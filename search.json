[
  {
    "objectID": "slides/03-filesystem-part3.html#contextutalització",
    "href": "slides/03-filesystem-part3.html#contextutalització",
    "title": "Sistema de fitxers (III)",
    "section": "Contextutalització",
    "text": "Contextutalització\nImaginem que disposem d’un servidor amb un únic disc dur, dividit en quatre particions. Aquestes particions són:\nFilesystem      Size  Used   Avail  Use%   Mounted on\n/dev/sda1       20G   5.5G   14G    29%    /\n/dev/sda2       10G   10G    0G     100%   /home\n/dev/sda3       5G    1G     4G     20%    /var\n/dev/sda4       5G    1G     4G     20%    /tmp\n\nQuè passa si la partició /home s’omple i la resta de particions tenen espai lliure?\n\n\nLa solució tradicional seria redimensionar les particions per alliberar espai per a /home.\n\n\n➡️ Això implica complexitat i possibilitat d’errors.\n\n\nPer tant, necessitem una solució més flexible que ens permeti redimensionar les particions sense haver de moure dades i en temps real.\n\n\nUna situació típica quan administrem servidors és que una partició s’ompli i la resta de particions tinguin espai lliure. En aquest cas, la partició /home s’ha omplert i la resta de particions tenen espai lliure. Per solucionar aquest problema, hauríem de redimensionar les particions per alliberar espai per a /home. Això implica complexitat i possibilitat d’errors. Per tant, necessitem una solució més flexible. Que ens permeti redimensionar les particions sense haver de moure dades i en temps real."
  },
  {
    "objectID": "slides/03-filesystem-part3.html#introducció-a-lvm-1",
    "href": "slides/03-filesystem-part3.html#introducció-a-lvm-1",
    "title": "Sistema de fitxers (III)",
    "section": "Introducció a LVM",
    "text": "Introducció a LVM\nLogical Volume Manager (LVM) és un sistema de gestió de discos que permet als administradors gestionar l’espai de disc de manera més flexible que amb les particions tradicionals, resolent problemes comuns.\n\nEn la situació anterior, LVM ens permetria en temps real i sense aturar el sistema:\n\nRedimensionar les particions /var i /tmp per alliberar espai per a /home.\nRedimensionar la partició /home a partir de l’espai alliberat.\n\n\n\no bé també ens permetria:\n\nAfegir un nou disc dur físic al servidor.\nUtilitzar aquest disc dur per a augmentar l’espai de la partició /home.\n\n\n\nCrear, eliminar, redimensionar i moure particions en temps real."
  },
  {
    "objectID": "slides/03-filesystem-part3.html#característiques-de-lvm",
    "href": "slides/03-filesystem-part3.html#característiques-de-lvm",
    "title": "Sistema de fitxers (III)",
    "section": "Característiques de LVM",
    "text": "Característiques de LVM\n\nAprovisionament: Permet combinar la capacitat de diferents dispositius físics per crear un únic o múltiples volums vírtuals. Per exemple, es poden combinar quatre discs durs de 1TB per crear un únic volum virtual de 4TB.\nElasticitat: Permet augmentar o disminuir l’espai assignat a un volum virtual, sense necessitat de reiniciar el sistema. Per exemple, si un volum virtual s’està quedant sense espai, es pot augmentar la seva mida o reduir-la.\nEscalabilitat: Permet afegir o eliminar dispositius físics al grup de volums per augmentar o disminuir l’espai d’emmagatzematge segons les necessitats. Per exemple, si es necessita més espai d’emmagatzematge, es poden afegir nous discs físics.\nResiliència: Atorga la capacitat de crear còpies de seguretat de les dades per protegir-les davant possibles errors o danys. Per exemple, es poden crear snapshots o miralls (mirroring)."
  },
  {
    "objectID": "slides/03-filesystem-part3.html#components-de-lvm",
    "href": "slides/03-filesystem-part3.html#components-de-lvm",
    "title": "Sistema de fitxers (III)",
    "section": "Components de LVM",
    "text": "Components de LVM\n\n\n\nPV (Physical Volume): Dispositiu físic que es pot utilitzar per emmagatzemar dades. Per exemple, un disc dur, una partició, un dispositiu RAID, etc.\nLV (Logical Volume): Bloc de dades que es pot utilitzar per emmagatzemar dades i contenir el seu propi sistema de fitxers. Equivalent a una partició de disc en un sistema sense LVM.\nVG (Volume Group): Agrupació de LVs i PVs en una unitat administrativa. Un VG pot contenir diversos PVs i LVs."
  },
  {
    "objectID": "slides/03-filesystem-part3.html#mapeig-i-extensions",
    "href": "slides/03-filesystem-part3.html#mapeig-i-extensions",
    "title": "Sistema de fitxers (III)",
    "section": "Mapeig i Extensions",
    "text": "Mapeig i Extensions\n\n\nPE (Physical Extent)\nÉs la unitat mínima d’emmagatzematge que es pot assignar a un PV. Normalment, un PE té una mida de 4MB.\nLE (Logical Extent)\nÉs la unitat mínima d’emmagatzematge que es pot assignar a un LV. Per exemple, si un LE té una mida de 4MB, un LV de 1GB tindrà 256 LE.\nObservacions\n\nCada VG s’encarrega de gestionar l’emmagatzematge físic (physical extents) mappejant-lo en emmagatzematge lògic (logical extents).\nEls PE i LE tenen la mateixa mida però són diferents en funció de l’estrategia de mapeig."
  },
  {
    "objectID": "slides/03-filesystem-part3.html#estratègies-de-mapeig",
    "href": "slides/03-filesystem-part3.html#estratègies-de-mapeig",
    "title": "Sistema de fitxers (III)",
    "section": "Estratègies de Mapeig",
    "text": "Estratègies de Mapeig"
  },
  {
    "objectID": "slides/03-filesystem-part3.html#exemple-i-consideracions",
    "href": "slides/03-filesystem-part3.html#exemple-i-consideracions",
    "title": "Sistema de fitxers (III)",
    "section": "Exemple i Consideracions",
    "text": "Exemple i Consideracions\n\n\n\n\n\nEs poden utilitzar dispositius de diferents mides i velocitats.\nUn PV només pot pertànyer a un VG.\nUn LV només pot pertànyer a un VG.\nUn VG pot contenir diversos PVs i LVs.\nLes funcions de mirror i snapshot requereixen més d’un PV."
  },
  {
    "objectID": "slides/03-filesystem-part3.html#snapshots",
    "href": "slides/03-filesystem-part3.html#snapshots",
    "title": "Sistema de fitxers (III)",
    "section": "Snapshots",
    "text": "Snapshots\nEls snapshots són còpies instantànies d’un LV en un moment concret. El seu funcionament és incremental: només es copien les dades que han canviat des de l’últim snapshot.\nPer què són útils?\n\nCòpies de seguretat: Realitzar còpies de seguretat de les dades sense aturar el sistema.\nRestauració: Restaurar les dades a un estat anterior.\nTests: Provar canvis en el sistema sense afectar les dades originals.\n\nCompte!\nLes instantànies ocupen espai en el VG. Per tant, si es crea una instantània i després es sobreescriu completament el LV original, l’instantània hauria de ser almenys tan gran com el LV original per poder emmagatzemar tots els canvis."
  },
  {
    "objectID": "slides/03-filesystem-part3.html#paquet-lvm2",
    "href": "slides/03-filesystem-part3.html#paquet-lvm2",
    "title": "Sistema de fitxers (III)",
    "section": "Paquet lvm2",
    "text": "Paquet lvm2\nEn la majoria de les distribucions de Linux, el paquet lvm2 permet la creació i gestió de dispositius LVM.\n\n\nDistribucions basades en Red Hat\ndnf search lvm2\ndnf install lvm2 -y\n\nDistribucions basades en Debian\napt search lvm2\napt install lvm2 -y\n\n\nEl funcionament del paquet lvm2 és similar en totes les distribucions de Linux. Per tant, les instruccions d’ús són similars i no importa la distribució que s’utilitzeu."
  },
  {
    "objectID": "slides/03-filesystem-part3.html#creació-de-pvs",
    "href": "slides/03-filesystem-part3.html#creació-de-pvs",
    "title": "Sistema de fitxers (III)",
    "section": "Creació de PVs",
    "text": "Creació de PVs\npvcreate PV [opcions]\nOn: PV pot ser un disc dur, una partició, un dispositiu RAID, etc.\n\n–dataalignment mida[Unitat]: Alinia el començament del PV.\n–dataalignmentoffset mida[Unitat]: Offset per modificar alineació de dades.\n–labelsector sector: Per defecte, el PV està etiquetat amb un identificador LVM2 al seu segon sector (sector 1). Això us permet utilitzar un sector diferent a prop de l’inici del disc (entre 0 i 3).\n–metadatasize mida[Unitat]: Mida de les metadades.\n–setphysicalvolumesize mida[Unitat]: Mida dels PE.\n–longhelp: Mostra totes les opcions (semblant a man pvcreate).\n–uuid uuid: Assigna un UUID al PV.\n\n\nÚs tradicional: pvcreate /dev/sdb sense opcions."
  },
  {
    "objectID": "slides/03-filesystem-part3.html#organització-interna-dels-pvs",
    "href": "slides/03-filesystem-part3.html#organització-interna-dels-pvs",
    "title": "Sistema de fitxers (III)",
    "section": "Organització interna dels PVs",
    "text": "Organització interna dels PVs"
  },
  {
    "objectID": "slides/03-filesystem-part3.html#exemples-de-lús-de-pvcreate",
    "href": "slides/03-filesystem-part3.html#exemples-de-lús-de-pvcreate",
    "title": "Sistema de fitxers (III)",
    "section": "Exemples de l’ús de pvcreate",
    "text": "Exemples de l’ús de pvcreate\n\nInicialització a partir d’un disc dur amb alineació de dades de 1MB començant des del sector 7.\n\n\npvcreate --dataalignment 1M --dataalignmentoffset 7s /dev/sdb\n\n\nInicialització a partir d’una partició amb un UUID específic.\n\n\npvcreate --uuid \"my-pv-uuid\" /dev/sdb1\n\n\nInicialització a partir d’un raid amb mida de metadades 128MB i 8MB per PE (enlloc de 4MB).\n\n\npvcreate --setphysicalvolumesize 8M --metadatasize 128M /dev/md0"
  },
  {
    "objectID": "slides/03-filesystem-part3.html#modificar-pvs-amb-pvchange",
    "href": "slides/03-filesystem-part3.html#modificar-pvs-amb-pvchange",
    "title": "Sistema de fitxers (III)",
    "section": "Modificar PVs amb pvchange",
    "text": "Modificar PVs amb pvchange\npvchange [opcions] PV\n\n–all: Aplica l’acció a tots els PVs (no cal especificar el PV).\n–addtag tag: Afegeix una etiqueta al PV.\n–deltag tag: Elimina una etiqueta del PV.\n–longhelp: Mostra totes les opcions (semblant a man pvcreate).\n–uuid uuid: Assigna un UUID al PV.\n–allocatable y/n: Activa o desactiva l’assignació de PE al PV.\n–autobackup y/n: Activa o desactiva la còpia de seguretat automàtica de les metadades."
  },
  {
    "objectID": "slides/03-filesystem-part3.html#redimensionar-pvs-amb-pvresize",
    "href": "slides/03-filesystem-part3.html#redimensionar-pvs-amb-pvresize",
    "title": "Sistema de fitxers (III)",
    "section": "Redimensionar PVs amb pvresize",
    "text": "Redimensionar PVs amb pvresize\npvresize [opcions] PV\n\n–setphysicalvolumesize mida[Unitat]: Redimensiona el PV.\n–longhelp: Mostra totes les opcions (semblant a man pvresize).\n\n\nConsideracions pràctiques\n\npvresize redimensiona el PV, però no redimensiona les particions o els sistemes de fitxers que conté. Hauràs de fer això manualment si és necessari.\npvresize refusarà reduir un PV si té extensiones assignades més enllà del nou final. Hauràs de moure o eliminar aquestes extensions primer.\npvresize permet redimensionar un PV encara que estigui inclòs en un VG amb LVs actius."
  },
  {
    "objectID": "slides/03-filesystem-part3.html#exemples-pvresize",
    "href": "slides/03-filesystem-part3.html#exemples-pvresize",
    "title": "Sistema de fitxers (III)",
    "section": "Exemples pvresize",
    "text": "Exemples pvresize\n\nExpandir un PV després d’ampliar la partició per utilitzar tot el nou espai disponible.\n\n\npvresize /dev/sdb1\n\n\nReduir un PV abans de reduir la partició (assegurar-se que la mida del PV és adequada per a la nova mida de la partició).\n\n\npvresize --setphysicalvolumesize 40G /dev/sdb1"
  },
  {
    "objectID": "slides/03-filesystem-part3.html#eliminar-pvs-amb-pvremove",
    "href": "slides/03-filesystem-part3.html#eliminar-pvs-amb-pvremove",
    "title": "Sistema de fitxers (III)",
    "section": "Eliminar PVs amb pvremove",
    "text": "Eliminar PVs amb pvremove\npvremove PV\n# Podeu obtenir la llista d'opcions amb pvremove --longhelp \n# o bé pvremove --help\n\npvremove elimina totes les metadades del PV, però no elimina les dades.\npvremove no permet eliminar PVs que estiguin en ús. Hauràs de moure o eliminar les extensions primer.\npvremove no permet eliminar PVs que formin part d’un VG. Hauràs de treure el PV del VG primer.\n\n\nPer eliminar les dades del PV, hauràs de sobreescriure el PV amb zeros dd if=/dev/zero of=PV bs=1M count=1 o bé formatejar el dispositiu."
  },
  {
    "objectID": "slides/03-filesystem-part3.html#obtenir-informació-pvs",
    "href": "slides/03-filesystem-part3.html#obtenir-informació-pvs",
    "title": "Sistema de fitxers (III)",
    "section": "Obtenir informació pvs",
    "text": "Obtenir informació pvs\npvs [opcions]\n\n–allpvs: Mostra tots els PVs, inclosos els PVs inactius.\n–all: Mostra tots els dispositius que no han estat inicialitzats com a PVs.\n–noheadings: No mostra la capçalera (bona combinació amb grep).\n–devices PV: Restringeix la sortida als PVs especificats.\n–options String: Permet seleccionar les columnes a mostrar. Per a més informació, consulteu pvs -o help.\n–longhelp: Mostra totes les opcions (semblant a man pvs).\n\n\nAltres opcions per a visualitzar información són: pvdisplay i pvscan. La principal diferència és que pvdisplay mostra la informació de tots els PVs, mentre que pvscan escaneja tots els dispositius per trobar PVs."
  },
  {
    "objectID": "slides/03-filesystem-part3.html#inicialització-de-vgs",
    "href": "slides/03-filesystem-part3.html#inicialització-de-vgs",
    "title": "Sistema de fitxers (III)",
    "section": "Inicialització de VGs",
    "text": "Inicialització de VGs\nvgcreate VG PV [opcions]\n\n–clustered y/n: Activa o desactiva el VG per a l’ús en un clúster.\n–maxlogicalvolumes nombre: Número màxim de LVs que es poden crear en el VG.\n–maxphysicalvolumes nombre: Número màxim de PVs que es poden afegir al VG.\n–physicalextentsize mida[Unitat]: Mida dels PE.\n–metadatasize mida[Unitat]: Mida de les metadades.\n–alloc [contiguous|cling|normal|anywhere]: Estratègia d’assignació de PE.\n–longhelp: Mostra totes les opcions (semblant a man vgcreate).\n\n\nQuan un VG s’inicialitza a partir d’un PV, els valors de la mida de les metadades, començament dels PE,… es prenen del PV, encara que s’hagin especificat opcions diferents amb vgcreate. ➡️ si voleu canviar-ho, pvremove. I després vgcreate amb les opcions desitjades.\n\n\n\nvgcreate incialitza el PV en cas que no estigui inicialitzat."
  },
  {
    "objectID": "slides/03-filesystem-part3.html#augmentar-o-reduir-vgs-amb-vgextend-i-vgreduce",
    "href": "slides/03-filesystem-part3.html#augmentar-o-reduir-vgs-amb-vgextend-i-vgreduce",
    "title": "Sistema de fitxers (III)",
    "section": "Augmentar o Reduir VGs amb vgextend i vgreduce",
    "text": "Augmentar o Reduir VGs amb vgextend i vgreduce\nvgextend VG PV [opcions] # Afegir un PV o una llista de PVs a un VG\nvgreduce VG PV [opcions] # Treure un PV o una llista de PVs d'un VG\n\nvgextend permet afegir PVs no inicialitzats. En aquest cas, vgextend inicialitzarà els PVs amb les opcions especificades de --labelsector, --metadatasize, --metadataignore, --pvmetadatacopies, --dataalignment, --dataalignmentoffset.\nvgreduce detecta que un o més PVs estan perduts, necessita vgreduce --removemissing per fer que les metadades del VG siguin consistents de nou."
  },
  {
    "objectID": "slides/03-filesystem-part3.html#altres-operacions-amb-vgs",
    "href": "slides/03-filesystem-part3.html#altres-operacions-amb-vgs",
    "title": "Sistema de fitxers (III)",
    "section": "Altres operacions amb VGs",
    "text": "Altres operacions amb VGs\n\nModificar les propietats d’un VG\n\n\nvgchange [opcions] VG\n\n\nEliminar un VG\n\n\nvgremove VG\n\n\nMostrar informació detallada d’un VG\n\n\nvgs\nvgdisplay VG\nvgscan\n\n\nTotes aquestes comandes tenen opcions similars a les ja vistes per a pvchange, pvremove, pvs, pvdisplay i pvscan. Per a més informació, consulteu el manual de cada comanda."
  },
  {
    "objectID": "slides/03-filesystem-part3.html#inicialització-de-lvs",
    "href": "slides/03-filesystem-part3.html#inicialització-de-lvs",
    "title": "Sistema de fitxers (III)",
    "section": "Inicialització de LVs",
    "text": "Inicialització de LVs\nlvcreate LV VG [opcions]\n\n-n|–name nom: Nom del LV.\n-L|–size mida[Unitat]: Mida del LV en unitats com MiB,GiB,TiB,….\n-l|–extents nombre: Defineix com un % del VG o bé com un nombre enter.\n-i|–stripes nombre: Defineix el nombre de stripes a utilitzar.\n-I|–stripesize mida[Unitat]: Defineix la mida de les stripes.\n-m|–mirrors nombre: Defineix el nombre de miralls a utilitzar.\n-s|–snapshot: Crea un snapshot del LV.\n-c|–chunksize mida[Unitat]: Defineix la mida dels chunks.\n-C|–contiguous y/n: Activa o desactiva l’assignació de PE contigus.\n-p|–permission r|rw: Defineix els permisos del LV.\n-t|–thinpool VG: Crea un thin pool LV.\n–longhelp: Mostra totes les opcions (semblant a man lvcreate)."
  },
  {
    "objectID": "slides/03-filesystem-part3.html#consideracions-pràctiques-sobre-lvcreate-i",
    "href": "slides/03-filesystem-part3.html#consideracions-pràctiques-sobre-lvcreate-i",
    "title": "Sistema de fitxers (III)",
    "section": "Consideracions pràctiques sobre lvcreate (I)",
    "text": "Consideracions pràctiques sobre lvcreate (I)\n\nlvcreate crea un nou LV en un VG. ➡️ Assigna extensions lògiques a les extensions físiques lliures del VG.\n\n\nQuè passaria si no hi ha prou espai lliure al VG? Hauríem d’ampliar el VG amb altres PVs (vgextend), o bé reduir o eliminar els LV existents (lvremove, lvreduce). Aquesta és una consideració important a tenir en compte quan es treballa amb grans volums de dades.\n\n\nlvcreate permet especificar quins PVs utilitzarà un nou LV. ➡️ lvcreate assignarà extensió físiques només dels PVs especificats. Això pot ser útil quan es vol controlar l’assignació d’espai en un sistema amb múltiples PVs.\nlvcreate també pot crear LV RAID especificant un tipus de LV en crear el LV. ➡️ Diferents nivells de RAID requereixen diferents nombres de PVs únics en el VG per a l’assignació. Això pot ser útil per a la redundància de dades i la tolerància a fallades."
  },
  {
    "objectID": "slides/03-filesystem-part3.html#consideracions-pràctiques-sobre-lvcreate-ii",
    "href": "slides/03-filesystem-part3.html#consideracions-pràctiques-sobre-lvcreate-ii",
    "title": "Sistema de fitxers (III)",
    "section": "Consideracions pràctiques sobre lvcreate (II)",
    "text": "Consideracions pràctiques sobre lvcreate (II)\n\nlvcreate també pot crear thin pools i cache pools. ➡️ Aquests no són utilitzables com a dispositius de bloc estàndard, però els noms dels LV actuen com a referències. Aquests pools ens poden interesar en servidors on molts usuaris comparteixen recursos d’emmagatzematge i es volen limitar els recursos d’emmagatzematge per usuari.\nlvcreate també pot crear LV thin i LV VDO. ➡️ Aquests es creen amb una mida virtual en lloc d’una mida física. Permeten sobreprovisionament i compressió de dades. ➡️ Tots el usuaris tenen dret a més espai del que realment tenen.\nPodeu utilitzar qualsevol --size o --extents per especificar la mida del LV.\nEn cas de no especificar un nom, es generarà un nom de LV amb el prefix lvol i un sufix numèric únic. Això pot ser útil quan es vol crear múltiples LVs de forma ràpida i eficient."
  },
  {
    "objectID": "slides/03-filesystem-part3.html#altres-operacions-amb-lvs",
    "href": "slides/03-filesystem-part3.html#altres-operacions-amb-lvs",
    "title": "Sistema de fitxers (III)",
    "section": "Altres operacions amb LVs",
    "text": "Altres operacions amb LVs\nEls LVs ens permeten les mateixes operacions amb opcions similars a les ja vistes per a PVs i VGs:\n\nMostrar informació detallada d’un LV: lvs, lvdisplay, lvscan.\nModificar les propietats d’un LV: lvchange.\nEliminar un LV: lvremove.\nIncrementar o disminuir la mida d’un LV: lvextend, lvreduce.\n\n\nPer a més informació, consulteu el manual de cada comanda o bé executeu comanda --help."
  },
  {
    "objectID": "slides/03-filesystem-part3.html#cas-pràctic-01-lvm-i-bootloaders",
    "href": "slides/03-filesystem-part3.html#cas-pràctic-01-lvm-i-bootloaders",
    "title": "Sistema de fitxers (III)",
    "section": "Cas Pràctic 01: LVM i BootLoaders",
    "text": "Cas Pràctic 01: LVM i BootLoaders\nDurant la realització d’una instal·lació d’un sistema operatiu, s’ha de decidir si utilitzar LVM per a la partició /boot o /boot/efi. Creus que és recomanable utilitzar LVM per a aquestes particions?\n\nNo, no és recomanable utilitzar LVM per a la partició /boot o /boot/efi. Els BootLoaders com GRUB no poden llegir els sistemes de fitxers LVM. Per tant, és millor utilitzar particions tradicionals per a /boot i /boot/efi.\n\n\nDurant el procés d’arrancada, el bootloader carrega el kernel i la imatge initramfs des de la partició /boot. Si aquesta partició està en un sistema de fitxers LVM, el bootloader no podrà llegir-la i no podrà carregar el sistema operatiu."
  },
  {
    "objectID": "slides/03-filesystem-part3.html#cas-pràctic-02-dispositiu-compartit-usb",
    "href": "slides/03-filesystem-part3.html#cas-pràctic-02-dispositiu-compartit-usb",
    "title": "Sistema de fitxers (III)",
    "section": "Cas Pràctic 02: Dispositiu compartit (USB)",
    "text": "Cas Pràctic 02: Dispositiu compartit (USB)\nAssumeix que tens un disc dur extern de 2TB i vols fer-ho servir per guardar còpies de seguretat de dos usuaris. El disc es connecta per usb físicament als dos dispositius. L’usuari 1 necessita 1TB i l’usuari 2 necessita 500GB. Assumeix que l’usuari 1 utilitza Windows i l’usuari 2 utilitza Linux. Recomanaries utilitzar LVM per aquest cas d’ús?\n\nNo, LVM és una tecnologia específica de Linux i no és compatible amb Windows. Per tant, no és recomanable utilitzar LVM per aquest cas d’ús. En aquest cas, seria millor utilitzar particions tradicionals per a cada usuari. Podeu crear dues particions: una de 1TB formatada amb NTFS per a l’usuari 1 (Windows) i una altra de 500GB formatada amb ext4 per a l’usuari 2 (Linux). La resta de l’espai es podria deixar sense particionar o crear una partició compartida si es desitja."
  },
  {
    "objectID": "slides/03-filesystem-part3.html#cas-pràctic-02-dispositiu-compartit-nas",
    "href": "slides/03-filesystem-part3.html#cas-pràctic-02-dispositiu-compartit-nas",
    "title": "Sistema de fitxers (III)",
    "section": "Cas Pràctic 02: Dispositiu compartit (NAS)",
    "text": "Cas Pràctic 02: Dispositiu compartit (NAS)\nAssumeix ara que el disc dur extern s’utilitza en un NAS on s’ofereix emmagatzematge compartit per a tots els usuaris en xarxa local. En aquest cas, recomanaries utilitzar LVM per aquest cas d’ús?\n\nSí, en aquest cas, LVM pot ser una bona opció per a la gestió de l’espai d’emmagatzematge compartit. LVM permet crear volums lògics que es poden redimensionar en temps real. Cada usuari podria tenir el seu LV per emmagatzemar les seves dades. Com el NAS és un servidor de xarxa, els usuaris podrien accedir als seus LVs a través de la xarxa; independentment del sistema operatiu que utilitzin els usuaris en els seus dispositius."
  },
  {
    "objectID": "slides/03-filesystem-part3.html#cas-pràctic-03-servidor-de-base-de-dades",
    "href": "slides/03-filesystem-part3.html#cas-pràctic-03-servidor-de-base-de-dades",
    "title": "Sistema de fitxers (III)",
    "section": "Cas Pràctic 03: Servidor de Base de Dades",
    "text": "Cas Pràctic 03: Servidor de Base de Dades\nConsiderant que hem de configurar un servidor de base de dades amb 4 discos durs de 1TB cadascun. Quins avantatges i desavantatges tindria la implementació de LVM en aquest context?\n\nLVM permet la creació de volums lògics que es poden distribuir en diversos discos físics, cosa que pot millorar el rendiment mitjançant el striping. ➡️ Aquesta configuració pot ser útil per a bases de dades que requereixen un alt rendiment d’E/S. Però, també augmenta la complexitat i pot induir a overheads addicionals dels Volums Lògics.\n\n\nA més, LVM admet instantànies, que poden ser útils per a les còpies de seguretat i la recuperació de les dades. Ara bé, si les instantànies es guarden en el mateix disc físic que la base de dades, i aquest disc falla, es perdran tant la base de dades com les instantànies.\n\n\nTambé permet afegir o eliminar discos físics sense temps d’inactivitat, cosa que millora la disponibilitat del servidor de base de dades. ➡️ Ens permet la seva ampliació en un futur sense haver de parar el servei."
  },
  {
    "objectID": "slides/03-filesystem-part3.html#cas-pràctic-04-errors-i-fallades-i",
    "href": "slides/03-filesystem-part3.html#cas-pràctic-04-errors-i-fallades-i",
    "title": "Sistema de fitxers (III)",
    "section": "Cas Pràctic 04: Errors i Fallades (I)",
    "text": "Cas Pràctic 04: Errors i Fallades (I)\nImagineu-vos que esteu treballant amb un grup de volums (VG1) que conté diversos discos físics, entre ells el PV1. A més, teniu un altre grup de volums (VG2) en un disc físic diferent (PV2) on guardeu les vostres instantànies. Què passaria amb les metadades de LVM i les instantànies si el disc físic PV1 falla?\n\nSi les metadades de LVM no estan en el disc fallat PV1, llavors els volums lògics que no estaven en el disc fallat segueixen estant disponibles. ➡️ En aquest cas, les metadades de LVM no es perden i es pot recuperar la informació dels volums lògics del VG1.\n\n\nNo obstant això, si el disc fallat PV1 contenia dades d’un volum lògic, aquestes dades es perdran a menys que tinguem una instantània. A més, si el disc fallat contenia una part d’un volum lògic que s’estenia per diversos discos (com en el cas d’un volum lògic distribuït o striped), tot el volum lògic pot quedar inutilitzable. ➡️ En aquest cas, les metadades de LVM es perden i no es pot recuperar la informació dels volums lògics del VG1.\n\n\nVG2 conté les instantànies, per tant, si el disc físic PV1 falla, les instantànies no es perdran. ➡️ Això permet restaurar les dades del volum lògic original del VG1 a partir de les instantànies del VG2."
  },
  {
    "objectID": "slides/03-filesystem-part3.html#cas-pràctic-05-escalabilitat-dapps-i",
    "href": "slides/03-filesystem-part3.html#cas-pràctic-05-escalabilitat-dapps-i",
    "title": "Sistema de fitxers (III)",
    "section": "Cas Pràctic 05: Escalabilitat d’Apps (I)",
    "text": "Cas Pràctic 05: Escalabilitat d’Apps (I)\nUna empresa està experimentant un ràpid creixement i necessita implementar un nou servidor per donar suport a una nova aplicació crítica per al negoci. El departament d’IT té pressupost limitat i només té disponible un emmagatzematge de 2TB per a aquest nou servidor. L’aplicació requereix un mínim de 1TB d’emmagatzematge per funcionar correctament, però es preveu que el seu ús creixerà ràpidament en els propers mesos.\n\nCom a administrador us plantejeu la possibilitat d’utilitzar el thin provisioning de LVM per donar suport a l’aplicació en creixement. Aquesta tècnica permet sobreprovisionar l’espai d’emmagatzematge, és a dir, assignar més espai del que realment teniu. Això és possible perquè el thin provisioning de LVM només assigna l’espai d’emmagatzematge real a mesura que l’aplicació l’utilitza.➡️ Si assigneu 4TB d’emmagatzematge a l’aplicació en un VG format pel disc de 2TB, inicialment només s’utilitzarà l’espai que l’aplicació necessita realment. Així, podreu planificar una ampliació del disc dur a 4TB en el futur sense haver de parar el servei."
  },
  {
    "objectID": "slides/03-filesystem-part3.html#cas-pràctic-05-escalabilitat-dapps-ii",
    "href": "slides/03-filesystem-part3.html#cas-pràctic-05-escalabilitat-dapps-ii",
    "title": "Sistema de fitxers (III)",
    "section": "Cas Pràctic 05: Escalabilitat d’Apps (II)",
    "text": "Cas Pràctic 05: Escalabilitat d’Apps (II)\nNo obstant això, que pot passar si les vostres previsions no són correctes i el creixement es mes rápid de l’esperat. ➡️ L’aplicació intenta escriure més de 2TB de dades al disc.\n\nEl thin provisioning de LVM no evitarà que l’aplicació s’aturi o es produeixin errors d’E/S quan l’aplicació excedeixi la capacitat real. ➡️ Quan l’aplicació intenti escriure més de 2TB de dades al disc, es produirà un error d’E/S, ja que no hi haurà prou espai d’emmagatzematge disponible per emmagatzemar les dades.\n\n\nEn aquest cas, es necessitarà afegir més espai d’emmagatzematge al grup de volums i ampliar el volum lògic thin provisioned per donar suport a l’aplicació en creixement."
  },
  {
    "objectID": "slides/03-filesystem-part3.html#cas-pràctic-05-escalabilitat-dapps-iii",
    "href": "slides/03-filesystem-part3.html#cas-pràctic-05-escalabilitat-dapps-iii",
    "title": "Sistema de fitxers (III)",
    "section": "Cas Pràctic 05: Escalabilitat d’Apps (III)",
    "text": "Cas Pràctic 05: Escalabilitat d’Apps (III)\nEn la situació anterior, heu decidit utilitzar el thin provisioning de LVM per donar suport a l’aplicació en creixement. Però, com a administrador de sistemes, us preocupa que l’aplicació pugui aturar-se o produir errors d’E/S si l’espai d’emmagatzematge s’omple ràpidament. Què faríeu per reduir el risc d’aturades i errors d’E/S en aquest escenari?\n\nUna opció seria implementar un sistema de monitoreig i alertes que supervisi l’ús de l’espai d’emmagatzematge del grup de volums. Quan l’ús d’emmagatzematge superi un determinat llindar, el sistema generaria una alerta per afegir més espai d’emmagatzematge al grup de volums i ampliar el volum lògic thin provisioned per donar suport a l’aplicació en creixement."
  },
  {
    "objectID": "slides/03-filesystem-part3.html#laboratoris",
    "href": "slides/03-filesystem-part3.html#laboratoris",
    "title": "Sistema de fitxers (III)",
    "section": "Laboratoris",
    "text": "Laboratoris\n\nLaboratori 01: Instal·lació de LVM a AlmaLinux\nLaboratori 02: Gestió de LVM a AlmaLinux"
  },
  {
    "objectID": "slides/03-filesystem-part3.html#laboratori-01-installació-de-lvm-a-almalinux",
    "href": "slides/03-filesystem-part3.html#laboratori-01-installació-de-lvm-a-almalinux",
    "title": "Sistema de fitxers (III)",
    "section": "Laboratori 01: Instal·lació de LVM a AlmaLinux",
    "text": "Laboratori 01: Instal·lació de LVM a AlmaLinux\nRequeriments\n\nMàquina virtual amb 1 disc dur de 20 GB, 1 GB de RAM i 1 CPU.\nImatge ISO d’AlmaLinux.\n\n\nTasques\n\nInstal·lar AlmaLinux i configurar LVM durant la instal·lació.\nCrearem un PV a partir del disc dur principal de 20GB.\nCrearem un VG anomenta almalinux.\n/ serà un LV amb un sistema de fitxers xfs de 16,4 GB (almalinx-root).\n/boot i boot/efi seran particions tradicionals de 600MiB i 1024MiB respectivament.\nswap serà un LV de 2GB (almalinux-swap)."
  },
  {
    "objectID": "slides/03-filesystem-part3.html#laboratori-01-selecció-de-dispositius",
    "href": "slides/03-filesystem-part3.html#laboratori-01-selecció-de-dispositius",
    "title": "Sistema de fitxers (III)",
    "section": "Laboratori 01: Selecció de dispositius",
    "text": "Laboratori 01: Selecció de dispositius"
  },
  {
    "objectID": "slides/03-filesystem-part3.html#laboratori-01-configuració-lvm",
    "href": "slides/03-filesystem-part3.html#laboratori-01-configuració-lvm",
    "title": "Sistema de fitxers (III)",
    "section": "Laboratori 01: Configuració LVM",
    "text": "Laboratori 01: Configuració LVM"
  },
  {
    "objectID": "slides/03-filesystem-part3.html#laboratori-01-configuració-de-les-particions",
    "href": "slides/03-filesystem-part3.html#laboratori-01-configuració-de-les-particions",
    "title": "Sistema de fitxers (III)",
    "section": "Laboratori 01: Configuració de les particions",
    "text": "Laboratori 01: Configuració de les particions"
  },
  {
    "objectID": "slides/03-filesystem-part3.html#laboratori-02-configuració-manual-lvm",
    "href": "slides/03-filesystem-part3.html#laboratori-02-configuració-manual-lvm",
    "title": "Sistema de fitxers (III)",
    "section": "Laboratori 02: Configuració manual LVM",
    "text": "Laboratori 02: Configuració manual LVM\nRequeriments\n\nAfegir un disc dur secundari de 10 GB a la màquina virtual.\n\n\nTasques\n\nCrear un PV a partir del disc dur secundari.\nCrear un VG anomenat datavg a partir del PV.\nCrear un LV anomenat home amb un sistema de fitxers ext4 de 5GB.\nMuntarem el LV home a /home.\nRedimensionarem el LV en calent."
  },
  {
    "objectID": "slides/03-filesystem-part3.html#laboratori-02-creació-de-pvs-vgs-i-lvs",
    "href": "slides/03-filesystem-part3.html#laboratori-02-creació-de-pvs-vgs-i-lvs",
    "title": "Sistema de fitxers (III)",
    "section": "Laboratori 02: Creació de PVs, VGs i LVs",
    "text": "Laboratori 02: Creació de PVs, VGs i LVs\n\nCreació d’un PV amb el dispositiu /dev/vdb:\n\n\npvcreate /dev/vdb\n\n\nCreació d’un VG anomenat datavg amb el PV /dev/vdb:\n\n\nvgcreate datavg /dev/vdb\n\n\nCreació d’un LV de 5GB anomenat home en el VG datavg:\n\n\nlvcreate -L 5GB M -n home datavg"
  },
  {
    "objectID": "slides/03-filesystem-part3.html#laboratori-02-creació-de-sistema-de-fitxers-i-muntatge",
    "href": "slides/03-filesystem-part3.html#laboratori-02-creació-de-sistema-de-fitxers-i-muntatge",
    "title": "Sistema de fitxers (III)",
    "section": "Laboratori 02: Creació de sistema de fitxers i muntatge",
    "text": "Laboratori 02: Creació de sistema de fitxers i muntatge\n\nCreació d’un sistema de fitxers ext4 en el LV home:\n\n\nmkfs.ext4 /dev/datavg/home\n\n\nMuntatge del LV home en el directori /home:\n\n\nmount /dev/datavg/home /home"
  },
  {
    "objectID": "slides/03-filesystem-part3.html#laboratori-02-ampliació-lvs",
    "href": "slides/03-filesystem-part3.html#laboratori-02-ampliació-lvs",
    "title": "Sistema de fitxers (III)",
    "section": "Laboratori 02: Ampliació LVs",
    "text": "Laboratori 02: Ampliació LVs\n\nAmpliació del LV home a 7GB:\n\n\nlvextend -L 7GB /dev/datavg/home\n\n\nRedimensionar el sistema de fitxers ext4:\n\n\nresize2fs /dev/datavg/home"
  },
  {
    "objectID": "slides/03-filesystem-part3.html#laboratori-02-reducción-lvs",
    "href": "slides/03-filesystem-part3.html#laboratori-02-reducción-lvs",
    "title": "Sistema de fitxers (III)",
    "section": "Laboratori 02: Reducción LVs",
    "text": "Laboratori 02: Reducción LVs\n\nReducció del sistema de fitxers ext4:\n\n\nresize2fs /dev/datavg/home 6G\n\n\nReducció del LV home a 6GB:\n\n\nlvreduce -L 6GB /dev/datavg/home"
  },
  {
    "objectID": "slides/03-filesystem-part3.html#exercicis",
    "href": "slides/03-filesystem-part3.html#exercicis",
    "title": "Sistema de fitxers (III)",
    "section": "Exercicis",
    "text": "Exercicis\n\nDeplegament d’un servidor web amb LVM"
  },
  {
    "objectID": "slides/03-filesystem-part3.html#thats-all",
    "href": "slides/03-filesystem-part3.html#thats-all",
    "title": "Sistema de fitxers (III)",
    "section": "That’s all",
    "text": "That’s all\n\n\n\n\n\n\n\n\n\nTake Home Message\n\n\n\nLVM és una eina potent que simplifica la gestió de l’espai d’emmagatzematge en sistemes Linux.\nOfereix als administradors de sistemes la flexibilitat de crear, modificar i eliminar particions de manera dinàmica sense necessitat d’aturar el sistema."
  },
  {
    "objectID": "slides/03-filesystem-part1.html#necessitat-dun-sistema-de-fitxers-i",
    "href": "slides/03-filesystem-part1.html#necessitat-dun-sistema-de-fitxers-i",
    "title": "Sistema de fitxers (I)",
    "section": "Necessitat d’un Sistema de Fitxers (I)",
    "text": "Necessitat d’un Sistema de Fitxers (I)\nLa implementació d’un Sistema de Fitxers (FS) és essencial per a l’organització, emmagatzematge i recuperació eficient de la informació en qualsevol sistema operatiu modern.\n\n\n\n\n\n\n\nObservació\n\n\nEn els sistemes operatius moderns (UNIX-like), el seu rol s’estén molt més enllà de la gestió de dades persistents al disc, abracant una filosofia fonamental.\n\n\n\n\n\nEverything is a File"
  },
  {
    "objectID": "slides/03-filesystem-part1.html#necessitat-dun-sistema-de-fitxers-ii",
    "href": "slides/03-filesystem-part1.html#necessitat-dun-sistema-de-fitxers-ii",
    "title": "Sistema de fitxers (I)",
    "section": "Necessitat d’un Sistema de Fitxers (II)",
    "text": "Necessitat d’un Sistema de Fitxers (II)\n\n\n\n\n\n\n\n\nTipus de Recurs\nExemple de Path\nSistema de Fitxers\n\n\n\n\nProcés/Estat del Kernel\n/proc/PID (p. ex., /proc/1234/status)\nprocfs (Memòria, no disc)\n\n\nDispositiu de Blocs\n/dev/sda1\ndevfs o udev\n\n\nPunts de Configuració\n/etc/hosts, /usr/bin/comando\nFS persistent (Ext4, XFS)\n\n\nDades d’Usuari\n/home/username/documents\nFS persistent\n\n\nXarxa\n/dev/tcp/80 (en certs entorns, e.g., Plan 9)\nÚs de Sockets com a File Descriptors\n\n\n\n\n\n\n\n\n\n\nAvantatge\n\n\nLa implementació d’un sistema de fitxers permet unificar l’accés a recursos heterogenis. El kernel pot tractar una E/S a /dev/sda1 (blocs físics) i una E/S a /proc/cpuinfo (informació virtual) utilitzant la mateixa API. API."
  },
  {
    "objectID": "slides/03-filesystem-part1.html#dispositius-i-device-files",
    "href": "slides/03-filesystem-part1.html#dispositius-i-device-files",
    "title": "Sistema de fitxers (I)",
    "section": "Dispositius i Device Files",
    "text": "Dispositius i Device Files\nUn Fitxer de Dispositiu (Device File o Node) és un nom assignat a un dispositiu d’E/S (Entrada/Sortida), ja sigui físic (disc, targeta de so) o lògic (port de xarxa, terminal).\n\n\n\n\n\n\n\n\nTipus de Dispositiu\nExemples Comuns\nCaracterística\n\n\n\n\nBlocs (Block Devices)\n/dev/sda (Disc sencer), /dev/sdb1 (Partició), /dev/md0 (RAID)\nTransfereixen dades en blocs de mida fixa. Són cachejables i permeten accés aleatori.\n\n\nCaràcters (Character Devices)\n/dev/ttyX (Terminals), /dev/lp0 (Port Paral·lel), /dev/input/mouse0\nTransfereixen dades seqüencialment caràcter a caràcter. No tenen caching de blocs.\n\n\n\nEls drivers és el conjunt de rutines del kernel que defineix com s’ha de dur a terme la comunicació específica amb el Hardware mitjançant interrupcions, accés directe a memòria (DMA) i E/S programada. Sense el driver, el fitxer a /dev seria inútil."
  },
  {
    "objectID": "slides/03-filesystem-part1.html#virtual-filesystem-switch-vfs",
    "href": "slides/03-filesystem-part1.html#virtual-filesystem-switch-vfs",
    "title": "Sistema de fitxers (I)",
    "section": "Virtual Filesystem Switch (VFS)",
    "text": "Virtual Filesystem Switch (VFS)\nUn Sistema de Fitxers (FS) és la capa lògica fonamental que gestiona l’accés i l’organització dels objectes (fitxers i directoris) sobre un dispositiu d’emmagatzematge.\n\n\n\n\n\n\n\nMúltiples FS actius\n\n\nÉs habitual que un sistema operatiu gestioni simultàniament diverses instàncies de sistemes de fitxers diferents:\n\nExt4 per a dades d’usuari (/home)\nBtrfs per a backups automàtics\ntmpfs per a fitxers temporals (/tmp)\nprocfs per a informació del kernel (/proc)\n\nCadascun muntat en un punt d’accés lògic diferent."
  },
  {
    "objectID": "slides/03-filesystem-part1.html#abstraccions-comunes-del-vfs",
    "href": "slides/03-filesystem-part1.html#abstraccions-comunes-del-vfs",
    "title": "Sistema de fitxers (I)",
    "section": "Abstraccions Comunes del VFS",
    "text": "Abstraccions Comunes del VFS\nTot i les diferències estructurals a nivell de disc, el VFS (Virtual Filesystem Switch) del kernel utilitza abstraccions uniformes per oferir una interfície consistent als processos.\n\n\n\n\n\n\n\n\n\nAbstracció\nUbicació\nFunció Tècnica\nPersistència\n\n\n\n\nSuperbloc\nDisc + Memòria\nConté metadata global del FS: tipus, mida, estat, punters clau\nPersistent\n\n\nInode\nDisc + Memòria\nMetadata del fitxer: permisos, timestamps, punters a blocs de dades\nPersistent\n\n\nDentry\nNomés Memòria\nEntrada de Directori: cacheja nom del fitxer ↔︎ inode\nTemporal\n\n\nFile Object\nNomés Memòria\nRepresenta un fitxer obert per un procés (file descriptors)\nTemporal\n\n\n\nPermet que un programa pugui treballar amb fitxers Ext4, XFS, NTFS o FAT32 sense modificar ni una sola línia de codi."
  },
  {
    "objectID": "slides/03-filesystem-part1.html#jerarquia-lògica-de-les-abstraccions",
    "href": "slides/03-filesystem-part1.html#jerarquia-lògica-de-les-abstraccions",
    "title": "Sistema de fitxers (I)",
    "section": "Jerarquia Lògica de les Abstraccions",
    "text": "Jerarquia Lògica de les Abstraccions\nPer entendre com el kernel mapeja un nom de fitxer a les dades, visualitzem la interacció entre les estructures in-memory i on-disk.\n\n\n\n\n\nclassDiagram\n    direction LR\n    \n    class Superbloc {\n        &lt;&lt;On-Disk i In-Memory&gt;&gt;\n        + Tipus FS (Ext4, XFS)\n        + Mida del Volum\n        + Punter a llistes d'Inodes Lliures\n    }\n\n    class Inode {\n        &lt;&lt;On-Disk i In-Memory&gt;&gt;\n        + Num Inode Únic\n        + Pointers a Blocs de Dades\n        + Permisos/ACLs\n        + UID/GID, Timestamps\n    }\n\n    class Dentry {\n        &lt;&lt;In-Memory Cache&gt;&gt;\n        + Nom del Fitxer/Directori\n        + Punter a Inode\n        + Punter al Dentry Pare\n    }\n\n    class FileObject {\n        &lt;&lt;In-Memory&gt;&gt;\n        + File Descriptor FD\n        + Offset de Lectura/Escriptura Actual\n        + Punter a Dentry (Path)\n    }\n\n    Superbloc \"1\" --&gt; \"*\" Inode : Gestiona\n    Dentry \"1\" --&gt; \"1\" Inode : Caching · Nom -&gt; Metadata\n    FileObject \"1\" --&gt; \"1\" Dentry : Resolució de Path\n    Inode \"1\" --&gt; \"*\" DataBlocks : Adreçament\n    \n    %% Colors per a claredat tècnica\n    classDef memory fill:#eaf7ff,stroke:#007bff\n    classDef disk fill:#f9f5dd,stroke:#c4aa18\n    class Dentry\n    FileObject memory\n    class Inode\n    Superbloc disk\n\n\n\n\n\n\n\n\n\n\n\n\n\nImpacte del Dentry\n\n\nUna Dentry Cache saturada o poc eficient pot degradar significativament el rendiment del sistema (I/O latency), ja que el kernel es veu forçat a re-llegir l’estructura de directoris directament del disc.\n\n\n\n\n\n\nFileObject: Un procés obre un fitxer, creant un FileObject amb un File Descriptor.\nDentry (Cache): El FileObject resol el camí a través d’una cadena de Dentries (des de la muntura fins al fitxer final). El Dentry proporciona l’associació Nom → Inode.\nInode: El número d’Inode permet al VFS carregar les metadades on-disk a memòria. Aquesta estructura conté els punters directes i indirectes als blocs de dades."
  },
  {
    "objectID": "slides/03-filesystem-part1.html#relacions-in-memory-del-vfs",
    "href": "slides/03-filesystem-part1.html#relacions-in-memory-del-vfs",
    "title": "Sistema de fitxers (I)",
    "section": "Relacions In-Memory del VFS",
    "text": "Relacions In-Memory del VFS\n\nMúltiples descriptors de fitxer poden apuntar al mateix fitxer (dup()).\nMúltiples abstraccions de fitxer poden apuntar a la mateixa Dentry (obrim el mateix path diverses vegades).\nMúltiples Dentries poden apuntar al mateix Inode (Hard Links)."
  },
  {
    "objectID": "slides/03-filesystem-part1.html#el-superbloc",
    "href": "slides/03-filesystem-part1.html#el-superbloc",
    "title": "Sistema de fitxers (I)",
    "section": "El Superbloc",
    "text": "El Superbloc\nEl Superbloc és el punt de referència absolut de qualsevol Sistema de Fitxers (FS). Sense aquesta estructura, el kernel no pot ni tan sols intentar muntar el volum.\n\n\n\n\n\n\n\nAvís\n\n\nSi el Superbloc es corromp (per un error de disc o d’E/S), el sistema de fitxers esdevé inaccessible fins que es restaura una de les seves còpies de seguretat (backup copies).\n\n\n\n\nPer aquest motiu, els FS moderns mantenen múltiples còpies del superbloc distribuïdes pel volum."
  },
  {
    "objectID": "slides/03-filesystem-part1.html#organització-física-del-superbloc",
    "href": "slides/03-filesystem-part1.html#organització-física-del-superbloc",
    "title": "Sistema de fitxers (I)",
    "section": "Organització Física del Superbloc",
    "text": "Organització Física del Superbloc\n\n\nEl diagrama mostra que el superbloc es troba típicament a l’inici del sistema de fitxers i que hi ha diversos blocs utilitzats amb diferents propòsits: alguns per emmagatzemar dentries, alguns per emmagatzemar inodes i alguns per emmagatzemar blocs de dades d’usuari. També hi ha blocs utilitzats per gestionar els blocs lliures disponibles (p. ex., mapes de bits per als sistemes de fitxers simples)."
  },
  {
    "objectID": "slides/03-filesystem-part1.html#abstraccions-del-superbloc",
    "href": "slides/03-filesystem-part1.html#abstraccions-del-superbloc",
    "title": "Sistema de fitxers (I)",
    "section": "Abstraccions del Superbloc",
    "text": "Abstraccions del Superbloc\n\n\n\n\n\n\n\n\nComponent\nFunció\nUbicació\n\n\n\n\nSuperbloc\nConté la metadata global del FS: tipus, mida, estat, i punters clau.\nInici del FS (i còpies de seguretat).\n\n\nIMAP (Inode Map)\nBitmap per a l’assignació i desassignació d’Inodes. Indica quins Inodes estan lliures o en ús dins de la IZONE.\nBloc(s) assignat(s) pel Superbloc.\n\n\nDMAP (Data Map)\nBitmap per a l’assignació i desassignació de Blocs de Dades. Indica quins blocs de la DZONE estan lliures o en ús.\nBloc(s) assignat(s) pel Superbloc.\n\n\nIZONE\nÀrea que conté les estructures d’Inode dels fitxers.\nDesprés dels mapes.\n\n\nDZONE\nÀrea que conté les dades d’usuari (el contingut real dels fitxers).\nDesprés de la IZONE."
  },
  {
    "objectID": "slides/03-filesystem-part1.html#estructura-i-implementació-del-superbloc",
    "href": "slides/03-filesystem-part1.html#estructura-i-implementació-del-superbloc",
    "title": "Sistema de fitxers (I)",
    "section": "Estructura i Implementació del Superbloc",
    "text": "Estructura i Implementació del Superbloc\nEl Superbloc no només s’autodefineix, sinó que defineix l’arquitectura de tota la partició:\n\nfs_type: El tipus de FS (p. ex., EXT4_MAGIC).\ns_blocks_count: El nombre total de blocs al FS.\ns_log_block_size: Defineix la mida del bloc lògic (p. ex., 1K, 4K). Tota la I/O es fa en aquesta unitat.\nPunters a Bitmaps: Adreces del primer bloc de l’IMAP i el DMAP.\nEstat del FS: Indica si el FS va ser desmuntat netament o si va patir un crash (s_state - important per al fsck)."
  },
  {
    "objectID": "slides/03-filesystem-part1.html#mapes-de-bits-bitmaps",
    "href": "slides/03-filesystem-part1.html#mapes-de-bits-bitmaps",
    "title": "Sistema de fitxers (I)",
    "section": "Mapes de Bits (Bitmaps)",
    "text": "Mapes de Bits (Bitmaps)\nEls mapes de bits són crucials per a l’eficiència en l’assignació:\n\nIMAP (Inode Bitmap): Cada bit representa l’estat d’un únic Inode a la IZONE. 1 = En ús, 0 = Lliure.\nDMAP (Data Bitmap): Cada bit representa l’estat d’un únic bloc a la DZONE. 1 = Ocupat per dades, 0 = Lliure per assignació.\n\n\n\n\n\n\n\nOptimització (Caching)\n\n\nQuan el FS es munta, el kernel carrega el Superbloc i, almenys parcialment, els mapes IMAP i DMAP a la memòria. Això permet que les noves assignacions de fitxers i blocs siguin extremadament ràpides sense requerir una E/S de disc constant.\n\n\n\n\n\n\n\n\n\n\nFS Grans\n\n\nEs carreguen parcialment i a demanda per no gastar massa memòria en FS grans."
  },
  {
    "objectID": "slides/03-filesystem-part1.html#mapping-crides-de-sistema-vfs",
    "href": "slides/03-filesystem-part1.html#mapping-crides-de-sistema-vfs",
    "title": "Sistema de fitxers (I)",
    "section": "Mapping: Crides de Sistema → VFS",
    "text": "Mapping: Crides de Sistema → VFS\n\n\n\n\n\n\n\n\n\n\nCrida al Sistema\nOperació VFS\nDescripció\n\n\n\n\nmount()\nvfs_mount()\nMuntar un FS.\n\n\nopen()\nvfs_open()\nObrir un fitxer (i obtenir un FD).\n\n\nstat() / fstat()\nvfs_stat() / vfs_fstat()\nConsultar atributs del fitxer.\n\n\nread() / write()\nvfs_read() / vfs_write()\nLlegir o escriure dades.\n\n\ncreate() / delete()\nvfs_create() / vfs_unlink()\nCrear i eliminar fitxers.\n\n\nclose()\nvfs_close()\nTancar un fitxer\n\n\n\n\nEl VFS és l’abstracció de Linux que permet gestionar múltiples tipus de FS (Ext4, XFS, NTFS) de manera transparent.\n\n\n\n\n\ngraph TD\n    A[Crida al Sistema open, read] --&gt; B{VFS};\n    B --&gt;|Operació abstracta| C1[Driver FS Específic Ext4];\n    B --&gt;|Operació abstracta| C2[Driver FS Específic XFS];\n    C1 --&gt; D[Subsistema d'Emmagatzematge E/S];\n    C2 --&gt; D;\n    \n    style B fill:#eaf7ff,stroke:#007bff\n    style C1 fill:#f9f5dd,stroke:#c4aa18\n    style C2 fill:#f9f5dd,stroke:#c4aa18"
  },
  {
    "objectID": "slides/03-filesystem-part1.html#montatge-dun-fs",
    "href": "slides/03-filesystem-part1.html#montatge-dun-fs",
    "title": "Sistema de fitxers (I)",
    "section": "Montatge d’un FS",
    "text": "Montatge d’un FS\n# Sintaxi: mount -t &lt;fs_type&gt; &lt;device&gt; &lt;mount_point&gt;\nmount -t ext4 /dev/nvme0n1p2 /home\nmount -t btrfs /dev/sdb1 /backup\nmount -t tmpfs -o size=1G tmpfs /tmp/ramdisk\n\n\n\n\n\n\n\n\nPas\nDescripció\nImplicació\n\n\n\n\n1. Entrada/Sortida\nInput: Dispositiu de blocs (Partició). Output: Dentry arrel del FS.\n\n\n\n2. Check Device\nValidació de l’estructura inicial del FS.\n\n\n\n3. Llegir Superbloc\nDeterminar paràmetres (mida de bloc, magic number). Carregar el Superbloc a memòria.\nCrític: Estableix el context global.\n\n\n4. Crear Inode i Dentry\nLocalitzar el Root Inode (e.g., inode 2 a Ext4) i crear l’estructura Dentry arrel a la memòria.\nInici de la navegació lògica."
  },
  {
    "objectID": "slides/03-filesystem-part1.html#obertura-dun-fitxer",
    "href": "slides/03-filesystem-part1.html#obertura-dun-fitxer",
    "title": "Sistema de fitxers (I)",
    "section": "Obertura d’un Fitxer",
    "text": "Obertura d’un Fitxer\n\n\n\n\n\nsequenceDiagram \n    participant P as Procés\n    participant VFS as VFS (Kernel)\n    participant FS as Driver de FS (read_inode)\n\n    P-&gt;&gt;VFS: open -&gt; /a/b/fitxer.txt \n    VFS-&gt;&gt;VFS: 1. Per cada component a, b, fitxer.txt:\n    VFS-&gt;&gt;VFS: Resoldre Dentry Pare (Cache)\n    VFS-&gt;&gt;FS: 2. Carregar Inode si no està en cache (via Num. Inode)\n    VFS-&gt;&gt;VFS: 3. Final: Crear nou **FILE OBJECT**\n    VFS-&gt;&gt;P: 4. Assignar **File Descriptor** (FD)"
  },
  {
    "objectID": "slides/03-filesystem-part1.html#consultar-atributs",
    "href": "slides/03-filesystem-part1.html#consultar-atributs",
    "title": "Sistema de fitxers (I)",
    "section": "Consultar Atributs",
    "text": "Consultar Atributs\n\n\n\n\n\nsequenceDiagram\n    participant P as Procés\n    participant VFS as VFS (Kernel)\n    participant FS as Driver de FS (read_inode)\n    P-&gt;&gt;VFS: stat -&gt; fitxer.txt o fstat -&gt; FD\n    VFS-&gt;&gt;VFS: 1. Accés a l'Inode via FD\n    VFS-&gt;&gt;FS: 2. Si no està en cache, llegir Inode del disc\n    FS--&gt;&gt;VFS: 3. Retornar Atributs\n    VFS--&gt;&gt;P: 4. Retornar Atributs UID, GID, Permisos, Mida, Timestamps"
  },
  {
    "objectID": "slides/03-filesystem-part1.html#operacions-de-lectura",
    "href": "slides/03-filesystem-part1.html#operacions-de-lectura",
    "title": "Sistema de fitxers (I)",
    "section": "Operacions de Lectura",
    "text": "Operacions de Lectura\n\n\n\n\n\nsequenceDiagram\n    participant P as Procés\n    participant VFS as VFS \n    participant FS as Driver de FS · read\n    P-&gt;&gt;VFS: read -&gt; FD, buf, len\n    VFS-&gt;&gt;VFS: 1. Validar FD i permisos\n    VFS-&gt;&gt;VFS: 2. Calcular blocs a llegir -&gt; offset, len\n    VFS-&gt;&gt;FS: 3. Llegir dades file-&gt;dentry-&gt;inode-&gt;data blocks\n    FS--&gt;&gt;VFS: 4. Retornar dades a VFS\n    VFS--&gt;&gt;P: 5. Copiar dades a l'espai d'usuari"
  },
  {
    "objectID": "slides/03-filesystem-part1.html#operacions-descriptura",
    "href": "slides/03-filesystem-part1.html#operacions-descriptura",
    "title": "Sistema de fitxers (I)",
    "section": "Operacions d’Escriptura",
    "text": "Operacions d’Escriptura\n\n\n\n\n\nsequenceDiagram\n    participant P as Procés\n    participant VFS as VFS\n    participant PC as Page Cache\n    participant FS as Driver FS\n    participant J as Journal\n    participant BD as Block Device\n\n    P-&gt;&gt;VFS: write -&gt; fd=5, buffer, 4096\n    VFS-&gt;&gt;VFS: Validar FD i permisos d'escriptura\n    VFS-&gt;&gt;VFS: Calcular nous blocs necessaris\n    \n    alt Fitxer necessita créixer\n        VFS-&gt;&gt;FS: Assignar nous blocs de dades\n        FS-&gt;&gt;FS: Actualizar bitmaps i inode\n        FS-&gt;&gt;J: Registrar transacció al journal\n    end\n    \n    VFS-&gt;&gt;PC: Escriure dades a la page cache · dirty pages\n    VFS--&gt;&gt;P: Retornar bytes escrits \n    \n    Note over PC,BD: Writeback asíncron \n    PC-&gt;&gt;BD: Flush dirty pages al disc\n    J-&gt;&gt;BD: Commit transacció journal"
  },
  {
    "objectID": "slides/03-filesystem-part1.html#escriptura-asíncrona-i-writeback",
    "href": "slides/03-filesystem-part1.html#escriptura-asíncrona-i-writeback",
    "title": "Sistema de fitxers (I)",
    "section": "Escriptura Asíncrona i Writeback",
    "text": "Escriptura Asíncrona i Writeback\nLa escriptura asíncrona permet que les operacions d’escriptura es realitzin en segon pla, millorant la resposta del sistema. Les dades es desplacen a la page cache i es poden escriure al disc més tard.\n\nDirty Pages: Pàgines a la memòria que han estat modificades però encara no s’han escrit al disc.\nWriteback: Procés de transferir les dirty pages de la memòria al disc.\nJournaling: Mecanisme per assegurar la integritat del FS en cas de fallada durant el writeback.\nFlush: Operació per escriure immediatament les dirty pages al disc."
  },
  {
    "objectID": "slides/03-filesystem-part1.html#creació-de-directoris",
    "href": "slides/03-filesystem-part1.html#creació-de-directoris",
    "title": "Sistema de fitxers (I)",
    "section": "Creació de Directoris",
    "text": "Creació de Directoris\n\n\n\n\n\nsequenceDiagram\n    participant P as Procés\n    participant VFS as VFS\n    participant FS as Driver de FS · mkdir\n    P-&gt;&gt;VFS: mkdir -&gt; /a/b/novedirectori\n    VFS-&gt;&gt;VFS: 1. Resoldre Dentry Pare -&gt; /a/b -&gt; Determinar Inode Pare\n    VFS-&gt;&gt;VFS: 2. Llegir blocs de dades del directori pare · Trobar espai per a nova Dentry\n    VFS-&gt;&gt;FS: 4. Crear nou Inode per al directori\n    FS--&gt;&gt;VFS: 5. Retornar Num. Inode\n    VFS-&gt;&gt;VFS: 6. Afegir Dentry al directori par · Escriure els blocs de dades del directori pare modificats\n    VFS--&gt;&gt;P: 8. Retornar èxit o error"
  },
  {
    "objectID": "slides/03-filesystem-part1.html#eliminació-de-fitxers",
    "href": "slides/03-filesystem-part1.html#eliminació-de-fitxers",
    "title": "Sistema de fitxers (I)",
    "section": "Eliminació de Fitxers",
    "text": "Eliminació de Fitxers\n\n\n\n\n\nsequenceDiagram\n    participant P as Procés\n    participant VFS as VFS\n    participant FS as Driver de FS · unlink\n    P-&gt;&gt;VFS: unlink -&gt; /a/b/fitxer.txt\n    VFS-&gt;&gt;VFS: 1. Resoldre Dentry Pare -&gt; /a/b -&gt; Determinar Inode Pare\n    VFS-&gt;&gt;VFS: 2. Llegir blocs de dades del directori pare · Trobar i esborrar la Dentry\n    VFS-&gt;&gt;VFS: 4. Comprovar enllaços -&gt; Si és l'últim enllaç, desassignar blocs de dades i blocs d'inode\n    VFS-&gt;&gt;FS: 6. Actualitzar metadades al disc\n    FS--&gt;&gt;VFS: 7. Confirmació d'actualització\n    VFS--&gt;&gt;P: 8. Retornar èxit o error"
  },
  {
    "objectID": "slides/03-filesystem-part1.html#superbloc-i-operacions-dinode",
    "href": "slides/03-filesystem-part1.html#superbloc-i-operacions-dinode",
    "title": "Sistema de fitxers (I)",
    "section": "Superbloc i Operacions d’Inode",
    "text": "Superbloc i Operacions d’Inode\nEl VFS (Virtual Filesystem Switch) estableix dos conjunts d’operacions que el driver de cada Sistema de Fitxers ha d’implementar. Aquests mètodes permeten al kernel interactuar amb les metadades de forma uniforme.\n\n\n\n\n\n\n\n\nOperació\nFunció Tècnica\nPropòsit\n\n\n\n\nfill_super()\nLlegeix l’estat global del FS (total/lliure d’Inodes i Blocs).\nInicialització i muntatge.\n\n\nwrite_super()\nPersisteix les estadístiques i l’estat actualitzat al disc.\nCanvis en l’assignació.\n\n\nput_super()\nAllibera la memòria associada a la instància del FS.\nDesmuntatge (umount)."
  },
  {
    "objectID": "slides/03-filesystem-part1.html#operacions-de-linode",
    "href": "slides/03-filesystem-part1.html#operacions-de-linode",
    "title": "Sistema de fitxers (I)",
    "section": "Operacions de l’Inode",
    "text": "Operacions de l’Inode\nMalgrat el nom, la majoria d’aquestes operacions tracten amb la gestió de les Dentries i la jerarquia de noms de fitxer (no el contingut de l’Inode en si).\n\nCreació i Cerca: create, lookup, link, unlink.\nDirectori i Enllaços: mkdir, rmdir, symlink, readlink, rename.\n\n\n\n\n\n\n\n\nTipus d’Inode\n\n\nEls drivers de FS treballen amb dos tipus d’Inode:\n\nVFS Inode: Estructura genèrica utilitzada pel kernel.\nFS Inode: Estructura interna del driver (p. ex., la versió Ext4 o XFS).\n\nEl driver és responsable de la conversió entre aquestes dues estructures segons sigui necessari."
  },
  {
    "objectID": "slides/03-filesystem-part1.html#cache-dinodes-icache",
    "href": "slides/03-filesystem-part1.html#cache-dinodes-icache",
    "title": "Sistema de fitxers (I)",
    "section": "Cache d’Inodes (Icache)",
    "text": "Cache d’Inodes (Icache)\nAquesta cache emmagatzema les metadades del fitxer a memòria (l’estructura de l’Inode), evitant lectures repetitives a la IZONE del disc.\n\nEstructura: S’indexa mitjançant una Taula Hash (hash table).\nClau Hash: Es genera a partir de la tupla (Superbloc, Número d’Inode).\nPolítica: Els Inodes es mantenen fins que el FS es desmunta, s’elimina el fitxer, o hi ha pressió de memòria (memory pressure)."
  },
  {
    "objectID": "slides/03-filesystem-part1.html#cache-de-dentries",
    "href": "slides/03-filesystem-part1.html#cache-de-dentries",
    "title": "Sistema de fitxers (I)",
    "section": "Cache de Dentries",
    "text": "Cache de Dentries\nLa Dcache és l’eina més important per a la resolució ràpida de camins (path lookup). Cacheja la relació Nom \\(\\rightarrow\\) Inode.\n\n\n\n\n\n\n\nEstat de la Dentry\nImplicació Tècnica\n\n\n\n\nUsed\nL’objecte està en ús (p. ex., associat a un FILE Objecte). El seu d_inode és vàlid.\n\n\nUnused\nEl d_inode és vàlid, però l’objecte Dentry no està sent utilitzat activament per cap procés.\n\n\nNegative\nL’d_inode no és vàlid. S’utilitza per recordar que un fitxer no existeix o ha estat eliminat, evitant cerques futures innecessàries al disc.\n\n\n\n\n\n\n\n\n\n\nOptimització de la Dentry Cache\n\n\nL’accés a l’Inode cache (per al seu alliberament en condicions de memòria baixa) utilitza l’estat d’ús, basat en el Superbloc i el número d’Inode. La Dentry cache també fa servir taules hash per a cerques ultra-ràpides."
  },
  {
    "objectID": "slides/03-filesystem-part1.html#cache-de-pàgines-dades-i-es",
    "href": "slides/03-filesystem-part1.html#cache-de-pàgines-dades-i-es",
    "title": "Sistema de fitxers (I)",
    "section": "Cache de pàgines: Dades i E/S",
    "text": "Cache de pàgines: Dades i E/S\nLa Cache de pàgines és el mecanisme principal del kernel per a la gestió de dades d’E/S, utilitzat per tots els sistemes de fitxers. Emmagatzema els blocs de dades del fitxer a la memòria del sistema,per a la lectura ràpida i per a l’escriptura diferida.\n\n\n\n\n\n\n\nGestió de Memòria\n\n\nLinux reutilitza la memòria lliure com a cache, però l’allibera quan un procés necessita RAM.\n\n\n\n\n\nDades Cachejades: Només dades de fitxers, no metadades de nivell de bloc (block device data).\nMecanismes d’E/S: Suporta operacions read(), write() i mmap() (mapes de memòria).\n\n\n\n\n\n\n\n\nEstructura Interna: Ràdix-Arbre\n\n\nLa Cache de pàgines utilitza una estructura de dades Radix Tree per mapejar de manera eficient els offsets de fitxer a les pàgines de memòria. Això permet accés ràpid a pàgines de dades grans."
  },
  {
    "objectID": "slides/03-filesystem-part1.html#fat-file-allocation-table",
    "href": "slides/03-filesystem-part1.html#fat-file-allocation-table",
    "title": "Sistema de fitxers (I)",
    "section": "FAT: File Allocation Table",
    "text": "FAT: File Allocation Table\n\nSistema de fitxers creat el 1977 i popularitzat gràcies a MS-DOS.\nEncara popular avui (FAT32): USB, targetes de memòria, partició d’arrencada EFI.\nFile Allocation Table: Estructura de llista enllaçada que conté informació sobre els blocs ocupats per cada fitxer.\nTambé determina si un bloc està en ús o no."
  },
  {
    "objectID": "slides/03-filesystem-part1.html#fat-organització-de-directoris",
    "href": "slides/03-filesystem-part1.html#fat-organització-de-directoris",
    "title": "Sistema de fitxers (I)",
    "section": "FAT: Organització de Directoris",
    "text": "FAT: Organització de Directoris\nEls directoris en FAT són fitxers especials que contenen entrades de 32 bytes per a cada fitxer o subdirectori. Cada entrada inclou: nom, atributs, timestamps, primer clúster i mida del fitxer.\n\n\n\nNom\nIndex\nDir?\nPermisos\n\n\n\n\n.\n2\nSí\nrwx\n\n\nWindows\n3\nSí\nrwx\n\n\nUsers\n4\nSí\nrwx\n\n\npagefile.sys\n5\nNo\nr–\n\n\n\nEl superbloc actua com a punt de referència per a tot el sistema de fitxers, emmagatzemant informació crítica com la mida del clúster, la ubicació de la FAT i la ubicació del directori arrel."
  },
  {
    "objectID": "slides/03-filesystem-part1.html#fat-limitacions-tècniques",
    "href": "slides/03-filesystem-part1.html#fat-limitacions-tècniques",
    "title": "Sistema de fitxers (I)",
    "section": "FAT: Limitacions Tècniques",
    "text": "FAT: Limitacions Tècniques\nLimitacions de capacitat:\n\nFAT32: màxim 2TB per volum\nFAT32: màxim 4GB per fitxer\n\nProblemes de rendiment:\n\nLocalització de blocs lliures: scan complet de la FAT\nFragmentació severa (pobra localitat)\nFragmentació de metadata: cerques costoses\nLlistes enllaçades ineficients per fitxers grans\n\nImpacte pràctic:\n\nUn fitxer de 16MB (4096 clústers de 4KB) requereix 4096 lectures de la FAT per accés seqüencial complet"
  },
  {
    "objectID": "slides/03-filesystem-part1.html#ext-extended-file-system",
    "href": "slides/03-filesystem-part1.html#ext-extended-file-system",
    "title": "Sistema de fitxers (I)",
    "section": "EXT: Extended File System",
    "text": "EXT: Extended File System\nEls sistemes EXT van ser dissenyats específicament per a Linux com a evolució dels sistemes Unix tradicionals.\nEvolució:\n\next (1992): Primera versió, problemes de rendiment\next2 (1993): Inodes, directoris flexibles\n\next3 (2001): Journaling per a consistència\next4 (2008): Extents, millor rendiment\n\nCaracterístiques:\n\nInodes com a element bàsic\nBitmaps per gestió d’assignació\nBlock Groups per localitat de dades\nJournaling per integritat"
  },
  {
    "objectID": "slides/03-filesystem-part1.html#ext-estructura-de-linode",
    "href": "slides/03-filesystem-part1.html#ext-estructura-de-linode",
    "title": "Sistema de fitxers (I)",
    "section": "EXT: Estructura de l’Inode",
    "text": "EXT: Estructura de l’Inode\nL’inode és el nucli del sistema EXT. Cada fitxer té almenys un inode que conté tota la seva metadata:\nstruct ext4_inode {\n    uint16_t i_mode;        // Permisos i tipus de fitxer\n    uint16_t i_uid;         // User ID del propietari\n    uint32_t i_size;        // Mida del fitxer en bytes\n    uint32_t i_atime;       // Últim temps d'accés\n    uint32_t i_ctime;       // Temps de creació de l'inode\n    uint32_t i_mtime;       // Últim temps de modificació\n    uint16_t i_gid;         // Group ID del propietari\n    uint16_t i_links_count; // Nombre de hard links\n    \n    // Punters a blocs de dades\n    uint32_t i_block[15];   // Blocs directes i indirectes\n    /*\n     * i_block[0-11]: 12 punters directes (48KB amb blocs de 4KB)\n     * i_block[12]:   1 punter simple indirecte (4MB addicionals)\n     * i_block[13]:   1 punter doble indirecte (4GB addicionals)\n     * i_block[14]:   1 punter triple indirecte (4TB addicionals)\n     */\n\n};\nEls i-nodes consumeixen un 10% de l’emmagatzematge del disc (es pot configurar en el moment de la creació del sistema de fitxers)."
  },
  {
    "objectID": "slides/03-filesystem-part1.html#ext-adreçament-de-blocs-ext2",
    "href": "slides/03-filesystem-part1.html#ext-adreçament-de-blocs-ext2",
    "title": "Sistema de fitxers (I)",
    "section": "EXT: Adreçament de Blocs (ext2)",
    "text": "EXT: Adreçament de Blocs (ext2)\n\nUn fitxer de 100MB (25.600 blocs de 4KB) necessita 2 nivells d’indirecció, requerint múltiples lectures de metadades abans d’accedir a les dades reals."
  },
  {
    "objectID": "slides/03-filesystem-part1.html#ext-organització",
    "href": "slides/03-filesystem-part1.html#ext-organització",
    "title": "Sistema de fitxers (I)",
    "section": "EXT: Organització",
    "text": "EXT: Organització\n\n\nBitmap d’Inodes: mapa de bits d’inodes ocupats/lliures.\nBitmap de Blocs: mapa de bits de blocs ocupats/lliures.\nTaula d’Inodes: cada entrada és un únic inode."
  },
  {
    "objectID": "slides/03-filesystem-part1.html#ext3-problema-de-consistència-i",
    "href": "slides/03-filesystem-part1.html#ext3-problema-de-consistència-i",
    "title": "Sistema de fitxers (I)",
    "section": "EXT3: Problema de Consistència (I)",
    "text": "EXT3: Problema de Consistència (I)\nImagineu que un fitxer necessita augmentar la seva mida, i això requereix assignar un nou bloc de dades i actualitzar l’inode per reflectir aquesta nova assignació. Aquest procés implica múltiples operacions d’escriptura al disc."
  },
  {
    "objectID": "slides/03-filesystem-part1.html#ext3-problema-de-consistència-ii",
    "href": "slides/03-filesystem-part1.html#ext3-problema-de-consistència-ii",
    "title": "Sistema de fitxers (I)",
    "section": "EXT3: Problema de Consistència (II)",
    "text": "EXT3: Problema de Consistència (II)\n\nImagina que el procés es veu interromput (crash) a mitja operació."
  },
  {
    "objectID": "slides/03-filesystem-part1.html#journaling---consistència",
    "href": "slides/03-filesystem-part1.html#journaling---consistència",
    "title": "Sistema de fitxers (I)",
    "section": "Journaling - Consistència",
    "text": "Journaling - Consistència\n\n\n\n\n\nsequenceDiagram\n    participant P as Procés\n    participant K as Kernel\n    participant J as Journal\n    participant FS as Filesystem\n\n    P-&gt;&gt;K: write() - ampliar fitxer\n    \n    Note over K,J: FASE 1: Preparació\n    K-&gt;&gt;J: Crear transacció: T1\n    K-&gt;&gt;J: Nou bloc dades · Update bitmap · Update inode\n    K-&gt;&gt;J: COMMIT transacció T1\n    \n    Note over K,FS: FASE 2: Aplicació\n    K-&gt;&gt;FS: Aplicar canvis del journal\n    K-&gt;&gt;J: Marcar T1 com a completa\n    \n    K--&gt;&gt;P: write() completat"
  },
  {
    "objectID": "slides/03-filesystem-part1.html#journaling-modes",
    "href": "slides/03-filesystem-part1.html#journaling-modes",
    "title": "Sistema de fitxers (I)",
    "section": "Journaling: Modes",
    "text": "Journaling: Modes\n\nJournaling Complet: Tant les dades com les metadades s’escriuen al journal abans d’aplicar-les al sistema de fitxers. Màxima seguretat, però més lent.\nJournaling de Metadades: Només les metadades s’escriuen al journal. Les dades es poden escriure directament al sistema de fitxers. Equilibri entre seguretat i rendiment.\nEscriptura Diferida (Writeback): Les dades i les metadades es poden escriure directament al sistema de fitxers sense passar pel journal. Màxim rendiment, però risc de corrupció de dades en cas de fallada."
  },
  {
    "objectID": "slides/03-filesystem-part1.html#ext3-journaling",
    "href": "slides/03-filesystem-part1.html#ext3-journaling",
    "title": "Sistema de fitxers (I)",
    "section": "ext3 · Journaling",
    "text": "ext3 · Journaling\n\nPre-escriptura (Write-Ahead Logging):\n\nAbans d’escriure qualsevol dada o metadada al disc, es registra la intenció d’aquesta escriptura en un registre especial anomenat journal. Garanteix que les operacions es completin correctament, fins i tot en cas de fallades.\n\nSi escriu el journal correctament:\n\nLa transacció es marca com a completa. Els canvis es poden aplicar al sistema de fitxers de manera segura.\n\nSi la escriptura del journal es veu interrompuda:\n\nLa transacció no es completa (pèrdua de dades), però el sistema de fitxers roman consistent.\n\nSi el journal s’escriu correctament, però el disc no:\n\nTemporalment, el sistema de fitxers perd la consistència.El registre té la informació per restaurar-la (durant l’arrencada, els journals inacabats es completen)."
  },
  {
    "objectID": "slides/03-filesystem-part1.html#ext4-extents-per-a-millor-eficiència",
    "href": "slides/03-filesystem-part1.html#ext4-extents-per-a-millor-eficiència",
    "title": "Sistema de fitxers (I)",
    "section": "ext4: Extents per a Millor Eficiència",
    "text": "ext4: Extents per a Millor Eficiència\nEl principal problema (ext2/ext3) era la gestió ineficient dels punters a blocs de dades, especialment per a fitxers grans.\n\nUn extends és un descriptor que representa un rang contigu de blocs, millorant l’eficiència en l’assignació i reduint la fragmentació.\n\n\nRangs de blocs físics contigus, descrits amb una entrada (bloc inicial + nombre de blocs).\nUn extent pot mapar fins a 128 MiB (blocs de 4KB) d’espai contigu amb blocs de 4 KiB.\nL’inode d’ext4 pot contenir directament fins a 4 extents; si el fitxer és gran o fragmentat, s’utilitza una estructura d’arbre (HTree) per indexar més extents."
  },
  {
    "objectID": "slides/03-filesystem-part1.html#ext4-estructura-dun-extent",
    "href": "slides/03-filesystem-part1.html#ext4-estructura-dun-extent",
    "title": "Sistema de fitxers (I)",
    "section": "ext4: Estructura d’un Extent",
    "text": "ext4: Estructura d’un Extent\nstruct ext4_extent {\n    uint32_t ee_block;      // Bloc lògic inicial al fitxer\n    uint16_t ee_len;        // Longitud en blocs (màxim 32.768)\n    uint16_t ee_start_hi;   // Bits alts del bloc físic\n    uint32_t ee_start_lo;   // Bits baixos del bloc físic\n};\n\n\n\n\n\ngraph TD\n    A[Inode] --&gt; B[Extent Header]\n    B --&gt; C1[Extent 1]\n    B --&gt; C2[Extent 2]\n    B --&gt; C3[Extent 3]\n    B --&gt; C4[Extent 4]\n    C1 --&gt; D1[Bloc Físic 1000 - 1023]\n    C2 --&gt; D2[Bloc Físic 2000 - 2023]\n    C3 --&gt; D3[Bloc Físic 3000 - 3023]\n    C4 --&gt; D4[Bloc Físic 4000 - 4023]\n    style A fill:#eaf7ff,stroke:#007bff\n    style B fill:#f9f5dd,stroke:#c4aa18"
  },
  {
    "objectID": "slides/03-filesystem-part1.html#ext4-htreebtree",
    "href": "slides/03-filesystem-part1.html#ext4-htreebtree",
    "title": "Sistema de fitxers (I)",
    "section": "ext4: HTree/Btree",
    "text": "ext4: HTree/Btree\n\n\n\nUn B-tree és una estructura d’arbre auto-balancejada que manté dades ordenades i permet cerques, insercions i eliminacions en temps logarítmic.\nUn HTree és una variant de B-tree utilitzada específicament per indexar fitxers i directoris en ext4.\nLa principal diferència és que les entrades es distribueixen en nodes fulla i no fulla, amb una estructura de capçalera específica per a cada node.\nInode/Arrel: Apunta a la capçalera de l’HTree.\n\n\n\n\n\n\n\ngraph TD\n    A[Inode] --&gt; B[HTree Root]\n    B --&gt; C1[Node No Fulla 1]\n    B --&gt; C2[Node No Fulla 2]\n    C1 --&gt; D1[Node Fulla 1]\n    C1 --&gt; D2[Node Fulla 2]\n    C2 --&gt; D3[Node Fulla 3]\n    C2 --&gt; D4[Node Fulla 4]\n    D1 --&gt; E1[Extent 1]\n    D1 --&gt; E2[Extent 2]\n    D2 --&gt; E3[Extent 3]\n    D3 --&gt; E4[Extent 4]\n    D4 --&gt; E5[Extent 5]\n\n\n\n\n\n\n\nNodes no fulla: Indexen altres nodes, permetent que l’arbre creixi i es mantingui balancejat.\nNodes fulla: Contenen les extents, que són rangs de blocs físics contigus.\nExtents: Descriuen els blocs reals del fitxer o directori."
  },
  {
    "objectID": "slides/03-filesystem-part1.html#ext4-assignació-multibloc-i-retrassada",
    "href": "slides/03-filesystem-part1.html#ext4-assignació-multibloc-i-retrassada",
    "title": "Sistema de fitxers (I)",
    "section": "ext4 · Assignació multibloc i retrassada",
    "text": "ext4 · Assignació multibloc i retrassada\n\nAssignació Multibloc:\n\next4 pot assignar múltiples blocs a la vegada, agrupant blocs consecutius per minimitzar la fragmentació.\nAixò redueix la sobrecàrrega d’assignació i millora la localitat de les dades.\n\nAssignació Retardada:\n\nL’assignació retardada espera a bloquejar l’espai fins just abans d’escriure, optimitzant la distribució de blocs.\nAixò permet agrupar escriptures i minimitzar la fragmentació."
  },
  {
    "objectID": "slides/03-filesystem-part1.html#exercicis-propostas",
    "href": "slides/03-filesystem-part1.html#exercicis-propostas",
    "title": "Sistema de fitxers (I)",
    "section": "Exercicis Propostas",
    "text": "Exercicis Propostas\n\nAdministració Bàsica de Sistemes de Fitxers\nDiscussió: Secure Boot és realment segur?: Cerca notícies recents sobre Secure Boot i comparteix-les al fòrum del curs. Debatiu sobre avantatges, desavantatges, vulnerabilitats conegudes i experiències personals.\nPràctica 01: Snapshots i restauració amb systemd i initramfs"
  },
  {
    "objectID": "slides/03-filesystem-part1.html#thats-all",
    "href": "slides/03-filesystem-part1.html#thats-all",
    "title": "Sistema de fitxers (I)",
    "section": "That’s all",
    "text": "That’s all\n\n\n\n\n\n\n\n\n\nTake Home Message\n\n\nEls sistemes de fitxers són complexos i crítics per al rendiment i la fiabilitat del sistema operatiu. El VFS proporciona una capa d’abstracció que permet gestionar diferents tipus de sistemes de fitxers de manera uniforme. Sistemes de fitxers com EXT4 han evolucionat per abordar problemes de rendiment i consistència, incorporant característiques com els extents i el journaling."
  },
  {
    "objectID": "slides/02-booting.html#etapes-de-larrancada",
    "href": "slides/02-booting.html#etapes-de-larrancada",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Etapes de l’arrancada",
    "text": "Etapes de l’arrancada"
  },
  {
    "objectID": "slides/02-booting.html#fase-1-màquinaria",
    "href": "slides/02-booting.html#fase-1-màquinaria",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Fase 1: Màquinaria",
    "text": "Fase 1: Màquinaria\n\nEn prémer el botó d’encesa, la placa base envia un senyal a la PSU (Power Supply Unit).\nLa PSU proporciona tensió estable a tots els components i activa la CPU.\nLa CPU inicialitza registres interns i col·loca el Puntador d’Instrucció (EIP) a la direcció de reset 0xFFFFFFF0.\n\n\n\nAquesta adreça conté una instrucció de salt (jmp) que redirigeix la CPU al Firmware (BIOS/UEFI) per iniciar el procés de diagnòstic i arrencada del sistema (POST)."
  },
  {
    "objectID": "slides/02-booting.html#fase-2-firmware",
    "href": "slides/02-booting.html#fase-2-firmware",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Fase 2: Firmware",
    "text": "Fase 2: Firmware\nEl teu ordinador necessita un firmware per: provar, detectar, configurar i inicialitzar dispositius. Aquest firmware en sistemes moderns és l’UEFI i en sistemes antics el BIOS (normalment compatibles amb IBM PC).\n\n\nYou’ve probably read a lot of stuff on the internet about UEFI. Here is something important you should understand: 95% of it was probably garbage. — Adam Williamson"
  },
  {
    "objectID": "slides/02-booting.html#fase-2-etapes",
    "href": "slides/02-booting.html#fase-2-etapes",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Fase 2: Etapes",
    "text": "Fase 2: Etapes\n\nInicialització del firmware\n\nCarrega i execució del codi de firmware (BIOS/UEFI).\nLectura de la configuració de la NVRAM.\nVerificació de la integritat del firmware.\n\nDiagnòstic i detecció\n\nPower-On Self Test (POST): comprovació de CPU, RAM, gràfics bàsics…\nDetecció i inicialització dels dispositius connectats.\nAplicació de la configuració als dispositius.\n\nArrencada del sistema\n\nSelecció del dispositiu d’arrencada.\nCàrrega del bootloader de primera etapa.\nTransferència del control al bootloader."
  },
  {
    "objectID": "slides/02-booting.html#actualització-del-firmware",
    "href": "slides/02-booting.html#actualització-del-firmware",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Actualització del firmware",
    "text": "Actualització del firmware\nEl firmware està emmagatzemat en un xip de memòria flash a la placa base. L’actualització (flashing) substitueix el contingut d’aquest xip per una versió nova.\n\n\n🚀 Objectius\n\nCorregir errades de microcodi de la CPU.\nAfegir suport per a nou maquinari (CPU, RAM, targetes).\nAplicar parches de seguretat (ex.: vulnerabilitats Spectre/Meltdown.\nMillorar funcions de gestió d’energia i arrencada segura (Secure Boot).\n\n\n⚠️ Riscos\n\nUn error en el procés (tall de corrent, imatge corrupta, versió incorrecta) pot deixar el xip inservible (brick).\nAlguns fabricants ofereixen mecanismes de recuperació (dual BIOS, BIOS flashback, càpsules UEFI).\nEn entorns de producció, és recomanable validar la nova versió en un entorn de test abans de desplegar-la."
  },
  {
    "objectID": "slides/02-booting.html#diferències-entre-bios-i-uefi-i",
    "href": "slides/02-booting.html#diferències-entre-bios-i-uefi-i",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Diferències entre BIOS i UEFI (I)",
    "text": "Diferències entre BIOS i UEFI (I)\n\n\n\n\n\n\n\n\nCaracterística\nBIOS\nUEFI\n\n\n\n\nEmmagatzematge\nTradicionalment en ROM (avui dia flash EEPROM)\nFlash SPI a la placa base + EFI System Partition (ESP) al disc\n\n\nCapacitat de disc\nFins a 2,2 TB (per limitació 32-bit LBA, sectors 512 B)\nFins a 9,4 ZB (GPT)\n\n\nInterfície\nText\nGràfica, amb suport per ratolí i resolucions altes\n\n\nSeguretat\nSense proteccions avançades\nSecure Boot, verificació de signatures i protecció contra codi maliciós\n\n\nCompatibilitat\nPrincipalment IBM PC compatibles antics\nCompatible amb sistemes moderns, amb suport per Legacy BIOS via CSM"
  },
  {
    "objectID": "slides/02-booting.html#diferències-entre-bios-i-uefi-ii",
    "href": "slides/02-booting.html#diferències-entre-bios-i-uefi-ii",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Diferències entre BIOS i UEFI (II)",
    "text": "Diferències entre BIOS i UEFI (II)\n\n\n\n\n\n\n\n\nCaracterística\nBIOS\nUEFI\n\n\n\n\nVelocitat d’arrencada\nMés lenta\nMés ràpida gràcies a inicialització paral·lela de drivers i fast boot\n\n\nTaula de particions\nMBR\nGPT\n\n\nNombre màxim de particions\n4 primàries (amb lògiques dins d’estesa)\nFins a 128 entrades de particions\n\n\nModularitat\nMonolítica\nModular, permet afegir drivers, aplicacions i extensions UEFI"
  },
  {
    "objectID": "slides/02-booting.html#taula-de-particions-mbr",
    "href": "slides/02-booting.html#taula-de-particions-mbr",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Taula de particions MBR",
    "text": "Taula de particions MBR\n\n\nEstructura\n\nBootloader de primera etapa (446 bytes): Conté el codi d’arrencada.\nTaula de particions (64 bytes): Conté la informació de les particions. Pot contenir fins a 4 entrades.\nSignatura (2 bytes): Marca de final de la taula de particions. Permet identificar la taula de particions com a vàlida.\n\n\n\n\n\n\n\n\nLímitació\n\n\n\nCom MBR utiltiza entrades de 32 bits per blocs lògics (LBA) → \\(2^{32}\\) sectors × \\(512 B = 2 TB\\) aproximadament.\nNomés suporta 4 particions primàries."
  },
  {
    "objectID": "slides/02-booting.html#particions-mbr-i",
    "href": "slides/02-booting.html#particions-mbr-i",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Particions MBR (I)",
    "text": "Particions MBR (I)\n\nParticions primàries\n\nFins a 4 per disc.\nContenen directament un sistema de fitxers (ext4, NTFS, FAT32).\nPot tenir un Volume Boot Record (VBR) que carrega el sistema operatiu de la partició.\n\nPartició estesa\n\nUna partició primària especial per superar la limitació de 4 primàries.\nNo conté sistema de fitxers ni VBR; actua com a contenidor de particions lògiques.\n\nParticions lògiques\n\nResideixen dins de la partició estesa.\nCada partició lògica té un Extended Boot Record (EBR) amb la seva taula de particions.\nLa linked list d’EBRs permet afegir dinàmicament més particions lògiques.\nPot contenir un VBR per carregar el sistema operatiu"
  },
  {
    "objectID": "slides/02-booting.html#particions-mbr-ii",
    "href": "slides/02-booting.html#particions-mbr-ii",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Particions MBR (II)",
    "text": "Particions MBR (II)"
  },
  {
    "objectID": "slides/02-booting.html#taula-de-particions-gpt-i",
    "href": "slides/02-booting.html#taula-de-particions-gpt-i",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Taula de particions GPT (I)",
    "text": "Taula de particions GPT (I)\n\nCompatibilitat i protecció\n\nBloqueja utilitats basades en MBR per no sobreescriure un disc GPT.\nConté una única partició especial que identifica el disc com GPT.\nOS i eines que no suporten GPT reconeixen el disc, però normalment no el modifiquen.\n\nGPT Header Primari\n\nSituat al segon sector del disc (LBA 1).\nDefineix els blocs utilitzables del disc.\nConté la taula de particions (mínim 128 entrades, 128 B cadascuna).\n\nGPT Header Secundari\n\nCòpia de seguretat del Primary GPT Header.\nSituat als últims sectors del disc.\nPermet recuperar la informació si el Primary Header està corrupte."
  },
  {
    "objectID": "slides/02-booting.html#taula-de-particions-gpt",
    "href": "slides/02-booting.html#taula-de-particions-gpt",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Taula de particions GPT",
    "text": "Taula de particions GPT"
  },
  {
    "objectID": "slides/02-booting.html#què-és-uefi-i",
    "href": "slides/02-booting.html#què-és-uefi-i",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Què és UEFI? (I)",
    "text": "Què és UEFI? (I)\n\nSistema de fitxers propi\n\nUEFI no utilitza MBR tradicional de 512 B ni codi de boot limitat.\nDisposa d’un filesystem propi (FAT32, 100 a 550 MB) anomenat EFI System Partition (ESP).\nLa partició EFI és marcada amb boot flag, però mai conté OS partitions.\n\nEstructura de la partició EFI\n\nCada OS té la seva carpeta dins de la ESP.\nConté tots els fitxers necessaris per carregar el sistema operatiu.\nEn Linux, la ESP sovint es munta sota /boot/efi.\n\n\n\n/\n├── boot\n│   ├── efi\n│   │   ├── EFI\n│   │   │   ├── BOOT\n│   │   │   │   ├── BOOTX64.EFI"
  },
  {
    "objectID": "slides/02-booting.html#què-és-uefi-ii",
    "href": "slides/02-booting.html#què-és-uefi-ii",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Què és UEFI? (II)",
    "text": "Què és UEFI? (II)\n\nMini sistema operatiu\n\nUEFI és com un mini sistema operatiu.\n\nExecuta fitxers en format EFI executable.\nPermet drivers i aplicacions independents del SO.\n\nQuan escrius un bootloader natiu UEFI, has de respectar aquest format.\n\nUEFI Boot Manager\n\nMotor de política del firmware per arrencada.\nConfigurable via variables globals a NVRAM.\nCarrega drivers UEFI i aplicacions UEFI (incloent OS bootloaders) en l’ordre definit per les variables.\nLinux disposa de l’eina efibootmgr per modificar la configuració del boot manager."
  },
  {
    "objectID": "slides/02-booting.html#mòduls-de-la-uefi",
    "href": "slides/02-booting.html#mòduls-de-la-uefi",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Mòduls de la UEFI",
    "text": "Mòduls de la UEFI"
  },
  {
    "objectID": "slides/02-booting.html#efibootmgr",
    "href": "slides/02-booting.html#efibootmgr",
    "title": "Arrencada del sistema (Part 1)",
    "section": "efibootmgr",
    "text": "efibootmgr\n# efibootmgr -v\nBootCurrent: 0002\nTimeout: 3 seconds\nBootOrder: 0003,0002,0000,0004\nBoot0000* CD/DVD Drive  BIOS(3,0,00)\nBoot0001* Hard Drive    HD(2,0,00)\nBoot0002* Fedora        HD(1,800,61800,6d98f360-cb3e-4727-8fed-5ce0c040365d)File(\\EFI\\fedora\\grubx64.efi)\nBoot0003* opensuse      HD(1,800,61800,6d98f360-cb3e-4727-8fed-5ce0c040365d)File(\\EFI\\opensuse\\grubx64.efi)\nBoot0004* Hard Drive    BIOS(2,0,00)P0: ST1500DM003-9YN16G \n\nLes entrades Boot0000 i Boot0004 corresponen a modes de compatibilitat BIOS (CSM), no són natives- d’UEFI.\nGenerades automàticament pel firmware, sense intervenció externa.\nS’afegeixen directament a les variables NVRAM del sistema.\nEntrades UEFI natives (Boot0002, Boot0003) apunten directament als fitxers EFI dels OS:\n\nFedora : \\EFI\\fedora\\grubx64.efi\nopenSUSE: \\EFI\\opensuse\\grubx64.efi\n\nL’ordre d’arrencada es defineix a la variable BootOrder."
  },
  {
    "objectID": "slides/02-booting.html#què-és-la-consola-de-la-uefi",
    "href": "slides/02-booting.html#què-és-la-consola-de-la-uefi",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Què és la consola de la UEFI?",
    "text": "Què és la consola de la UEFI?\nLa consola de la UEFI és una interfície de línia de comandes que permet interactuar directament amb el firmware UEFI per realitzar tasques avançades de diagnòstic, configuració i manteniment del sistema.\n\n\nFuncions\n\nConfiguració del maquinari i perifèrics (CPU, memòria, dispositius PCIe).\nComprovació del funcionament dels dispositius i diagnòstic de fallades.\nAccés als sistemes de fitxers EFI i gestió de fitxers de boot.\nInstal·lació, reparació o actualització de bootloaders i OS.\nExecució de aplicacions UEFI natives (mini-aplicacions tipus OS).\n\n\nAccés\n\nPrement una tecla durant l’engegada del sistema, segons el fabricant: F2, F10, F12, ESC o Supr.\nDes de sistemes operatius:\n\nLinux: efibootmgr o systemctl reboot --firmware-setup.\nWindows: Opció Advanced Startup i UEFI Firmware Settings.\nmacOS: Reboot amb Option/Alt."
  },
  {
    "objectID": "slides/02-booting.html#comandes-de-la-consola-de-la-uefi",
    "href": "slides/02-booting.html#comandes-de-la-consola-de-la-uefi",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Comandes de la consola de la UEFI",
    "text": "Comandes de la consola de la UEFI\n\n\n\n\n\n\n\n\nComanda\nFunció\nExemple\n\n\n\n\nmap\nMostra els dispositius detectats i les unitats lògiques associades\nmap fs* → llista tots els sistemes de fitxers detectats\n\n\nmem\nMostra l’ús de memòria i mapa físic de la RAM\nmemmap → mapa detallat de la memòria física\n\n\nls\nLlista fitxers i directoris dins un FS accessible\nls fs0:\\EFI\\Boot → mostra fitxers de la partició EFI\n\n\ncd\nNavegar entre carpetes dins del FS\ncd EFI\\Boot → mou a la carpeta d’arrencada EFI\n\n\ncp\nCopiar fitxers entre unitats o directoris\ncp fs0:\\EFI\\Boot\\bootx64.efi fs1:\\EFI\\Backup\\\n\n\nedit\nEditar fitxers, útil per configurar scripts d’arrencada\nedit fs0:\\EFI\\Boot\\bootx64.efi"
  },
  {
    "objectID": "slides/02-booting.html#importància-de-la-partició-efi",
    "href": "slides/02-booting.html#importància-de-la-partició-efi",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Importància de la partició EFI",
    "text": "Importància de la partició EFI\n\nPunt de partida per a l’arrencada del sistema operatiu.\nEssencial per a l’arrencada dels sistemes UEFI.\nConté fitxers crítics per carregar el bootloader de segona etapa, com:\n\nGRUB (Linux)\nGestor d’arrencada de Windows\n\nPermet tenir múltiples sistemes operatius en el mateix disc.\nFacilita la gestió i actualització de bootloaders sense afectar les particions del sistema operatiu."
  },
  {
    "objectID": "slides/02-booting.html#arrencar-sense-partició-efi",
    "href": "slides/02-booting.html#arrencar-sense-partició-efi",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Arrencar sense partició EFI",
    "text": "Arrencar sense partició EFI\n\nTeòricament possible: configurar UEFI per carregar el bootloader directament des del disc dur.\nPoc comú i no recomanat, ja que:\n\nComplica la gestió dels sistemes operatius.\nImpedeix actualitzacions i reparacions automàtiques dels bootloaders.\n\nLa partició EFI proporciona un punt centralitzat i estàndard per a tots els fitxers d’arrencada."
  },
  {
    "objectID": "slides/02-booting.html#tipus-de-bootloaders",
    "href": "slides/02-booting.html#tipus-de-bootloaders",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Tipus de bootloaders",
    "text": "Tipus de bootloaders\n\nBootloader de primera etapa: Carregat directament pel firmware (BIOS/UEFI). S’encarrega de carregar el bootloader de segona etapa.\nBootloader de segona etapa: Carregat pel bootloader de primera etapa. S’encarrega de carregar el sistema operatiu.\n\n\nEn sistemes UEFI, el bootloader de primera etapa és un fitxer executable en format EFI (per exemple, grubx64.efi per a GRUB). Mentre que en sistemes BIOS, el bootloader de primera etapa es troba en el MBR del disc."
  },
  {
    "objectID": "slides/02-booting.html#funcions-del-bootloader",
    "href": "slides/02-booting.html#funcions-del-bootloader",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Funcions del bootloader",
    "text": "Funcions del bootloader\nUn bootloader és el programa encarregat de:\n\nMostrar un menú amb les diverses opcions d’arrencada disponibles.\nCarregar el nucli (kernel) i l’Initrd (si s’escau) a la memòria principal.\nEl kernel de linux té una convenció d’arrencada on el bootloader ha de preparar el mapa de memòria i els registres de la CPU abans de transferir el control al nucli."
  },
  {
    "objectID": "slides/02-booting.html#diferents-gestors-darrencada",
    "href": "slides/02-booting.html#diferents-gestors-darrencada",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Diferents gestors d’arrencada",
    "text": "Diferents gestors d’arrencada\n\n\n\n\n\n\n\n\nBootloader\nCompatibilitat\nCaracterístiques principals\n\n\n\n\nLILO\nBIOS\nAntic bootloader Linux, obsolet.\n\n\nGRUB\nBIOS/UEFI\nPopular en Linux; menú configurable; suport multiboot.\n\n\nGRUB2\nBIOS/UEFI\nVersió moderna; suport FAT, NTFS, ext4; millor multiboot i scripting.\n\n\nrEFInd\nUEFI\nPermet arrencar múltiples OS; interfície gràfica amigable.\n\n\nsystemd-boot\nUEFI\nSimple i ràpid; integració amb systemd; no recomanat per multiboot.\n\n\nWindows Boot Manager\nUEFI\nGestiona arrencada de Windows i altres OS compatibles; integració amb BCD."
  },
  {
    "objectID": "slides/02-booting.html#exercicis-propostas",
    "href": "slides/02-booting.html#exercicis-propostas",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Exercicis Propostas",
    "text": "Exercicis Propostas\n\nBooting amb MBR i BIOS\nBooting amb UEFI\nDual Boot amb UEFI"
  },
  {
    "objectID": "slides/02-booting.html#thats-all",
    "href": "slides/02-booting.html#thats-all",
    "title": "Arrencada del sistema (Part 1)",
    "section": "That’s all",
    "text": "That’s all\n\n\n\n\n\n\n\n\n\nTake Home Message\n\n\nEl procés d’arrencada és un procés complex. Els administradors de sistemes han de conèixer aquest procés per poder gestionar i solucionar problemes durant l’arrencada del sistema i garantir un sistema segur, estable i eficient."
  },
  {
    "objectID": "slides/02-booting-part2.html#etapes-de-larrancada",
    "href": "slides/02-booting-part2.html#etapes-de-larrancada",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Etapes de l’arrancada",
    "text": "Etapes de l’arrancada"
  },
  {
    "objectID": "slides/02-booting-part2.html#què-és-el-grubgrub2",
    "href": "slides/02-booting-part2.html#què-és-el-grubgrub2",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Què és el GRUB/GRUB2?",
    "text": "Què és el GRUB/GRUB2?\nGRUB (GRand Unified Bootloader) és un gestor d’arrencada molt utilitzat en sistemes operatius Linux i altres sistemes Unix-like. La seva funció principal és carregar un kernel del sistema operatiu a la memòria i iniciar el procés d’arrencada.\n\nFuncions principals:\n\nPermet seleccionar entre múltiples sistemes operatius instal·lats en un mateix ordinador (multi-boot).\nProporciona una interfície per configurar opcions d’arrencada, com ara paràmetres del kernel.\nSuporta diferents sistemes de fitxers, permetent accedir a particions amb formats com ext4, Btrfs, XFS, entre altres.\nOfereix una consola interactiva per a la resolució de problemes i la configuració avançada."
  },
  {
    "objectID": "slides/02-booting-part2.html#etapes-dexecució-del-grub",
    "href": "slides/02-booting-part2.html#etapes-dexecució-del-grub",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Etapes d’execució del GRUB",
    "text": "Etapes d’execució del GRUB\n\nStage 1:\n\nEn sistemes BIOS: efectivament és el codi al MBR (o VBR) → molt petit (≤ 446 bytes).\nEn sistemes UEFI: és un fitxer executable EFI (normalment a /boot/efi/EFI/grub/grubx64.efi).\n\nStage 1.5 (només en BIOS, opcional):\n\nProporciona suport bàsic per a sistemes de fitxers.\nNormalment es troba en sectors buits després del MBR (espai entre MBR i primera partició). core.img.\n\nStage 2:\n\nConté el GRUB complet amb el menú d’arrencada.\nPot carregar mòduls addicionals (drivers de FS, vídeo, xarxa, criptografia…).\nTransfereix el control al kernel per iniciar el sistema operatiu."
  },
  {
    "objectID": "slides/02-booting-part2.html#diagrama-darrencada-del-grub",
    "href": "slides/02-booting-part2.html#diagrama-darrencada-del-grub",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Diagrama d’arrencada del GRUB",
    "text": "Diagrama d’arrencada del GRUB\n\n\nset root=‘hd0,msdos1’: Indica la partició arrel on es troba el sistema operatiu que es vol arrencar.\nlinux /vmlinuz root=/dev/sda1: Indica la ruta del kernel i la partició arrel.\ninitrd /initramfs.img: Indica la ruta de l’initramfs.\nboot: Inicia el sistema operatiu."
  },
  {
    "objectID": "slides/02-booting-part2.html#configuració-del-grub-i",
    "href": "slides/02-booting-part2.html#configuració-del-grub-i",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Configuració del GRUB (I)",
    "text": "Configuració del GRUB (I)\nEl fitxer principal de configuració de GRUB2 és:\n- /boot/grub/grub.cfg (o /boot/grub2/grub.cfg en algunes distribucions).\n\n\n\n\n\n\n\nImportant\n\n\nNo s’ha d’editar directament, ja que es regenera automàticament.\n\n\n\n\nFitxers i directoris\n\n/etc/default/grub : Opcions generals de configuració i variables d’entorn.\n/etc/grub.d/\nDirectori amb scripts que generen grub.cfg:\n\n00_header → configuració inicial\n\n10_linux → detecta kernels Linux\n\n30_os-prober → detecta altres SO\n\n40_custom → entrades personalitzades"
  },
  {
    "objectID": "slides/02-booting-part2.html#configuració-del-grub-ii",
    "href": "slides/02-booting-part2.html#configuració-del-grub-ii",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Configuració del GRUB (II)",
    "text": "Configuració del GRUB (II)\nUn cop modificats els fitxers anteriors, cal regenerar grub.cfg:\n# Distribucions Debian/Ubuntu\nsudo update-grub\n\n# Distribucions Arch, Fedora, openSUSE...\nsudo grub-mkconfig -o /boot/grub/grub.cfg"
  },
  {
    "objectID": "slides/02-booting-part2.html#variables-etcdefaultgrub",
    "href": "slides/02-booting-part2.html#variables-etcdefaultgrub",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Variables /etc/default/grub",
    "text": "Variables /etc/default/grub\n\n\n\n\n\n\n\nVariable\nDescripció\n\n\n\n\nGRUB_BACKGROUND\nImatge de fons que es mostrarà al menú d’arrencada.\n\n\nGRUB_TIMEOUT\nTemps en segons abans de carregar l’entrada predeterminada.\n\n\nGRUB_DEFAULT\nEntrada per defecte que es carregarà (index o nom)\n\n\nGRUB_CMDLINE_LINUX\nOpcions de línia de comandes que es passen al nucli en arrencar el sistema.\n\n\nGRUB_DISABLE_RECOVERY\nSi true, desactiva les opcions de mode de recuperació.\n\n\nGRUB_DISABLE_OS_PROBER\nSi true, impedeix que GRUB busqui altres sistemes operatius instal·lats.\n\n\nGRUB_PRELOAD_MODULES\nLlista de mòduls GRUB que es carregaran abans de mostrar el menú d’arrencada."
  },
  {
    "objectID": "slides/02-booting-part2.html#paràmetres-del-kernel-més-comuns",
    "href": "slides/02-booting-part2.html#paràmetres-del-kernel-més-comuns",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Paràmetres del kernel més comuns",
    "text": "Paràmetres del kernel més comuns\n\n\n\n\n\n\n\nParàmetre\nDescripció\n\n\n\n\nquiet\nSuprimeix els missatges del nucli durant l’arrencada.\n\n\nsingle\nInicia el sistema en mode d’usuari únic (single-user mode) per a tasques de manteniment.\n\n\nnomodeset\nDesactiva la detecció de modes de vídeo, útil per a solucions de problemes amb gràfics.\n\n\nroot=\nEspecifica la partició arrel del sistema de fitxers.\n\n\ninit=\nEspecifica un fitxer d’init alternatiu.\n\n\nro\nMuntatge de la partició arrel en mode de només lectura durant l’arrencada.\n\n\nrw\nMuntatge de la partició arrel en mode de lectura i escriptura durant l’arrencada.\n\n\nsystemd.unit =\nEspecifica el target de systemd a iniciar (ex: multi-user.target, graphical.target)."
  },
  {
    "objectID": "slides/02-booting-part2.html#consideracions-addicionals",
    "href": "slides/02-booting-part2.html#consideracions-addicionals",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Consideracions addicionals",
    "text": "Consideracions addicionals\n\nEn UEFI, GRUB2 és un fitxer EFI a /boot/efi/EFI//grubx64.efi.\nEs poden protegir entrades amb contrasenya a /etc/grub.d/40_custom.\nAl menú, amb e es poden passar paràmetres temporals al kernel.\nGRUB permet chainloading per arrencar altres SO (Windows, BSD).\nAmb UEFI Secure Boot, GRUB pot ser signat digitalment."
  },
  {
    "objectID": "slides/02-booting-part2.html#secure-boot",
    "href": "slides/02-booting-part2.html#secure-boot",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Secure Boot",
    "text": "Secure Boot\nSecure Boot és una característica de seguretat del firmware UEFI que assegura que només es carregui i s’executi programari de confiança durant el procés d’arrencada del sistema.\n\nUEFI comprova la signatura digital del bootloader EFI (per exemple, grubx64.efi) abans de carregar-lo.\nLa signatura és comparada amb les claus de confiança emmagatzemades en la DB (Database of allowed signatures) del firmware.\nSi la signatura és vàlida, UEFI carrega i executa el bootloader. Sinó, impedeix l’execució del bootloader i mostra un missatge d’error.\nPot carregar mòduls addicionals signats, que també poden ser verificats pel mateix GRUB (opcional).\nEl kernel Linux també pot estar signat (opcional, si s’utilitza Linux Kernel Signing).\nSi s’utilitza Shim, aquest actua com a intermediari: el firmware UEFI confia en Shim, i Shim verifica després GRUB i el kernel."
  },
  {
    "objectID": "slides/02-booting-part2.html#problemes-de-secure-boot",
    "href": "slides/02-booting-part2.html#problemes-de-secure-boot",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Problemes de Secure Boot",
    "text": "Problemes de Secure Boot\n\nCompatibilitat: No tots els sistemes operatius o distribucions Linux suporten Secure Boot de manera nativa.\nClaus de confiança: La gestió de claus pot ser complexa, especialment en entorns corporatius.\nActualitzacions: Les actualitzacions del bootloader o del kernel poden requerir la re-signatura dels components.\nRestriccions: Algunes funcionalitats avançades poden estar limitades per les polítiques de Secure Boot.\n\nMalgrat Secure Boot, s’han detectat vulnerabilitats que permeten carregar bootloaders no autoritzats en alguns dispositius (ArsTechnica, 2024)."
  },
  {
    "objectID": "slides/02-booting-part2.html#què-és-el-kernel",
    "href": "slides/02-booting-part2.html#què-és-el-kernel",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Què és el kernel?",
    "text": "Què és el kernel?\nEl kernel és el nucli del sistema operatiu, responsable de gestionar els recursos del sistema, com la memòria, el processador, els dispositius d’entrada/sortida, la xarxa i els processos d’usuari.\n\n\n\n\n\n\n\nEl kernel es carrega a la memòria RAM durant el procés d’arrencada i es troba normalment a la partició arrel del sistema de fitxers (generalment en /boot).\nEl kernel és un programa binari que es compila específicament per a l’arquitectura de maquinari del sistema (per exemple, x86, ARM, etc.)\nPot ser personalitzat amb diferents mòduls i controladors segons les necessitats del sistema."
  },
  {
    "objectID": "slides/02-booting-part2.html#carregar-el-kernel",
    "href": "slides/02-booting-part2.html#carregar-el-kernel",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Carregar el kernel",
    "text": "Carregar el kernel\nPer carregar el kernel, el bootloader necessita:\n\nRuta del kernel\n\nNormalment un fitxer com vmlinuz-version dins de /boot.\n\nPartició arrel\n\nLa partició on es troba el sistema de fitxers del sistema operatiu.\n\nFitxer de configuració del bootloader\n\nCom grub.cfg en el cas de GRUB, que indica ruta del kernel, paràmetres i initramfs.\n\nCàrrega de l’initramfs\n\nInitramfs (initial RAM filesystem) és un sistema de fitxers temporal a RAM.\n\nPermet inicialitzar controladors bàsics i muntar la partició arrel real abans de transferir el control al kernel complet.\n\n\n\nL’initramfs facilita la portabilitat i modularitat del kernel, permetent arrencar diferents configuracions de maquinari sense necessitat de recompilar el kernel cada cop."
  },
  {
    "objectID": "slides/02-booting-part2.html#què-és-linitramfs",
    "href": "slides/02-booting-part2.html#què-és-linitramfs",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Què és l’Initramfs?",
    "text": "Què és l’Initramfs?\nL’Initramfs (Initial RAM Filesystem) és un petit sistema de fitxers integrat dins la imatge del nucli Linux.\n\nPermet que el kernel pugui muntar la partició arrel durant l’arrencada.\n\nA diferència de l’antic initrd, que residia en un disc, l’initramfs es carrega completament a RAM com a imatge comprimida.\n\n\nObjectius\n\nProporcionar un sistema de fitxers temporal i mínim.\n\nCarregar mòduls essencials del kernel necessaris per accedir a maquinari i sistemes de fitxers.\n\nExecutar scripts d’inicialització abans de transferir el control al sistema complet."
  },
  {
    "objectID": "slides/02-booting-part2.html#etapes-de-linitramfs-i",
    "href": "slides/02-booting-part2.html#etapes-de-linitramfs-i",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Etapes de l’Initramfs (I)",
    "text": "Etapes de l’Initramfs (I)\n\nDescompressió a la RAM\n\nEl fitxer CPIO de l’initramfs es descomprimeix a un sistema de fitxers temporal a RAM (tmpfs), creant l’entorn mínim necessari per iniciar el kernel.\n\n\nExecució de l’script /init\n\n/init és l’entrypoint principal de l’initramfs.\n\nExecuta la seqüència d’inicialització: muntatge de sistemes virtuals, càrrega de mòduls i preparació de l’entorn.\n\n\nCreació del sistema de fitxers temporal\n\nMuntatge de /proc, /sys i /dev.\n\nCreació de directoris temporals (/tmp, /run) per permetre que els scripts i utilitats funcionin."
  },
  {
    "objectID": "slides/02-booting-part2.html#etapes-de-linitramfs-ii",
    "href": "slides/02-booting-part2.html#etapes-de-linitramfs-ii",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Etapes de l’Initramfs (II)",
    "text": "Etapes de l’Initramfs (II)\n\nCarregar mòduls del kernel\n\nCarrega controladors necessaris per accedir a maquinari (discos, controladors de xarxa, LVM, RAID, xifrat).\n\nSi els mòduls estan integrats al kernel, aquesta etapa pot ser mínima o nul·la.\n\nMuntatge de la partició arrel real\n\nLocalitza la partició arrel (per exemple /dev/sda1 o UUID=...).\n\nMuntatge en un punt temporal (/mnt/root o similar).\n\n\nTransició al sistema complet (switch_root)\n\nSubstitueix l’entorn temporal de l’initramfs pel sistema de fitxers real.\n\nExecuta el binari init del sistema complet (normalment /sbin/init o systemd)."
  },
  {
    "objectID": "slides/02-booting-part2.html#etapes-de-linitramfs-iii",
    "href": "slides/02-booting-part2.html#etapes-de-linitramfs-iii",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Etapes de l’Initramfs (III)",
    "text": "Etapes de l’Initramfs (III)\n\nAlliberament de l’initramfs\n\nDestruir l’entorn temporal a RAM.\n\nAlliberar la memòria utilitzada pel sistema de fitxers temporal, deixant el control complet al sistema operatiu."
  },
  {
    "objectID": "slides/02-booting-part2.html#característiques-de-linitramfs",
    "href": "slides/02-booting-part2.html#característiques-de-linitramfs",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Característiques de l’Initramfs",
    "text": "Característiques de l’Initramfs\n\nFacilita la portabilitat i modularitat del kernel, permetent arrencar diferents configuracions de maquinari sense necessitat de recompilar el kernel cada cop.\nNo sempre està present, pot estar buit o omès si el sistema no necessita un espai RAM inicial (per exemple, en sistemes simples o compilacions estàtiques del nucli).\nEs configura durant la compilació del nucli make menuconfig i es pot definir el contingut de l’initramfs amb un fitxer de configuració, s’utiltizen variables:\n\nCONFIG_BLK_DEV_INITRD: Activa la creació de l’initramfs.\nCONFIG_INITRAMFS_SOURCE: Especifica el fitxer CPIO, un directori o un fitxer d’especificació.\n\nTambé es pot personalitzar segons les necessitats del sistema, permetent afegir mòduls del kernel, scripts personalitzats o utilitats addicionals."
  },
  {
    "objectID": "slides/02-booting-part2.html#contingut-de-linitramfs",
    "href": "slides/02-booting-part2.html#contingut-de-linitramfs",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Contingut de l’initramfs",
    "text": "Contingut de l’initramfs\n\nFitxers executables\n\nEx: BusyBox, que encapsula moltes utilitats Unix (ls, cp, mount, shell, etc.).\n\nPoden incloure altres programes compilats estàticament.\n\nMòduls del kernel\n\nControladors per discos, xarxes, sistemes RAID o LVM.\n\nSón carregats si no estan integrats dins del nucli.\n\nFitxers de dispositiu i sistemes especials\n\n/dev conté dispositius com tty o null.\n\nGestionats per utilitats com mdev o udev.\n\n\n\nTots aquests elements es troben comprimits en un fitxer CPIO, descomprimits a RAM durant l’arrencada i executats per l’script /init."
  },
  {
    "objectID": "slides/02-booting-part2.html#configuració-de-linitramfs",
    "href": "slides/02-booting-part2.html#configuració-de-linitramfs",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Configuració de l’initramfs",
    "text": "Configuració de l’initramfs\nL’initramfs es pot personalitzar segons les necessitats del sistema, permetent afegir mòduls del kernel, scripts personalitzats o utilitats addicionals. La configuració depèn de la distribució:\nDebian/Ubuntu\nupdate-initramfs -u -k &lt;versió&gt;\n# -u actualitza l'initramfs\n# -k especifica la versió del nucli\n\nFedora/Red Hat\ndracut -f /boot/initramfs-&lt;versió&gt;.img &lt;versió&gt;\n# -f força la regeneració\n# El primer argument és la ruta on es vol guardar l'initramfs generat\n# El segon argument és la versió del nucli"
  },
  {
    "objectID": "slides/02-booting-part2.html#initramfs-tools-debian-i",
    "href": "slides/02-booting-part2.html#initramfs-tools-debian-i",
    "title": "Arrencada del sistema (Part 2)",
    "section": "initramfs-tools (Debian) (I)",
    "text": "initramfs-tools (Debian) (I)\n\n/etc/initramfs-tools/modules\nLlista de mòduls addicionals del kernel a incloure a l’initramfs, per exemple controladors de xarxa o discos RAID.\n\n/etc/initramfs-tools/hooks/\nScripts que s’executen durant la creació de l’initramfs, útils per afegir fitxers o directoris personalitzats.\n\n/etc/initramfs-tools/conf.d/\nFitxers de configuració addicionals per modificar paràmetres específics de l’initramfs.\n\n/etc/initramfs-tools/initramfs.conf\nConfiguració principal, inclou opcions com compressió, ús de scripts, paràmetres de muntatge.\n\n/usr/share/initramfs-tools/\nScripts i fitxers estàndard utilitzats per initramfs-tools, no modificats normalment."
  },
  {
    "objectID": "slides/02-booting-part2.html#initramfs-tools-debian-ii",
    "href": "slides/02-booting-part2.html#initramfs-tools-debian-ii",
    "title": "Arrencada del sistema (Part 2)",
    "section": "initramfs-tools (Debian) (II)",
    "text": "initramfs-tools (Debian) (II)\n\n/etc/initramfs-tools/scripts/\nScripts que s’executen durant l’arrencada:\n\ninit-top/ → scripts executats just després de descomprimir l’initramfs i abans de muntar /proc, /sys i /dev. Ideal per inicialitzar serveis crítics o preparar dispositius especials.\n\ninit-bottom/ → scripts executats just abans de fer switch_root al sistema complet. Útil per passos finals com muntar la partició arrel, desbloquejar LUKS o activar LVM.\n\nlocal-bottom/ → scripts addicionals definits per l’administrador.\nlocal-top/ → scripts addicionals definits per l’administrador."
  },
  {
    "objectID": "slides/02-booting-part2.html#initramfs-tools-debian-ii-1",
    "href": "slides/02-booting-part2.html#initramfs-tools-debian-ii-1",
    "title": "Arrencada del sistema (Part 2)",
    "section": "initramfs-tools (Debian) (II)",
    "text": "initramfs-tools (Debian) (II)\n\npremount/ → scripts executats abans de muntar la partició arrel. Ideal per preparar dispositius o sistemes de fitxers especials.\nmount/ → scripts executats durant el muntatge de la partició arrel. Útil per passos específics relacionats amb el muntatge.\ncleanup/ → scripts executats després de fer switch_root al sistema complet. Ideal per netejar recursos temporals o realitzar tasques posteriors a l’arrencada."
  },
  {
    "objectID": "slides/02-booting-part2.html#dracut-fedorared-hat",
    "href": "slides/02-booting-part2.html#dracut-fedorared-hat",
    "title": "Arrencada del sistema (Part 2)",
    "section": "dracut (Fedora/Red Hat)",
    "text": "dracut (Fedora/Red Hat)\n\n/etc/dracut.conf\nFitxer de configuració principal de Dracut, on es poden definir opcions generals: compressió, tipus de fitxer d’initramfs, paràmetres del kernel, etc.\n\n/etc/dracut.conf.d/\nFitxers de configuració addicionals, útils per a configuracions específiques de mòduls o projectes.\n\n/usr/lib/dracut/modules.d/\nConté mòduls estàndard de Dracut (ex: mòduls de xarxa, lvm, cryptsetup), carregats automàticament segons la configuració.\n\n/etc/dracut/modules.d/\nMòduls personalitzats creats per l’administrador, per afegir scripts o fitxers específics.\n\n/usr/share/dracut/\nConté scripts i fitxers estàndard utilitzats durant la generació de l’initramfs, igual que a initramfs-tools."
  },
  {
    "objectID": "slides/02-booting-part2.html#quan-regenerar-linitramfs",
    "href": "slides/02-booting-part2.html#quan-regenerar-linitramfs",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Quan regenerar l’initramfs?",
    "text": "Quan regenerar l’initramfs?\n\nActualització del nucli: Quan es compila o instal·la un nou kernel, l’initramfs associat ha de ser regenerat per garantir que carrega correctament els mòduls i el maquinari necessari.\nConfiguració RAID: Si es modifiquen o s’afegeixen sistemes RAID, l’initramfs ha de reflectir aquests canvis per assegurar un arrencada correcta.\nXifrat de discos: Per a sistemes amb particions xifrades (LUKS), cal actualitzar l’initramfs després de canvis en la configuració de xifrat per poder accedir a les particions durant l’arrencada.\nConfiguració de xarxa: Si es canvien components de xarxa que s’utilitzen en el procés d’arrencada (sistemes amb arrencada PXE)."
  },
  {
    "objectID": "slides/02-booting-part2.html#cas-dus-usb-amb-clau-de-desxifrat",
    "href": "slides/02-booting-part2.html#cas-dus-usb-amb-clau-de-desxifrat",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Cas d’us: USB amb clau de desxifrat",
    "text": "Cas d’us: USB amb clau de desxifrat\nUn cas d’ús comú de l’initramfs és en sistemes amb particions xifrades amb LUKS que utilitzen una clau emmagatzemada en un dispositiu USB per desxifrar la partició arrel durant l’arrencada.\n\n\n\nMunti els sistemes virtuals necessaris (/proc, /sys).\n\nMunti la unitat USB que conté la clau.\n\nLlegeixi la clau i desxifri la partició LUKS.\n\nActivar volums LVM si cal.\n\nMuntar la partició arrel i transferir el control amb switch_root.\n\n\n#!/bin/busybox sh\nmount -t proc proc /proc\nmount -t sysfs sys /sys\nmount /dev/sdb1 /mnt\nKEYFILE=/mnt/keyfile\ncryptsetup luksOpen /dev/sda1 crypted --key-file $KEYFILE\necho \"Retira el dispositiu USB i prem Enter per continuar.\"\nread\nvgchange -a y\nmount /dev/mapper/vg-root /mnt\nexec switch_root /mnt /sbin/init"
  },
  {
    "objectID": "slides/02-booting-part2.html#exercicis-propostas",
    "href": "slides/02-booting-part2.html#exercicis-propostas",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Exercicis Propostas",
    "text": "Exercicis Propostas\n\nModificant la contrasenya de l’usuari root a través del GRUB\nDesxifrat automàtic mitjançant clau en disc secundari (USB emulat)\nDiscussió: Secure Boot és realment segur?: Cerca notícies recents sobre Secure Boot i comparteix-les al fòrum del curs. Debatiu sobre avantatges, desavantatges, vulnerabilitats conegudes i experiències personals."
  },
  {
    "objectID": "slides/02-booting-part2.html#thats-all",
    "href": "slides/02-booting-part2.html#thats-all",
    "title": "Arrencada del sistema (Part 2)",
    "section": "That’s all",
    "text": "That’s all\n\n\n\n\n\n\n\n\n\nTake Home Message\n\n\nEl procés d’arrencada és un procés complex. Els administradors de sistemes han de conèixer aquest procés per poder gestionar i solucionar problemes durant l’arrencada del sistema i garantir un sistema segur, estable i eficient."
  },
  {
    "objectID": "laboratories/01-foundations/01-aws-introduction.html",
    "href": "laboratories/01-foundations/01-aws-introduction.html",
    "title": "Executing a Python script in a EC2 instance",
    "section": "",
    "text": "CONTENTS:",
    "crumbs": [
      "1 · Executing a Python script in a EC2 instance"
    ]
  },
  {
    "objectID": "laboratories/01-foundations/01-aws-introduction.html#pas-1-creacio-dun-compte-daws-academy",
    "href": "laboratories/01-foundations/01-aws-introduction.html#pas-1-creacio-dun-compte-daws-academy",
    "title": "Executing a Python script in a EC2 instance",
    "section": "1. Creating an AWS Academy Account",
    "text": "1. Creating an AWS Academy Account\nCheck your email to see if you have received an email from AWS Academy with the subject Course Invitation. If you haven’t received it, let me know. The email will contain a button labeled Get Started. Click this button to begin the registration process.\n\nAfter clicking the Get Started button, you will be redirected to the AWS Academy login page. Now click the Create my account button to start the registration process, as shown below:\n\nChoose a password and complete the registration process. Once you have completed the registration, you will be redirected to the AWS Academy dashboard. Congratulations! You have successfully created your AWS Academy account.",
    "crumbs": [
      "1 · Executing a Python script in a EC2 instance"
    ]
  },
  {
    "objectID": "laboratories/01-foundations/01-aws-introduction.html#pas-2-acces-al-tauler-daws",
    "href": "laboratories/01-foundations/01-aws-introduction.html#pas-2-acces-al-tauler-daws",
    "title": "Executing a Python script in a EC2 instance",
    "section": "2. Accessing the AWS Dashboard",
    "text": "2. Accessing the AWS Dashboard\nNow that you have created your AWS Academy account, you can access the AWS dashboard. The first thing you need to do is click the Courses tab (1) on the left side of the screen. You will see a list of courses available to you. Click the course AWS Academy Learner Lab (2), as shown in the screenshot below:\n\n\n\n\n\n\n\nNote\n\n\n\nThe course AWS Academy Learner Lab is the course you will use for these practical labs.\n\n\nNow we need to look for the Modules tab (1) on the left side of the screen. Click on it and you will see a list of modules available to you. Click on the AWS Academy Learner Lab module (2), as shown below:\n\nYou will now be asked to accept the course terms and conditions. Do this by scrolling to the bottom of the page and clicking the button I Agree.\n\nAfter accepting the terms and conditions, you just need to click the button Start Lab.\n\nNow give it a few minutes to load. You will see this animation while the lab is being prepared for you:\n\nFinally, when the lab is ready, you will see that the dot next to AWS is green. You will also see a timer counting down from 4 hours. This is the time you have to work in the lab. To the left of the timer, you will see your budget status. You have a budget of $50 to spend on AWS services. Click on AWS to access the AWS dashboard, as shown below:\n\n\n\n\n\n\n\nImportantConsiderations about the laboratories\n\n\n\nThe labs are a real AWS environment, so it’s important to be careful with resources and your actions.\n\nIf you exceed the $50 budget, you will no longer have access to the AWS dashboard and you will lose your work. Make sure to monitor your budget — it is each student’s responsibility to stay within the limit.\nThe labs last for 4 hours. Once the 4 hours have passed, the session will expire and you will not be able to access the AWS dashboard. However, this does not mean you will automatically lose your work.\nThe tasks and resources you have created (such as EC2 instances, S3 buckets, etc.) will remain accessible between sessions, as long as you do not delete them manually. You can restart the lab as many times as you want, but it is good practice to stop or shut down services you no longer need to avoid consuming unnecessary resources by clicking Reset.\nTherefore, if you start a lab and leave it unfinished, you will be able to resume it in a later session.Per tant, si comences un laboratori i el deixes a mig fer, podràs reprendre’l en una sessió posterior.\n\n\n\nGreat! You have now accessed the AWS dashboard. You will see a screen similar to the one below:",
    "crumbs": [
      "1 · Executing a Python script in a EC2 instance"
    ]
  },
  {
    "objectID": "laboratories/01-foundations/01-aws-introduction.html#pas-3-importació-de-la-clau-pública-a-aws",
    "href": "laboratories/01-foundations/01-aws-introduction.html#pas-3-importació-de-la-clau-pública-a-aws",
    "title": "Executing a Python script in a EC2 instance",
    "section": "3. Creating an SSH key pair",
    "text": "3. Creating an SSH key pair\nThe SSH key is a security mechanism that enables secure authentication between two systems. The Amazon EC2 server holds the public key, and the client (your local computer) holds the private key. When the client connects to the server, the server checks whether the client’s public key matches the server’s private key. If the keys match, the client connects to the server. Therefore, the private key must never be shared with anyone, while the public key can be shared freely and used on multiple servers. Currently, there is no mechanism to obtain the private key from the public key.\nTo create an SSH key pair, we will use the ssh-keygen command. This command is available on most operating systems, including Linux, macOS, and Windows (via PowerShell or Windows Subsystem for Linux - WSL). If you are using Windows and do not have access to ssh-keygen, you can use tools like PuTTYgen to generate SSH keys.\nThis command has several parameters that allow you to customize the SSH key. The most common parameters are:\n\n-t: Specifies the encryption type of the key. The most common types are rsa, dsa, ecdsa, and ed25519.\n-f: Specifies the name of the file where the key will be saved.\n-b: Specifies the length of the key in bits.\n\nThe first step to create the SSH key pair is to make sure the .ssh directory exists. To do this, open a terminal on your local computer and type the following command:\ncd          # we suppose the .ssh directory will be located in the home directory\nmkdir .ssh\n\n\n\n\n\n\nWarning\n\n\n\nIf the .ssh directory already exists, you will get an error indicating that the directory already exists. This is normal; it simply means the directory was already there.\n\n\nNow we will create the SSH key pair. Type the following command:\nssh-keygen -t rsa -f .ssh/aws-keypair\nYou will be asked to enter a passphrase. You can leave it empty by pressing Enter twice (I recommend doing this for simplicity; otherwise, you will have to enter the passphrase every time you connect to the remote machine). You should see an output similar to the following:\nGenerating public/private rsa key pair.\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in .ssh/aws-keypair\nYour public key has been saved in .ssh/aws-keypair.pub\nThe key fingerprint is:\nSHA256:uhINFvYaJh6MbwFQCXdZyrW7W46jFGHUhLglDgQ5OYE ferran@DESKTOP-0841\n+---[RSA 3072]----+\n|XBooo*+          |\n|E.++*o..         |\n| O ==o.          |\n|. B.=...         |     \n| o *.=. S        |\n|  + o..o         |\n| .  ..o .        |\n|   .. .*         |\n|    .o+..        |\n+----[SHA256]-----+\nssh-keygen is the command to generate the key pair. The -t rsa option specifies the type of key to create, in this case an RSA key, and -f .ssh/aws-keypair specifies the filename for the key pair. You can name the file whatever you like, but it’s important to remember the name you choose. In this example, we are naming it aws-keypair. I recommend using the same name to avoid confusion later.\n\n\n\n\n\n\nTipUnderstanding SSH keys - See video\n\n\n\nIt is essential to understand how public and private keys work and how they are used to establish a connection SSH, see this video.\n\n\nWe can check the contents of the directory .ssh with:\nls .ssh\naws-keypair   aws-keypair.pub\nWe should now see two files, aws-keypair and aws-keypair.pub. The first is the private key and the second is the public key. The private key should never be shared with anyone, while the public key is the one that should be shared with the remote machine. A useful command to inspect the contents of a file is `cat. For example, to view the contents of the public key, type the following command:\ncat .ssh/aws-keypair.pub\n\n\n\n\n\n\nNote\n\n\n\nYou can also inspect the contents of the .ssh folder and the files inside it using the File Explorer (or Finder on Mac devices). But be careful — by default, folders and files that start with a dot, . (like .ssh) are hidden in most file explorers, and if you want to see them, you’ll need to enable the option to show hidden files. Check this tutorial to see how to do it on your operating system.\nAnother thing to keep in mind is that file extensions (i.e., the part of the file name that comes after the last .) are also usually hidden. This means that in the File Explorer you might see two files named aws-keypair when in reality one is aws-keypair and the other is aws-keypair.pub. Here’s [a tutorial]https://www.gottheknack.com/a-how-to/file-systems/file-ext-and-details-view/file-ext-and-details-view.html) on how to show file extensions on your operating system.\nYou don’t need to worry about any of this if you’re using the terminal — the terminal will show files and their extensions as they are. However, to view hidden files and folders (those that start with a .), you’ll need to use the command ls -a.\nls -a .ssh\n\n\nWe have created an SSH key pair that we can use to connect to remote machines. Next, we will import our public key into AWS.",
    "crumbs": [
      "1 · Executing a Python script in a EC2 instance"
    ]
  },
  {
    "objectID": "laboratories/01-foundations/01-aws-introduction.html#pas-4-importacio-de-la-clau-publica-a-aws",
    "href": "laboratories/01-foundations/01-aws-introduction.html#pas-4-importacio-de-la-clau-publica-a-aws",
    "title": "Executing a Python script in a EC2 instance",
    "section": "4. Importing the public key into AWS",
    "text": "4. Importing the public key into AWS\nNow that we’ve created our SSH key pair, we need to import the public key into AWS so we can use it to connect to the EC2 instances we’ll create later. To do this, we need to go back to the AWS dashboard, which is where we left off after completing Step 2.\nNow we’ll go to the search bar and look for the EC2 service. Type EC2 into the search bar and click on the EC2 service, as shown below:\n\n\n\nAWS Dashboard\n\n\nYou will now see the EC2 dashboard. On the left side of the screen, you’ll find a list of options. Click on Import key pair, as shown below:\n\n\n\nAWS Dashboard\n\n\nNow you need to give a name to the key pair. You can name it whatever you like, but I suggest naming it aws-keypair to keep things simple. You can now insert the public key into the text box, or you can click the Browse button to select the public key file from your computer. Just click Browse, navigate to the .ssh folder, and select the aws-keypair.pub file. Alternatively, you can copy the content of aws-keypair.pub (the public key) into the box. But remember, the file must be the public key file, not the private key file. That means the file must have the .pub extension. Once you’ve selected the file, click Import Key Pair.\n\n\n\nAWS Dashboard\n\n\n\n\n\n\n\n\nNote\n\n\n\nRemember, as explained in the previous note, you might not see the .ssh folder in the file explorer, and you might not see the .pub extension of the file. If you’re having trouble with this, I recommend using the terminal to copy the contents of the file, as shown in the screenshot above.\n\n\nYou should now see the key pair you just imported in the list of key pairs. There will probably be another key pair there — that’s fine, you can ignore it. Perfect! You’ve now imported the public key into AWS. Next, we’ll create an EC2 instance and configure it to use the key pair we just imported.",
    "crumbs": [
      "1 · Executing a Python script in a EC2 instance"
    ]
  },
  {
    "objectID": "laboratories/01-foundations/01-aws-introduction.html#pas-5-creacio-duna-instancia-ec2",
    "href": "laboratories/01-foundations/01-aws-introduction.html#pas-5-creacio-duna-instancia-ec2",
    "title": "Executing a Python script in a EC2 instance",
    "section": "5. Creating an EC2 instance",
    "text": "5. Creating an EC2 instance\nThe first step will be to go to the EC2 dashboard. You can do this by typing EC2 into the search bar and clicking on the EC2 service, just like we did at the beginning of Step 3:\n\n\n\nAWS Dashboard\n\n\nOnce you’re on the EC2 dashboard, click on Instances &gt; Launch Instance, as shown below:\n\n\n\nAWS Dashboard\n\n\nLeave everything as it is except for the Key pair (login) option (you’ll need to scroll down to find it). Click the dropdown menu and select the key pair you imported earlier. In this case, it should be aws-keypair. Click Launch instance, as shown below\n\n\n\nAWS Dashboard\n\n\nWe now have a running EC2 instance with our public key imported. This means we have a remote machine on AWS that we can connect to from our local computer using SSH. Let’s see how to do that.",
    "crumbs": [
      "1 · Executing a Python script in a EC2 instance"
    ]
  },
  {
    "objectID": "laboratories/01-foundations/01-aws-introduction.html#pas-6-connexio-a-la-instancia-ec2",
    "href": "laboratories/01-foundations/01-aws-introduction.html#pas-6-connexio-a-la-instancia-ec2",
    "title": "Executing a Python script in a EC2 instance",
    "section": "6. Connecting to the EC2 instance",
    "text": "6. Connecting to the EC2 instance\nBefore connecting to the remote machine, you may try a few commands on your local computer that we will repeat once we are connected to the remote machine. One of the commands is pwd, which stands for print working directory, as mentioned earlier. This command will show you the path to the directory you are currently in. The other command is whoami, which will show you the username you are logged in with. Try these commands on your local computer and remember the output. We will repeat them once we are connected to the remote machine.\nBelow is the output I get on my local computer:\nPS C:\\Users\\fnao&gt; pwd\n\nPS C:\\Users\\fnao&gt; whoami\ngft\\fnao\nPS C:\\Users\\fnao&gt;\n\n\n\n\n\n\nWarning\n\n\n\nThe local computer I’m using is a Windows laptop, so the output will be different from yours if you’re using a Mac or a computer running Linux. Replace fnao with your own username and C:\\Users\\fnao with the path to your user directory.\n\n\nTo connect to the EC2 instance, we will use the terminal on our local computer, just as we did at the beginning Step 3, Open a terminal on your local computer. We will use the ssh command to connect to the remote machine. The command will look like this:\nssh -i .ssh/aws-keypair ec2-user@&lt;public-ip&gt;\nYou will need to replace &lt;public-ip&gt; with the public IP of the EC2 instance. To find the public IP, go back to the EC2 dashboard and click on Instances, on the left side of the screen. You will see a list of instances—click on the one you created. You will see the public IP at the bottom of the screen, as shown below:\n\n\n\nAWS Dashboard\n\n\nBoth the Public IPv4 address and the Public IPv4 DNS can be used as &lt;public-ip&gt; in the ssh command. Copy whichever you prefer and paste it into the ssh command. The command should look something like this if you use the IP address:\nssh -i .ssh/aws-keypair ec2-user@98.84.68.70\nor like this if you use the DNS:\nssh -i .ssh/aws-keypair ec2-user@ec2-98-84-68-70.compute-1.amazonaws.com\nIf this is the first time you’re connecting to the remote machine, you’ll get a warning. This is normal—just type yes and press Enter. You should now be connected to the remote machine. You’ll see a message similar to the following:\n   ,     #_\n   ~\\_  ####_        Amazon Linux 2023\n  ~~  \\_#####\\\n  ~~     \\###|\n  ~~       \\#/ ___   https://aws.amazon.com/linux/amazon-linux-2023\n   ~~       V~' '-&gt;\n    ~~~         /\n      ~~._.   _/\n         _/ _/\n       _/m/'\nLast login: Sun Mar  2 09:50:33 2025 from 79.156.58.43\n[ec2-user@ip-172-31-86-82 ~]$\n\n\n\n\n\n\nImportantExercise\n\n\n\nInvestigate the meaning and importance of the message you accept when connecting to the remote machine for the first time. Why is it important to accept this message? What does it mean? What are its implications?\n\n\nYou are now connected to the remote machine. It’s important to understand that from this point on, the commands we type will be executed on the remote machine, not on our local computer. To verify this, type the commands pwd and whoami as we did on our local computer. You’ll see that the output is different. Below is the output I get on the remote machine:\n[ec2-user@ip-172-31-86-82 ~]$ pwd\n/home/ec2-user\n[ec2-user@ip-172-31-86-82 ~]$ whoami\nec2-user\n[ec2-user@ip-172-31-86-82 ~]$",
    "crumbs": [
      "1 · Executing a Python script in a EC2 instance"
    ]
  },
  {
    "objectID": "laboratories/01-foundations/01-aws-introduction.html#execucio-en-el-nostre-laboratori-remot",
    "href": "laboratories/01-foundations/01-aws-introduction.html#execucio-en-el-nostre-laboratori-remot",
    "title": "Executing a Python script in a EC2 instance",
    "section": "7. Working in the EC2 instance",
    "text": "7. Working in the EC2 instance\nThis step will cover file transfer between the local machine and the remote machine. Additionally, we will use a Python script to simulate a workload and generate a graph from a data file.\n\n7.1. Transferring a data file to the EC2 instance EC2\nTo transfer a data file (workload.csv) to the EC2 instance, we will use SFTP (SSH File Transfer Protocol). SFTP is a secure protocol for transferring files between a local computer and a remote machine. We will use the same SSH key pair we created earlier to authenticate to the EC2 instance.\n\nDownload the data file workload.csv to your local computer.\nUse SFTP to upload the data file to the EC2 instance:\n# Replace &lt;public-ip&gt; with the public IP of your EC2 instance\nsftp -i .ssh/aws-keypair ec2-user@&lt;public-ip&gt;:/home/ec2-user\n# Download the workload.csv file from the remote directory to your local machine\nput workload.csv\n# Close the SFTP session\nexit\n\n\n\n7.2. Setup and Python script execution in the EC2\nFirst, we need to prepare the environment on our EC2 instance. This includes installing the necessary tools to run our Python script and manage data. So, we’ll connect to the EC2 instance via ssh as we did earlier and run the following commands to install the required tools.\n\nConnect to the EC2 instance:\n\nssh -i .ssh/aws-keypair ec2-user@&lt;public-ip&gt;\n\nSystem update:\n\nsudo yum update -y\n\nCheck if Python is installed, and if not, install it:\n\npython3 --version # Comprova si Python està instal·lat\nsudo yum install python3 -y # Instal·la Python si no està instal·lat\n\nCreate a virtual environment for Python:\n\npython3 -m venv myenv\nsource myenv/bin/activate\n\nCheck the virtual environment with a Hello World:\n\npython3 -c \"print('Hello World from the virtual environment')\"\n\nInstall the necessary libraries for our script:\n\npip install pandas matplotlib psutil\n\nCreate a virtual environment for Python:\n\nmkdir lab01-workload-simulation\nmv workload.csv lab01-workload-simulation\ncd lab01-workload-simulation\n\nCreate the Python script file, using vi or vim:\n\nvi simulate_workload.py\n\n#!/usr/bin/env python3\nimport sys\nimport time\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    if len(sys.argv) != 2:\n        print(\"Ús: python3 simulate.py workload.csv\")\n        sys.exit(1)\n\n    csv_file = sys.argv[1]\n    df = pd.read_csv(csv_file)\n\n    print(\"Simulació d'ús de CPU i memòria (amb gràfic)\\n\")\n\n    plt.ion()\n    fig, ax = plt.subplots()\n    cpu_vals, mem_vals, ts_vals = [], [], []\n\n    for i, row in df.iterrows():\n        ts = row['timestamp']\n        cpu = row['cpu_usage']\n        mem = row['memory_usage']\n\n        print(f\"[{ts}] CPU: {cpu:.2f}%  |  MEM: {mem:.2f}%\")\n\n        ts_vals.append(ts)\n        cpu_vals.append(cpu)\n        mem_vals.append(mem)\n\n        ax.clear()\n        ax.plot(ts_vals, cpu_vals, label=\"CPU (%)\", color=\"tab:red\", marker=\"o\")\n        ax.plot(ts_vals, mem_vals, label=\"Memòria (%)\", color=\"tab:blue\", marker=\"x\")\n        ax.set_ylim(0, 100)\n        ax.set_xlabel(\"Temps\")\n        ax.set_ylabel(\"Ús (%)\")\n        ax.set_title(\"Simulació de càrrega del sistema\")\n        ax.legend()\n        plt.xticks(rotation=45)\n\n\n    print(\"\\n--- Fi de la simulació ---\")\n    plt.savefig(\"workload_analysis.png\")\n\nif __name__ == \"__main__\":\n    main()\n\nRun the script with the following command:\n\npython3 simulate_workload.py workload.csv\nNow it should work correctly and generate an image file with the workload graph. You can check that the image file (workload_analysis.png) has been created correctly using the `ls -l command. Once the image has been generated, you can use SFTP to download it to your local machine:\nsftp -i .ssh/aws-keypair ec2-user@&lt;public-ip&gt;:/home/ec2-user/lab01-workload-simulation\nget workload_analysis.png",
    "crumbs": [
      "1 · Executing a Python script in a EC2 instance"
    ]
  },
  {
    "objectID": "laboratories/01-foundations/01-aws-introduction.html#neteja-final",
    "href": "laboratories/01-foundations/01-aws-introduction.html#neteja-final",
    "title": "Executing a Python script in a EC2 instance",
    "section": "8. Cleanup",
    "text": "8. Cleanup\nOnce you’ve finished the lab, it’s important to shut down the EC2 instance to avoid unnecessary costs. To do this, go back to the EC2 dashboard and select the instance you created. At the top of the screen, click on Instance state and then on Terminate instance.",
    "crumbs": [
      "1 · Executing a Python script in a EC2 instance"
    ]
  },
  {
    "objectID": "course-information/schedule.html",
    "href": "course-information/schedule.html",
    "title": "AMSA 105013: System Administration",
    "section": "",
    "text": "A continuació es presenta un calendari complet dels temes, el contingut del curs i les tasques per al semestre. Tingueu en compte que aquest calendari és un document viu i es pot actualitzar. Tots els canvis es publicaran aquí per assegurar-vos que teniu la informació més actual.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSetmana\nTipus\nData\nTema\nDiapositives\nApunts\nLaboratori\nAltres\nTasques\nLliuraments\n\n\n\n\n1\nTeoria\n10/09/25\nUnitat 01: Fonaments de l’Administració de Sistemes\n📖\n\n\n\n📝 📝\n\n\n\n2\nLaboratori\n15/09/25\nUnitat 01: Fonaments de l’Administració de Sistemes\n\n\n🧪 🧪\n\n\n\n\n\n2\nTeoria\n17/09/25\nUnitat 02: Arrencada del sistema\n📖\n\n\n\n📝 📝 📝\n\n\n\n3\nLaboratori\n24/09/25\nUnitat 02: Arrencada del sistema (II)\n📖\n\n\n💬\n📝 📝\n\n\n\n4\nTeoria\n29/09/25\nUnitat 02: Arrencada del sistema (III)\n📖\n\n\n💬\n📝 📝\n👩🏻‍💻\n\n\n4\nLaboratori\n01/10/25\nNetworking\n\n\n🧪\n\n\n\n\n\n5\nTeoria\n06/10/25\nUnitat 03: Sistemes de fitxers (Part 1)\n📖\n\n\n\n📝\n\n\n\n5\nLaboratori\n08/10/25\nNetworking\n\n\n🧪\n\n\n\n\n\n6\nTeoria\n13/10/25\nUnitat 03: Sistemes de fitxers (Part 2)\n📖\n\n\n\n📝\n\n\n\n6\nLaboratori\n15/10/25\n(Vaga general)\n\n\n\n\n\n\n\n\n7\nTeoria\n20/10/25\nUnitat 03: Sistemes de fitxers (Part 3)\n📖\n\n\n\n📝\n\n\n\n7\nLaboratori\n22/10/25\nUnitat 03: Pràctica 02\n\n\n\n \n\n👩🏻‍💻"
  },
  {
    "objectID": "course-information/schedule.html#planificació",
    "href": "course-information/schedule.html#planificació",
    "title": "AMSA 105013: System Administration",
    "section": "",
    "text": "A continuació es presenta un calendari complet dels temes, el contingut del curs i les tasques per al semestre. Tingueu en compte que aquest calendari és un document viu i es pot actualitzar. Tots els canvis es publicaran aquí per assegurar-vos que teniu la informació més actual.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSetmana\nTipus\nData\nTema\nDiapositives\nApunts\nLaboratori\nAltres\nTasques\nLliuraments\n\n\n\n\n1\nTeoria\n10/09/25\nUnitat 01: Fonaments de l’Administració de Sistemes\n📖\n\n\n\n📝 📝\n\n\n\n2\nLaboratori\n15/09/25\nUnitat 01: Fonaments de l’Administració de Sistemes\n\n\n🧪 🧪\n\n\n\n\n\n2\nTeoria\n17/09/25\nUnitat 02: Arrencada del sistema\n📖\n\n\n\n📝 📝 📝\n\n\n\n3\nLaboratori\n24/09/25\nUnitat 02: Arrencada del sistema (II)\n📖\n\n\n💬\n📝 📝\n\n\n\n4\nTeoria\n29/09/25\nUnitat 02: Arrencada del sistema (III)\n📖\n\n\n💬\n📝 📝\n👩🏻‍💻\n\n\n4\nLaboratori\n01/10/25\nNetworking\n\n\n🧪\n\n\n\n\n\n5\nTeoria\n06/10/25\nUnitat 03: Sistemes de fitxers (Part 1)\n📖\n\n\n\n📝\n\n\n\n5\nLaboratori\n08/10/25\nNetworking\n\n\n🧪\n\n\n\n\n\n6\nTeoria\n13/10/25\nUnitat 03: Sistemes de fitxers (Part 2)\n📖\n\n\n\n📝\n\n\n\n6\nLaboratori\n15/10/25\n(Vaga general)\n\n\n\n\n\n\n\n\n7\nTeoria\n20/10/25\nUnitat 03: Sistemes de fitxers (Part 3)\n📖\n\n\n\n📝\n\n\n\n7\nLaboratori\n22/10/25\nUnitat 03: Pràctica 02\n\n\n\n \n\n👩🏻‍💻"
  },
  {
    "objectID": "exercises/03-fs/10-ex-week7.html",
    "href": "exercises/03-fs/10-ex-week7.html",
    "title": "Laboratori: Desplegament d’un servidor web amb LVM",
    "section": "",
    "text": "En aquest laboratori aprendrem a utilitzar LVM (Logical Volume Manager) per administrar l’emmagatzematge d’un servidor web. Simularem un entorn real on diferents tipus de dades (codi font, dades de la web, i fitxers temporals) es gestionen mitjançant volums lògics, millorant la flexibilitat i escalabilitat del sistema."
  },
  {
    "objectID": "exercises/03-fs/10-ex-week7.html#objectius",
    "href": "exercises/03-fs/10-ex-week7.html#objectius",
    "title": "Laboratori: Desplegament d’un servidor web amb LVM",
    "section": "🎯 Objectius",
    "text": "🎯 Objectius\n\nEntendre el funcionament i components de LVM: PV, VG i LV.\n\nCrear, formatar i muntar volums lògics per a un servei web.\n\nAmpliar o reduir la mida dels volums.\n\nCrear i utilitzar snapshots per fer còpies de seguretat en calent."
  },
  {
    "objectID": "exercises/03-fs/10-ex-week7.html#escenari",
    "href": "exercises/03-fs/10-ex-week7.html#escenari",
    "title": "Laboratori: Desplegament d’un servidor web amb LVM",
    "section": "🧱 Escenari",
    "text": "🧱 Escenari\nGestionarem una aplicació web desplegada en un servidor AlmaLinux.\n\n\n\nDirectori\nFunció\nExemple de contingut\n\n\n\n\n/opt/webapp/sources\nCodi font Django\nPython, HTML, JS\n\n\n/opt/webapp/data\nDades, imatges, logs\nCSV, JPG, LOG\n\n\n/opt/webapp/run\nFitxers temporals i sockets\nPID, sock"
  },
  {
    "objectID": "exercises/03-fs/10-ex-week7.html#preparació-de-la-màquina-virtual",
    "href": "exercises/03-fs/10-ex-week7.html#preparació-de-la-màquina-virtual",
    "title": "Laboratori: Desplegament d’un servidor web amb LVM",
    "section": "🧩 Preparació de la màquina virtual",
    "text": "🧩 Preparació de la màquina virtual\n\nCrea una nova MV amb AlmaLinux i un disc principal de 20 GB.\nDurant la instal·lació, selecciona LVM com a esquema de particionat.\nAfegeix dos discos addicionals de 20 GB cadascun (ex. nvme0n2 i nvme0n3).\nComprova l’estat inicial del sistema:\nlsblk\nHauries de veure una sortida semblant a:\nnvme0n1     20G  \n├─nvme0n1p1 600M  /boot/efi\n├─nvme0n1p2   1G  /boot\n├─nvme0n1p3   2G  [SWAP]\n└─nvme0n1p4 16.4G /\nnvme0n2     20G\nnvme0n3     20G"
  },
  {
    "objectID": "exercises/03-fs/10-ex-week7.html#activitat-1.-creació-dels-volums-físics-i-grup-de-volums",
    "href": "exercises/03-fs/10-ex-week7.html#activitat-1.-creació-dels-volums-físics-i-grup-de-volums",
    "title": "Laboratori: Desplegament d’un servidor web amb LVM",
    "section": "🧠 Activitat 1. Creació dels volums físics i grup de volums",
    "text": "🧠 Activitat 1. Creació dels volums físics i grup de volums\n\nPas 1: Crear els volums físics\npvcreate /dev/nvme0n2 /dev/nvme0n3\n\n\n\n\n\n\nAlerta💡 Comprova l’estat dels PV\n\n\n\nQuin és l’estat del camp Allocatable abans de crear el grup de volums?\n\n\n\n\nPas 2: Crear el grup de volums vg_webapp\nvgcreate vg_webapp /dev/nvme0n2 /dev/nvme0n3\n\n\n\n\n\n\nAlerta💡 Comprova l’estat del VG\n\n\n\n\nQuina és la mida total del grup de volums vg_webapp?\nQuants extents té el VG i quina és la mida de cada extent?"
  },
  {
    "objectID": "exercises/03-fs/10-ex-week7.html#activitat-2.-creació-i-muntatge-dels-volums-lògics",
    "href": "exercises/03-fs/10-ex-week7.html#activitat-2.-creació-i-muntatge-dels-volums-lògics",
    "title": "Laboratori: Desplegament d’un servidor web amb LVM",
    "section": "⚙️ Activitat 2. Creació i muntatge dels volums lògics",
    "text": "⚙️ Activitat 2. Creació i muntatge dels volums lògics\n\nPas 1: Crear els LV\nlvcreate -L 1G -n lv_sources vg_webapp\nlvcreate -L 10G -n lv_data vg_webapp\nlvcreate -L 1G -n lv_run vg_webapp\n\n\nPas 2: Formatar els LV amb sistemes de fitxers\nmkfs.xfs /dev/vg_webapp/lv_sources\nmkfs.ext4 /dev/vg_webapp/lv_data\nmkfs.xfs /dev/vg_webapp/lv_run\n\n\n\n\n\n\nAlerta💡 Discussió\n\n\n\nPer què podria ser interessant utilitzar xfs per a /run i ext4 per a /data o al revés?\n\n\n\n\nPas 3: Muntar els volums\nmkdir -p /opt/webapp/{sources,data,run}\nmount /dev/vg_webapp/lv_sources /opt/webapp/sources\nmount /dev/vg_webapp/lv_data /opt/webapp/data\nmount /dev/vg_webapp/lv_run /opt/webapp/run\n\n\n\n\n\n\nAlerta💡 Comprova els muntatges\n\n\n\n\nUtilitza df -h per verificar que els volums estan muntats correctament.\nAfegeix les entrades corresponents a /etc/fstab per muntar-los automàticament en reiniciar."
  },
  {
    "objectID": "exercises/03-fs/10-ex-week7.html#activitat-3.-redimensionar-volums-lògics",
    "href": "exercises/03-fs/10-ex-week7.html#activitat-3.-redimensionar-volums-lògics",
    "title": "Laboratori: Desplegament d’un servidor web amb LVM",
    "section": "📏 Activitat 3. Redimensionar volums lògics",
    "text": "📏 Activitat 3. Redimensionar volums lògics\n\nEscenari 1: Augmentar lv_data de 10 GB a 20 GB\nQuan s’amplia un volum lògic, s’afegeixen nous extents al final del volum. Si el sistema de fitxers és ext4, cal actualitzar-ne la taula d’espai amb resize2fs.\nlvextend -L +10G /dev/vg_webapp/lv_data\nresize2fs /dev/vg_webapp/lv_data\n\n\nEscenari 2: Reduir lv_run de 1 GB a 500 MB\nEl sistema de fitxers xfs no permet reduir volums.\numount /opt/webapp/run\nlvremove /dev/vg_webapp/lv_run\nlvcreate -L 500M -n lv_run vg_webapp\nmkfs.xfs -f /dev/vg_webapp/lv_run\nmount /dev/vg_webapp/lv_run /opt/webapp/run\n\n\n\n\n\n\nAlerta💡 Reduir o Ampliar\n\n\n\nQuè creus que és més segur: redimensionar un volum lògic cap amunt o cap avall? Per què?"
  },
  {
    "objectID": "exercises/03-fs/10-ex-week7.html#activitat-4.-creació-dsnapshots",
    "href": "exercises/03-fs/10-ex-week7.html#activitat-4.-creació-dsnapshots",
    "title": "Laboratori: Desplegament d’un servidor web amb LVM",
    "section": "💾 Activitat 4. Creació d’snapshots",
    "text": "💾 Activitat 4. Creació d’snapshots\nEls snapshots LVM permeten fer còpies de seguretat en calent del sistema de fitxers. Aquest mecanisme utilitza la tècnica Copy-on-Write (COW) per mantenir versions consistents de les dades mentre s’estan utilitzant.\n\nPas 1: Crear dades\necho \"Hello, World1!\" &gt; /opt/webapp/data/file1.txt\necho \"Hello, World2!\" &gt; /opt/webapp/data/file2.txt\necho \"Hello, World3!\" &gt; /opt/webapp/data/file3.txt\n\n\nPas 2: Crear snapshot\nlvcreate -L 1G -s -n snap_data /dev/vg_webapp/lv_data\n\n\nPas 3: Muntar snapshot\nmkdir /snaps\nmount /dev/vg_webapp/snap_data /snaps\ndiff -r /opt/webapp/data /snaps\n\n\nPas 4: Modificar dades originals i comparar\ndd if=/dev/zero of=/opt/webapp/data/file3.txt bs=1M count=100\ndiff -r /opt/webapp/data /snaps\n\n\n\n\n\n\nAlerta💡 Reflexió: Mida snapshot\n\n\n\nQuè passa amb la mida de l’snapshot quan s’escriuen noves dades?\n\n\n\n\nPas 5: Crear un segon snapshot i comprovar versions\nlvcreate -L 1G -s -n snap_data2 /dev/vg_webapp/lv_data\numount /snaps\nmount /dev/vg_webapp/snap_data2 /snaps\nls -li /opt/webapp/data /snaps/\n\n\n\n\n\n\nAlertaInodes\n\n\n\nEls fitxers inalterats comparteixen inode; els modificats tenen un inode nou.\n\n\n\n\n🧹 Neteja\numount /snaps\nlvremove /dev/vg_webapp/snap_data\nlvremove /dev/vg_webapp/snap_data2"
  },
  {
    "objectID": "exercises/03-fs/10-ex-week7.html#exercicis-addicionals",
    "href": "exercises/03-fs/10-ex-week7.html#exercicis-addicionals",
    "title": "Laboratori: Desplegament d’un servidor web amb LVM",
    "section": "Exercicis addicionals",
    "text": "Exercicis addicionals\n\nDescriu els passos per migrar un LV existent a un altre PV utilitzant pvmove. Quin avantatge té aquest procediment respecte a copiar fitxers manualment?\nConfigura un mirall de /opt/webapp/data utilitzant LVM. Realitza una prova simulant la fallada d’un disc i comprova que les dades es mantenen accessibles. Quines implicacions té sobre el rendiment?\nCerca informació sobre l’eina fio i realitza un experiment per avaluar el rendiment d’un volum striped. Representa una gràfica amb els resultats per diferents valors de --stripe-size (64K, 128K, 256K, 512K, 1M, 2M). Interpreta la relació entre mida de bloc i rendiment."
  },
  {
    "objectID": "exercises/03-fs/08-ex-week5.html",
    "href": "exercises/03-fs/08-ex-week5.html",
    "title": "Administració bàsica de Sistemes de Fitxers",
    "section": "",
    "text": "Crear particions i sistemes de fitxers (ext4, xfs).\nMigrar directoris reals a particions separades amb coherència i sense pèrdua de dades.\nConfigurar el muntatge automàtic amb UUID i opcions de seguretat (nodev, nosuid, noexec).\nDiagnosticar i recuperar problemes reals: saturació d’espai i corrupció de sistema de fitxers.\nEines: fdisk, mkfs.*, tune2fs, mount, rsync, xfs_repair, hexedit."
  },
  {
    "objectID": "exercises/03-fs/08-ex-week5.html#objectius",
    "href": "exercises/03-fs/08-ex-week5.html#objectius",
    "title": "Administració bàsica de Sistemes de Fitxers",
    "section": "",
    "text": "Crear particions i sistemes de fitxers (ext4, xfs).\nMigrar directoris reals a particions separades amb coherència i sense pèrdua de dades.\nConfigurar el muntatge automàtic amb UUID i opcions de seguretat (nodev, nosuid, noexec).\nDiagnosticar i recuperar problemes reals: saturació d’espai i corrupció de sistema de fitxers.\nEines: fdisk, mkfs.*, tune2fs, mount, rsync, xfs_repair, hexedit."
  },
  {
    "objectID": "exercises/03-fs/08-ex-week5.html#requeriments-previs",
    "href": "exercises/03-fs/08-ex-week5.html#requeriments-previs",
    "title": "Administració bàsica de Sistemes de Fitxers",
    "section": "Requeriments previs",
    "text": "Requeriments previs\n\nTenir una màquina virtual (MV) amb Debian instal·lat.\nCrear un disc dur virtual addicional de 10GB del tipus SATA o NVMe.\nInstal·lar els paquets xfsprogs, rsync, hexedit i build-essential:\napt update -y && apt install xfsprogs rsync hexedit build-essential -y\nTotes les comandes s’han d’executar amb permisos de superusuari (root). Per tant, su -.\nCompte amb el nom del disc dur addicional, en aquest cas /dev/nvme0n2, però pot variar en funció de la configuració de la màquina virtual, utilitza la comanda lsblk per a identificar el disc dur addicional. Utilitza el nom correcte actualitzant-lo en les comandes que apareixen en aquest exercici."
  },
  {
    "objectID": "exercises/03-fs/08-ex-week5.html#particions-i-sistemes-de-fitxers",
    "href": "exercises/03-fs/08-ex-week5.html#particions-i-sistemes-de-fitxers",
    "title": "Administració bàsica de Sistemes de Fitxers",
    "section": "Particions i Sistemes de Fitxers",
    "text": "Particions i Sistemes de Fitxers\n\nCrear Particions i Sistemes de Fitxers\nAssegurarem que el disc dur addicional està detectat pel sistema. En aquest cas, el disc dur és /dev/nvme0n2, però pot variar en funció de la configuració de la màquina virtual, utilitza la comanda lsblk per a identificar el disc dur addicional.\nUtilitzarem la comanda fdisk per a crear tres noves particions en el disc dur.\n\nLa primera partició serà per a /var amb el sistema de fitxers ext4, etiqueta var mida 4GB.\nLa segona partició serà per a /tmp amb el sistema de fitxers xfs, sense etiqueta i mida 2GB.\nLa tercera partició serà per a /opt amb el sistema de fitxers ext4, etiqueta opt mida 3GB.\nLa quarta partició serà /home amb el sistema de fitxers ext4, etiqueta home i la resta d’espai disponible (1GB).\n\nCrearem les noves particions en el disc dur. Podeu utilzar una pipeline per a automatitzar la creació de les particions.\necho -e \"n\\np\\n\\n\\n+4G\\nn\\np\\n\\n\\n+2G\\nn\\np\\n\\n\\n+3G\\nn\\np\\n\\n\\n+1G\\nw\" | fdisk /dev/nvme0n2\nEl següent pas és crear els sistemes de fitxers en les particions que acabem de crear i assignar les etiquetes corresponents.\nmkfs.ext4 /dev/nvme0n2p1\ntune2fs -L \"var\" /dev/nvme0n2p1\nmkfs.xfs /dev/nvme0n2p2\nmkfs.ext4 /dev/nvme0n2p3\ntune2fs -L \"opt\" /dev/nvme0n2p3\nmkfs.xfs /dev/nvme0n2p4\ntune2fs -L \"home\" /dev/nvme0n2p4\nMonteu les particions en directoris temporals per a migrar les dades, per a això, creeu els directoris /mnt/var, /mnt/tmp , /mnt/opt i /mnt/home.\nmkdir /mnt/var /mnt/tmp /mnt/opt /mnt/home\nmount /dev/nvme0n2p1 /mnt/var\nmount /dev/nvme0n2p3 /mnt/opt\nmount /dev/nvme0n2p4 /mnt/home\n\n\n\n\n\n\nNota/tmp\n\n\n\nLa partició /tmp és temporal i no conté dades importants, per tant, no la muntarem en aquest pas, ja que no necessitem migrar cap dada. Les seves dades es perdran en el reinici del sistema.\n\n\n\n\nMigrar Directoris a les Noves Particions\nAbans de migrar les dades, és important assegurar-se que no hi ha processos que estiguin utilitzant els directoris que volem migrar. Per a això, podem utilitzar la comanda lsof per a llistar els fitxers oberts en aquests directoris.\nlsof +D /var\nlsof +D /opt\nlsof +D /home\n\n\n\n\n\n\nNotaFitxers oberts\n\n\n\nSi hi ha processos que estan utilitzant els directoris que volem migrar, és recomanable aturar aquests processos abans de continuar amb la migració. Això és especialment important per al directori /var, ja que conté fitxers de registre i altres dades que poden ser utilitzades per diversos serveis del sistema.\n\n\nHi ha moltes comandes per a migrar dades entre directoris, però en aquest cas utilitzarem la comanda rsync ja que ens permet mostrar el progrés de la còpia i també ens permet reprendre la còpia en cas que es talli la connexió o hi hagi un error. A més, també ens permet excloure directoris o fitxers que no volem migrar i ens permet fer còpies incrementals.\nrsync -av /var/ /mnt/var\nrsync -av /opt/ /mnt/opt\nrsync -av /home/ /mnt/home\n\n\n\n\n\n\nNotarsync\n\n\n\nrsync és una eina molt potent per a la sincronització de fitxers i directoris. En aquest cas, utilitzem les opcions -a (mode arxiu) i -v (verbose) per a conservar els permisos, propietaris, marques de temps i per a mostrar el progrés de la còpia. La barra inclinada (/) al final dels directoris d’origen és important perquè indica a rsync que només volem copiar el contingut del directori i no el directori en si mateix. Si no posem la barra inclinada, rsync crearà un subdirectori amb el mateix nom que el directori d’origen dins del directori de destinació. Per a més informació sobre rsync, podeu consultar la documentació (man rsync).\n\n\nUn cop copiem les dades, és important verificar que les dades s’han copiat correctament. Per a això, podem utilitzar la comanda diff per a comparar els directoris d’origen i destinació.\ndiff -r /var /mnt/var\ndiff -r /opt /mnt/opt\ndiff -r /home /mnt/home\nSi la comanda diff no mostra cap sortida, significa que els directoris són idèntics i que les dades s’han copiat correctament. Si hi ha diferències, la comanda diff mostrarà les línies que són diferents entre els dos directoris.\nMuntarem les noves particions en els directoris corresponents.\nmount /dev/nvme0n2p1 /var\nmount /dev/nvme0n2p3 /opt\nmount /dev/nvme0n2p4 /home\nUtiltiza la comanda df per a comprovar que les particions s’han muntat correctament o lsblk per a veure totes les particions i els seus punts de muntatge.\n\n\nConfigurar el Muntatge Automàtic\nSi ara reinicieu el sistema reboot, les particions no estaran muntades automàticament. Per a que les particions es muntin automàticament en l’arrencada del sistema, hem d’editar el fitxer /etc/fstab i afegir les noves particions amb els seus punts de muntatge corresponents.\necho \"/dev/nvme0n2p1 /var ext4 defaults 0 0\" &gt;&gt; /etc/fstab\necho \"/dev/nvme0n2p2 /tmp xfs defaults 0 0\" &gt;&gt; /etc/fstab\necho \"/dev/nvme0n2p3 /opt ext4 defaults 0 0\" &gt;&gt; /etc/fstab\necho \"/dev/nvme0n2p4 /home xfs defaults 0 0\" &gt;&gt; /etc/fstab\n\n\n\n\n\n\nNota/etc/fstab\n\n\n\nEl fitxer /etc/fstab conté la informació de les particions que es muntaran automàticament en l’arrencada del sistema. Cada línia del fitxer conté la informació d’una partició. Els camps de cada línia són: dispositiu, punt de muntatge, sistema de fitxers, opcions, freqüència de comprovació i ordre de comprovació. Podeu consultar la documentació del fitxer per a més informació (man fstab).\n\n\nPots provar la configuració del fitxer /etc/fstab sense reiniciar el sistema amb la comanda mount -a. Aquesta comanda muntarà totes les particions que estan definides en el fitxer /etc/fstab. També podem fer un reboot per a comprovar que les particions es muntin automàticament en l’arrencada del sistema, sempre hi quan la comanda mount -a no hagi donat cap error.\nEn aquest punt podriam optimitzar la configuració particions per a millorar el rendiment del sistema.\n\nUtiltizarem els UUIDs en lloc dels dispositius per a muntar les particions. Això ens permetrà identificar les particions de forma unívoca i evitar problemes en cas que els dispositius canviïn d’identificador. Per fer-ho podem utilitzar la comanda sed per actualitzar el fitxer /etc/fstab.\nsed -i \"s|/dev/nvme0n2p1|UUID=$(blkid -s UUID -o value /dev/nvme0n2p1)|\" /etc/fstab\nsed -i \"s|/dev/nvme0n2p2|UUID=$(blkid -s UUID -o value /dev/nvme0n2p2)|\" /etc/fstab\nsed -i \"s|/dev/nvme0n2p3|UUID=$(blkid -s UUID -o value /dev/nvme0n2p3)|\" /etc/fstab\nsed -i \"s|/dev/nvme0n2p4|UUID=$(blkid -s UUID -o value /dev/nvme0n2p4)|\" /etc/fstab\n\n🔍 Pregunta: En quins casos poden canviar els dispositius o tenir duplicats?\nEls dispositius poden canviar d’identificador en cas que es connectin més dispositius al sistema o es canvii l’ordre de connexió dels dispositius. Això pot provocar que les particions es muntin en llocs diferents dels esperats. Per a evitar aquest problema, és recomanable utilitzar els UUIDs en lloc dels dispositius per a muntar les particions.\n\nUtilitzarem opcions més específiques per protegir la partició /tmp per a evitar que s’executin programes des de la partició. Utilitzant les opcions nodev, nosuid, i noexec:\n\nEdita el fitxer /etc/fstab i afegeix les opcions nodev, nosuid, i noexec a la partició /tmp.\n\n\n\n\n\n\n\n\nNotaOpcions de Muntatge\n\n\n\nLa opció defaults és una col·lecció d’opcions que s’utilitzen per defecte en la majoria de sistemes de fitxers. Aquestes opcions inclouen rw (lectura i escriptura), suid (permet l’ús de l’atribut suid), és a dir, evita que es puguin exectuar programaes amb permisos de superusuari, dev (permet l’ús de dispositius), exec (permet l’execució de fitxers binaris), auto (muntatge automàtic en l’arrencada del sistema), nouser (només l’usuari root pot muntar la partició) i async (permet l’escriptura asíncrona).\n\n\n\nComprova les opcions després d’editar el fitxer /etc/fstab.\n\nmount | grep /tmp\n\nPer aplicar les opcions de muntatge a la partició /tmp, farem un reboot del sistema.\nTestem les opcions de muntatge de la partició /tmp:\n\nProva d’executar un programa des de la partició /tmp com a usuari no privilegiat.\n\necho \"echo 'Hello, World'\" &gt; /tmp/hello.sh\nchmod +x /tmp/hello.sh\n/tmp/hello.sh\nbash /tmp/hello.sh\n\nProva de fer el mateix com a usuari privilegiat.\n\nsu -\n/tmp/hello.sh\nbash /tmp/hello.sh\n\n👁️ Observació:\nObserveu que la opció noexec impedeix la execució dels binaris però no ens protegeix contra l’execució de scripts de bash.\n\n\nProva d’accedir a un dispositiu creat a /tmp:\n\nInicialitza un dispositiu a /tmp utilitzant la comanda mknod.\n\nmknod /tmp/dispositiu c 1 3\n\n⚠️ Compte:\nLa comanda mknod única i exclusivament la poden fer els usuaris amb permisos de superusuari. Per tant, feu servir la comanda su per a canviar a l’usuari root abans de fer servir la comanda mknod.\n\n\nPer accedir al dispositiu, utilitza la comanda cat.\n\ncat /tmp/dispositiu\n\n👁️ Observació:\nFixeu-vos que quan intento accedir a un dispositiu al directori actual, no hi ha cap problema. Però quan intento accedir al dispositiu creat a /tmp, rebre un missatge d’error indicant que no es pot accedir al dispositiu. Això és degut a la opció nodev que impedeix l’accés a dispositius en la partició.\n\n\n\nPer veure, les implicacions de la opció nosuid, podem realitzar el següent experiment:\nPer fer-ho, crearem un executable amb c que ens indicarà l’identificador de l’usuari real i l’identificador de l’usuari efectiu. On l’usuari real és l’usuari que ha iniciat la sessió i l’usuari efectiu és l’usuari que executa el programa. Si un programa té el bit suid activat, l’usuari efectiu serà l’usuari propietari del programa i no l’usuari que l’ha executat.\n#include &lt;stdio.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;unistd.h&gt;\n\nint main() {\n    printf(\"Effective user ID: %d\\n\", geteuid());\n    printf(\"Real user ID: %d\\n\", getuid());\n    return 0;\n}\nCompilem el programa amb la comanda gcc.\ngcc -o /tmp/suid /tmp/suid.c\nDesactiva la opció nosuid i també la opció noexec per a la partició /tmp. Per fer-ho, utilitza l’usuari root per a editar el fitxer /etc/fstab.\nRemunta la partició /tmp.\nProva d’executar el programa com a usuari no privilegiat.\n/tmp/suid\nActiva la opció nosuid i torna a provar d’executar el programa.\n/tmp/suid\n\n\n👁️ Observació:\nFixeu-vos que quan la opció nosuid està activada, no es pot executar el programa amb permisos de superusuari. Això és important per a evitar que els usuaris no privilegiats puguin executar programes amb permisos de superusuari. Aquesta opció pot permetre escalar privilegis i comprometre la seguretat del sistema.\n\n\n\n🔍 Pregunta: Per què és important tenir els directoris /var, /tmp i /opt en particions diferents?\nLa raó principal per a tenir els directoris /var, /tmp i /opt en particions diferents és per a millorar el rendiment i la seguretat del sistema. El directori /var conté dades variables com ara logs, bases de dades, correu electrònic, etc. Si aquest directori es queda sense espai, el sistema podria fallar. El mateix raonament s’aplica al directori /tmp i /opt. Per això, és important tenir-los en particions separades per a evitar que el sistema falli. A més, tenir els directoris /var, /tmp i /opt en particions separades també millora la seguretat del sistema ja que si una partició falla, les altres particions seguiran funcionant.\n\nAnem a fer una simulació de com respon el sistema en cas de no tenir els directoris /var, /tmp i /opt en particions separades. Per a això, simularem que el directori /opt es va omplint fins a ocupar tot l’espai disponible en la partició principal del sistema.\n\nDesmuntem la partició /opt per a poder continuar amb l’exercici.\numount /opt\nCreeu un fitxer de 20GB al directori /opt:\ndd if=/dev/urandom of=/opt/fitxer bs=1M count=20480\nComprova l’estat del sistema.\ndf -h\n\n\n\nComprova l’estat del sistema\n\n\nIntenta instal·lar un paquet amb apt i comprova que el sistema falla.\napt install htop\n\n\n\nIntenta instal·lar un paquet amb apt i comprova que el sistema falla\n\n\nCom podeu veure, el sistema fallarà ja que no té espai suficient per a instal·lar el paquet. Això és un problema greu ja que el sistema no podrà funcionar correctament fins que no alliberem espai en la partició principal.\nElimina el fitxer que has creat per a poder continuar amb la resta de l’exercici.\nrm /opt/fitxer\nMunteu la partició /opt i torneu a crear el fitxer per a omplir el directori.\nmount /dev/nvme0n2p3 /opt\ndd if=/dev/urandom of=/opt/fitxer bs=1M count=20480\nAra únicament teniu la partició /opt plena; però el sistema pot continuar fent tasques:\napt install htop"
  },
  {
    "objectID": "exercises/03-fs/08-ex-week5.html#simulant-una-corrupció-a-home",
    "href": "exercises/03-fs/08-ex-week5.html#simulant-una-corrupció-a-home",
    "title": "Administració bàsica de Sistemes de Fitxers",
    "section": "Simulant una corrupció a /home",
    "text": "Simulant una corrupció a /home\nEn aquest escenari simularem que hem patit una corrupció a la partició /home i quines eines podem utiltzar per intentar recuperar les dades. Bàsicament editarem alguns bits de la partició /home amb un editor hexadecimal per a simular la corrupció i després utilitzarem l’eina xfs_repair per a intentar recuperar les dades.\nEl primer pas que farem serà migrar el directori /home a una partició diferent per a poder simular la corrupció. A continuació, simularem la corrupció i finalment recuperarem les dades.\nAra podem crear fitxers i directoris al directori /home del vostre usuari normal, en el meu cas jordi.\nmkdir codi\nmkdir dades\ntouch dades/pokemon.csv\ntouch codi/main.c\ntouch codi/Makefile\ntouch codi/README.md\ntouch .vim\nPer a simular una corrupció editarem alguns valors de la partició /home amb un editor hexadecimal.\n\nDesmuntem la partició /home.\numount /home\n\nCompte!: Si esteu connectats per SSH, no podreu desmuntar la partició /home ja que el vostre usuari està utilitzant aquesta partició. En la primera sessió. Per tant, haure de fer-ho a la consola de la màquina virtual.\n\nObrirem la partició /home amb un editor hexadecimal:\n\nhexedit /dev/nvme0n2p4 \n\nModifiqueu bits a l’atzar i deseu els canvis. Per fer-ho escriviu damunt dels valors hexadecimals altres valors. Un cop fet guardeu amb Ctrl + X i Y.\nAra intentarem muntar la partició /home per a comprovar que ha estat corrompuda.\n\nmount /home\nSi la partició /home s’ha corromput, hauríeu de veure un missatge d’error com aquest:\n\nEls diferents sistemes de fitxers tenen eines per a comprovar la integritat dels fitxers. Per exemple, el sistema de fitxers xfs té l’eina xfs_ncheck que permet comprovar la integritat dels fitxers.\nxfs_ncheck /dev/nvme0n2p4\nPer a reparar la partició /home utilitzarem l’eina xfs_repair.\nxfs_repair /dev/nvme0n2p4\nUn cop reparada la partició /home, la muntarem de nou.\nmount /home\nComprovarem que la partició /home s’ha muntat correctament i conté els fitxers que havíem creat.\nls /home"
  },
  {
    "objectID": "exercises/01-foundations-of-systems-administration/02-ex-week1.html",
    "href": "exercises/01-foundations-of-systems-administration/02-ex-week1.html",
    "title": "Emulació en mode d’usuari amb QEMU",
    "section": "",
    "text": "Aquest exercici t’introduirà a l’emulació en mode d’usuari de QEMU, una eina que et permet executar un programa compilat per a una arquitectura de CPU diferent de la teva màquina. Concretament, executaràs un programa de 32 bits compilat per a ARM en un sistema x86 (processadors Intel o AMD) o ARM de 64 bits (processadors Apple M). Per simplificar l’exercici, utiltizarem un Hello, World! com a programa d’exemple."
  },
  {
    "objectID": "exercises/01-foundations-of-systems-administration/02-ex-week1.html#requeriments-previs",
    "href": "exercises/01-foundations-of-systems-administration/02-ex-week1.html#requeriments-previs",
    "title": "Emulació en mode d’usuari amb QEMU",
    "section": "Requeriments previs",
    "text": "Requeriments previs\n\nDisposar d’una màquina virtual amb Debian configurada segons les instruccions de l’exercici de configuració d’entorn de virtualització.\nDisposar de les eines bàsiques de desenvolupament instal·lades a la màquina virtual (compilador gcc, make, etc.). Pots instal·lar-les com a root amb la comanda següent: apt install build-essential."
  },
  {
    "objectID": "exercises/01-foundations-of-systems-administration/02-ex-week1.html#objectius",
    "href": "exercises/01-foundations-of-systems-administration/02-ex-week1.html#objectius",
    "title": "Emulació en mode d’usuari amb QEMU",
    "section": "Objectius",
    "text": "Objectius\n\nIntroduir-se en l’ús de QEMU en mode d’usuari per a l’emulació d’aplicacions.\nComprendre la diferència entre compilació nativa i compilació creuada.\nCompilar i executar un programa senzill per a una arquitectura diferent de la teva màquina."
  },
  {
    "objectID": "exercises/01-foundations-of-systems-administration/02-ex-week1.html#tasques",
    "href": "exercises/01-foundations-of-systems-administration/02-ex-week1.html#tasques",
    "title": "Emulació en mode d’usuari amb QEMU",
    "section": "Tasques",
    "text": "Tasques\n\nEscriure i compilar un programa Hello World per a ARM\n\nCrea un fitxer anomenat hello.c amb el següent contingut:\n\n#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"Hello, World!\\n\");\n    return 0;\n}\nPer compilar-lo per a l’arquitectura ARM, necessites un compilador creuat. En aquest laboratori, utilitzarem el GNU ARM toolchain per a Linux. Instal·la’l amb la següent comanda:\n# Com a root\napt install gcc-arm-linux-gnueabi\nAra, compila el programa per a ARM amb aquesta comanda:\n# Com a usuari normal\narm-linux-gnueabi-gcc -o helloarm -static hello.c\nAixò generarà un executable anomenat helloarm. La bandera -static crea un binari estàticament enllaçat, la qual cosa significa que totes les biblioteques necessàries s’inclouen dins del propi fitxer.\nSi intentes executar helloarm directament, rebràs un error:\n./helloarm\n-bash: ./helloarm: no es pot executar el fitxer binari: Error de format d'execució\nAquest error es produeix perquè el teu sistema operatiu no reconeix l’arquitectura del fitxer. Pots verificar-ho amb la comanda file:\nfile helloarm\nhelloarm: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, not stripped\n\n\nCompilació per a l’arquitectura de la teva MV\nPer entendre la diferència, ara compila el mateix codi per a l’arquitectura de la teva màquina amb gcc:\ngcc -o hellohost hello.c\nSi l’executes, funcionarà sense problemes:\n./hellohost\nHello, World!\nPer comprovar-ne l’arquitectura, utilitza de nou la comanda file:\nfile hellohost\n# Exemple per a x86\nhellohost: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked...\n# Exemple per a Apple M Series (ARM 64-bit)\nhellohost: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked...\n\n\nExecució del programa amb QEMU\nFinalment, per executar el binari ARM a la teva màquina, necessites el component de QEMU per a emulació en mode d’usuari. Instal·la’l amb aquesta comanda:\n# Com a root\napt install qemu-user\nUn cop instal·lat, pots executar el programa helloarm amb l’emulador qemu-arm:\nqemu-arm helloarm\nHello, World!\n\n\nPreguntes finals\n\nInvestiga quines altres arquitectures són compatibles amb QEMU en mode d’usuari. Prova de compilar i executar un programa per a una d’aquestes arquitectures.\nPer què la compilació estàtica és important en aquest context? Per què no cal incloure la bandera -static en la compilació normal? Quines avantatges i inconvenients té cada enfocament?"
  },
  {
    "objectID": "exercises/02-booting/05-ex-week3.html",
    "href": "exercises/02-booting/05-ex-week3.html",
    "title": "Desxifrat automàtic mitjançant clau en disc secundari (USB emulat)",
    "section": "",
    "text": "Aprendre a personalitzar la initramfs per buscar una clau en un disc secundari (emulant un USB).\nDesxifrar automàticament una partició LUKS durant l’arrencada amb una keyfile.\nEntendre els hooks i scripts d’initramfs-tools i com incloure binaris (cryptsetup) a la imatge."
  },
  {
    "objectID": "exercises/02-booting/05-ex-week3.html#objectius",
    "href": "exercises/02-booting/05-ex-week3.html#objectius",
    "title": "Desxifrat automàtic mitjançant clau en disc secundari (USB emulat)",
    "section": "",
    "text": "Aprendre a personalitzar la initramfs per buscar una clau en un disc secundari (emulant un USB).\nDesxifrar automàticament una partició LUKS durant l’arrencada amb una keyfile.\nEntendre els hooks i scripts d’initramfs-tools i com incloure binaris (cryptsetup) a la imatge."
  },
  {
    "objectID": "exercises/02-booting/05-ex-week3.html#requeriments-previs",
    "href": "exercises/02-booting/05-ex-week3.html#requeriments-previs",
    "title": "Desxifrat automàtic mitjançant clau en disc secundari (USB emulat)",
    "section": "Requeriments Previs",
    "text": "Requeriments Previs\n\nTenir una màquina virtual (MV) amb Debian instal·lat, aquesta màquina virtual s’ha d’haver creat seleccionat l’opció de LVM xifrat durant la instal·lació.\nAfegeix un disc secundari a la màquina virtual que simularà un USB de 4GB i de tipus SATA.\nTotes les comandes s’han d’executar amb permisos de superusuari (root). Per tant, su -.\nRealitzar un apt update -y && apt upgrade -y per assegurar-se que el sistema està actualitzat.\nInstal·lar el paquet apt install parted vim -y per gestionar particions."
  },
  {
    "objectID": "exercises/02-booting/05-ex-week3.html#passos",
    "href": "exercises/02-booting/05-ex-week3.html#passos",
    "title": "Desxifrat automàtic mitjançant clau en disc secundari (USB emulat)",
    "section": "Passos",
    "text": "Passos\n\nCreació del disc secundari amb la clau\nPrimer, cal crear un disc secundari que simuli un USB. Això es pot fer afegint un nou disc a la màquina virtual. En aquest exemple, suposarem que el nou disc és /dev/sda. Si el teu disc és diferent, substitueix /dev/sda pel nom correcte. Per obtenir el nom del nou disc, pots utilitzar la comanda lsblk o df -h.\nparted --script /dev/sda mklabel msdos\nparted --script /dev/sda mkpart primary ext4 1MiB 100%\nmkfs.ext4 -L KEYDISK /dev/sda1\nAquestes comandes creen una taula de particions MBR i una partició primària que ocupa tot l’espai del disc, formatada amb el sistema de fitxers ext4 i amb l’etiqueta KEYDISK.\n\n\nMuntar el disc i crear la clau\nPrimer crearem un punt de muntatge i muntarem la partició del disc secundari. Després, generarem un fitxer de clau amb dades aleatòries i li assignarem permisos restrictius per garantir la seva seguretat.\nmkdir -p /tmp/keydisk\nmount /dev/sda1 /tmp/keydisk\ndd if=/dev/urandom of=/tmp/keydisk/keyfile.bin bs=4096 count=1\nchmod 0400 /tmp/keydisk/keyfile.bin\n\n\nAfegir la clau a la partició LUKS\nAfegirem el fitxer de clau a la partició LUKS que conté la partició arrel. En aquest exemple, suposarem que la partició LUKS és /dev/nvme0n1p3. Si el teu dispositiu és diferent, substitueix /dev/nvme0n1p3 pel nom correcte.\ncryptsetup luksDump /dev/nvme0n1p3\ncryptsetup luksAddKey /dev/nvme0n1p3 /tmp/keydisk/keyfile.bin\nEn aquest punt, se’t demanarà introduïr una passphrase existent per autoritzar l’afegiment de la nova clau, entra la passphrase i comprova que la clau s’ha afegit correctament amb:\ncryptsetup luksDump /dev/nvme0n1p3\nAra veuras una línia addicional a Key Slot. Indicant que la clau s’ha afegit correctament."
  },
  {
    "objectID": "exercises/02-booting/05-ex-week3.html#edita-el-fitxer-etccrypttab",
    "href": "exercises/02-booting/05-ex-week3.html#edita-el-fitxer-etccrypttab",
    "title": "Desxifrat automàtic mitjançant clau en disc secundari (USB emulat)",
    "section": "Edita el fitxer /etc/crypttab",
    "text": "Edita el fitxer /etc/crypttab\nAquest fitxer s’utilitza per definir les particions xifrades que s’han de desxifrar durant l’arrencada. Edita el fitxer /etc/crypttab i afegeix la a entre el UUID de la partició LUKS i les opcions, la ruta al fitxer de clau que hem creat anteriorment. Per fer-ho, elimineu none i afegiu la ruta al fitxer de clau.\n# /etc/crypttab\nnvme0n1p3_crypt UUID=XXXXXXXXX /tmp/keydisk/keyfile.bin  luks,discard\nIndicarem que la keyfile es troba a /tmp/keydisk/keyfile.bin, ja que en la initramfs muntarem el disc secundari a /tmp/keydisk i llegirem la clau des d’allà.\n\nCrear l’script per muntar el disc i llegir la clau\nCrearem un script que s’executarà durant l’arrencada per muntar el disc secundari, llegir la clau i desxifrar la partició LUKS. Aquest script es col·locarà a /etc/initramfs-tools/scripts/local-top/ i s’anomenarà mount_disk.\n#!/bin/sh\n### BEGIN INIT INFO\n# Provides:          mount_disk\n# Required-Start:    $local_fs\n# Required-Stop:\n# Default-Start:     S\n# Default-Stop:\n# Short-Description: Unlock LUKS root using a keyfile on a secondary disk\n# Description:       Finds and mounts a secondary disk\n### END INIT INFO\n\nlog_msg() {\n    echo \"mount_disk: $1\" &gt; /dev/kmsg\n}\n\nKEYDISK_UUID=\"XXXXXX\" # &lt;-- Substitueix amb el teu UUID corresponent al disc secundari\nKEYFILE_PATH=\"/keyfile.bin\"\n\nlog_msg \"Iniciant desxifrat automàtic amb keyfile.\"\n\nMNT_POINT=\"/tmp/keydisk\"\nmkdir -p \"$MNT_POINT\"\n\nDEV=$(blkid -U \"$KEYDISK_UUID\")\nif [ -n \"$DEV\" ]; then\n    log_msg \"Dispositiu trobat a $DEV. Muntant...\"\n    mount -t ext4 \"$DEV\" \"$MNT_POINT\"\n    if [ $? -ne 0 ]; then\n        log_msg \"ERROR: No s'ha pogut muntar $DEV.\"\n        exit 0\n    fi\nelse\n    log_msg \"ERROR: No s'ha trobat cap dispositiu amb l'UUID especificat.\"\n    exit 0\nfi\n\n# Comprovar si el keyfile existeix\nif [ -f \"$MNT_POINT/$KEYFILE_PATH\" ]; then\n    log_msg \"Keyfile trobat. Desxifrant LUKS...\"\nelse\n    log_msg \"ERROR: No s'ha trobat el keyfile.\"\nfi\n\nexit 0\nGuarda aquest script com a /etc/initramfs-tools/scripts/local-top/mount_disk i fes-lo executable:\nchmod +x /etc/initramfs-tools/scripts/local-top/mount_disk\n\n\nConfiigurar cryptsetup per a la initramfs\ncryptsetup ja esta inclòs en la initramfs per defecte, però cal assegurar-se que està configurat per utilitzar el fitxer de clau des del disc secundari. Edita el fitxer /etc/cryptsetup-initramfs/conf-hook i afegeix la següent línia que permet que no es demani la contrasenya si es troba el fitxer de clau:\n#  /etc/cryptsetup-initramfs/conf-hook\nASKPASS=n\n\n\nIncloure el fitxer /etc/crypttab a la initramfs\nPer assegurar que el fitxer /etc/crypttab es troba disponible durant l’arrencada, cal crear un script que el copiï a la initramfs. Crearem un script anomenat copy-crypttab a /etc/initramfs-tools/hooks/.\n#!/bin/sh\ncp /etc/crypttab \"${DESTDIR}/cryptroot/crypttab\"\nexit\nGuarda aquest script com a /etc/initramfs-tools/hooks/copy-crypttab i fes-lo executable:\nchmod +x /etc/initramfs-tools/hooks/copy-crypttab\n\n\nActualitzar la initramfs\nPerquè els canvis tinguin efecte, cal actualitzar la initramfs. Això es fa amb la comanda següent:\nupdate-initramfs -u -k $(uname -r)\n\n\nComprovar la inclusió de l’script i cryptsetup a la initramfs\nPer assegurar-te que l’script s’ha inclòs correctament a la initramfs i que cryptsetup també hi és, pots utilitzar les següents comandes:\nlsinitramfs /boot/initrd.img-$(uname -r) | grep mount_disk\nlsinitramfs /boot/initrd.img-$(uname -r) | grep cryptsetup\n\n\nProva l’arrencada\nReinicia la màquina virtual per provar l’arrencada. Si tot està configurat correctament, la partició LUKS s’hauria de desxifrar automàticament utilitzant la clau emmagatzemada al disc secundari. Sense demanar la contrasenya manualment.\nreboot\n\n\nConsultar el log d’arrencada\nDurant l’arrencada, el sistema registrarà missatges al kernel log. Pots consultar aquests missatges per verificar que l’script s’ha executat correctament i que la partició LUKS s’ha desxifrat. Utilitza la comanda següent per veure els missatges rellevants:\ndmesg | grep mount_disk"
  },
  {
    "objectID": "exercises/02-booting/03-ex-week2.html",
    "href": "exercises/02-booting/03-ex-week2.html",
    "title": "Arrancada UEFI",
    "section": "",
    "text": "Entendre com funciona la UEFI i la partició ESP.\nConfigurar una màquina virtual amb dual boot.\nPracticar la gestió de l’ordre d’arrencada i la creació d’entrades UEFI.\n\nAl final, hauries de poder seleccionar entre AlmaLinux i Debian a l’inici de la màquina virtual."
  },
  {
    "objectID": "exercises/02-booting/03-ex-week2.html#objectiu",
    "href": "exercises/02-booting/03-ex-week2.html#objectiu",
    "title": "Arrancada UEFI",
    "section": "",
    "text": "Entendre com funciona la UEFI i la partició ESP.\nConfigurar una màquina virtual amb dual boot.\nPracticar la gestió de l’ordre d’arrencada i la creació d’entrades UEFI.\n\nAl final, hauries de poder seleccionar entre AlmaLinux i Debian a l’inici de la màquina virtual."
  },
  {
    "objectID": "exercises/02-booting/03-ex-week2.html#preparació-de-les-màquines-virtuals",
    "href": "exercises/02-booting/03-ex-week2.html#preparació-de-les-màquines-virtuals",
    "title": "Arrancada UEFI",
    "section": "Preparació de les Màquines Virtuals",
    "text": "Preparació de les Màquines Virtuals\nEn primer lloc, heu de crear dues màquines virtuals amb UEFI com a firmware.\n\n\n\nNom\nOS\nDisc\nFirmware\n\n\n\n\nVM1-AlmaLinux\nAlmaLinux 9\n20 GB\nUEFI\n\n\nVM2-Debian\nDebian 12\n20 GB\nUEFI\n\n\n\n\n\n\n\n\n\nNotaNota\n\n\n\nAssegureu-vos que ambdues màquines virtuals tinguin UEFI com a firmware. En el moment de fer les particions, heu de veure que es crea una partició ESP (EFI System Partition) automàticament. Si no és així, pot ser que la màquina virtual no estigui configurada correctament per utilitzar UEFI. No continuïs fins que no tinguis aquesta partició.\n\n\n\n\n\n\n\n\nAlertaAdvertència\n\n\n\nSi VMWare no us deixa seleccionar UEFI com a firmware, un cop creada la màquina virtual amb BIOS, heu de modificar el fitxer .vmx de la màquina virtual i afegir al final les línies següents:\nfirmware = \"efi\"\nefi.secureBoot.enabled = \"FALSE\"\nGuarda els canvis i inicia la màquina virtual de nou, i instal·la el sistema operatiu."
  },
  {
    "objectID": "exercises/02-booting/03-ex-week2.html#migrar-el-disc-de-debian-a-la-màquina-virtual-dalmalinux",
    "href": "exercises/02-booting/03-ex-week2.html#migrar-el-disc-de-debian-a-la-màquina-virtual-dalmalinux",
    "title": "Arrancada UEFI",
    "section": "Migrar el disc de Debian a la màquina virtual d’AlmaLinux",
    "text": "Migrar el disc de Debian a la màquina virtual d’AlmaLinux\n\nApaga la màquina virtual de Debian si està en funcionament.\nLocalitza el fitxer de disc virtual de la màquina virtual de Debian. Aquest fitxer al programa VMware sol tenir l’extensió .vmdk.\nA la configuració de la màquina virtual d’AlmaLinux, aneu a l’opció de disc dur i afegiu un disc dur existent, seleccionant el disc dur de la màquina virtual de Debian que heu localitzat en el pas anterior.\nConfirmar els parametres i aplica els canvis.\n\n\nTest\nAssegureu-vos que la màquina virtual ara té dos discs durs: un amb AlmaLinux i un altre amb Debian utilitzant la comanda lsblk, hauria de mostrar-vos alguna cosa com això:\n[root@localhost ~]# lsblk\nNAME               MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS\nsr0                 11:0    1  1.7G  0 rom\nnvme0n1            259:0    0   20G  0 disk\n├─nvme0n1p1        259:1    0  600M  0 part /boot/efi\n├─nvme0n1p2        259:2    0    1G  0 part /boot\n└─nvme0n1p3        259:3    0 18.4G  0 part\n├─almalinux-root 253:0    0 16.4G  0 lvm  /\n└─almalinux-swap 253:1    0    2G  0 lvm  [SWAP]\nnvme0n2            259:4    0   20G  0 disk\n├─nvme0n2p1        259:5    0  512M  0 part\n├─nvme0n2p2        259:6    0 18.5G  0 part\n└─nvme0n2p3        259:7    0  976M  0 part\nOn nvme0n1 és el disc d’AlmaLinux i nvme0n2 és el disc de Debian. Es posible que el nom del disc no sigui nvme, pot ser sda, vda, etc. Depèn del tipus de disc que tinguis."
  },
  {
    "objectID": "exercises/02-booting/03-ex-week2.html#tasca",
    "href": "exercises/02-booting/03-ex-week2.html#tasca",
    "title": "Arrancada UEFI",
    "section": "Tasca",
    "text": "Tasca\nReinicia la màquina virtual d’AlmaLinux i entra a la UEFI (normalment prement F2 o Esc durant l’arrencada). La teva tasca es configurar la UEFI per afegir una entrada d’arrencada per a Debian. Has de poder arrancar tant AlmaLinux com Debian des del menú d’arrencada de la UEFI.\n\nEl primer pas és identificar com podem arrancar Debian.\nAnalitzeu la comanda bcfg amb help bcfg per veure com funciona.\n\n\n\n\n\n\n\nImportantNota\n\n\n\nLa comanda bcfg es troba disponible a partir de la versió 2.3 de UEFI Shell. Si la vostra màquina virtual utilitza una versió anterior, és possible que no tingueu aquesta comanda disponible. En aquest cas, haureu d’actualitzar el firmware UEFI de la vostra màquina virtual o utilitzar una altra eina per gestionar les entrades d’arrencada com efibootmgr des de Linux.\n\n\nEn cas de no poder accedir a la shell o no tenir disponible la comanda bcfg encara que es compleixi el requisit de la versió de UEFI Shell &gt;= 2.3, cal arrencar des d’un fitxer EFI Shell V2 més complet. Podeu descarregar-lo aquí.\nPer poder arrencar aquest fitxer des de VMware, l’hem d’escriure amb el format correcte a una imatge vmdk:\n\nEl primer pas és crear una imatge de disc buida on després escriurem l’arbre de directoris adequat per EFI així com el fitxer descarregat a arrencar.\ndd if=/dev/zero of=Shell.img bs=1M count=64\nAra utilitzem parted per crear una taula de particions GPT i una partició FAT32 marcada com a bootable.\nparted Shell.img --script mklabel gpt\nparted Shell.img --script mkpart ESP fat32 1MiB 100%\nparted Shell.img --script set 1 boot on\nPer poder treballar amb les particions dins del fitxer de disc, l’associem a un dispositiu loop.\nsudo losetup -Pf Shell.img\nFormatem la partició EFI amb FAT32, obligatori per a UEFI:\nsudo mkfs.vfat -F32 /dev/loop0p1\nMuntem la partició, creem l’arbre de directoris correcte i copiem el fitxer .efi amb el nom BOOTX64.EFI. Finalment, desmuntem la partició i desassociem el dispositiu loop.\nsudo mount /dev/loop0p1 /mnt\nsudo mkdir -p /mnt/EFI/BOOT\nsudo cp Shellx64.efi /mnt/EFI/BOOT/BOOTX64.EFI\nsudo umount /mnt\nsudo losetup -d /dev/loop0\nFinalment convertim la imatge RAW a VMDK perquè pugui ser utilitzada a VMware:\nqemu-img convert -f raw -O vmdk Shell.img Shell.vmdk\n\nPer usar aquest fitxer generat, afegiu un disc dur (Hard Disk) a la vostra màquina i obriu-lo.\n\n\n\n\n\n\nImportantNota\n\n\n\nEn cas de tenir un altre disc dur bootejable a la màquina virtual, per defecte no arrencarà des del de UEFI Shell. Per poder executar-ho, heu d’entrar a la UEFI (normalment prement F2 o Esc durant l’arrencada) i seleccionar el disc dur corresponent a la UEFI Shell.\n\n\nSi per alguna raó no podeu executar les comandes per crear un disc dur amb l’imatge de UEFI Shell, el podeu descarregar des d’aquí.\nA partir d’aquesta shell ja teniu disponible la comanda bcfg"
  },
  {
    "objectID": "exercises/02-booting/03-ex-week2.html#entrega",
    "href": "exercises/02-booting/03-ex-week2.html#entrega",
    "title": "Arrancada UEFI",
    "section": "Entrega",
    "text": "Entrega\nHas de presentar un document amb els següents punts:\n\nEls passos que has seguit per configurar la UEFI i afegir l’entrada d’arrencada per a Debian.\nFes una captura de pantalla del menú d’arrencada de la UEFI mostrant les dues entrades (AlmaLinux i Debian) i puja-la a l’aula virtual juntament amb una breu descripció dels passos que has seguit per aconseguir-ho."
  },
  {
    "objectID": "exercises/02-booting/07-ex-week4.html",
    "href": "exercises/02-booting/07-ex-week4.html",
    "title": "Servei de Còpia de Seguretat Automàtica amb systemd",
    "section": "",
    "text": "Aprendre a crear un servei bàsic amb systemd.\nConfigurar un servei que s’executi a l’inici del sistema.\nEntendre els fitxers d’unitat de systemd i com gestionar-los.\nCrear un script senzill per realitzar una còpia de seguretat de la carpeta /home i desar-lo a /backup."
  },
  {
    "objectID": "exercises/02-booting/07-ex-week4.html#objectius",
    "href": "exercises/02-booting/07-ex-week4.html#objectius",
    "title": "Servei de Còpia de Seguretat Automàtica amb systemd",
    "section": "",
    "text": "Aprendre a crear un servei bàsic amb systemd.\nConfigurar un servei que s’executi a l’inici del sistema.\nEntendre els fitxers d’unitat de systemd i com gestionar-los.\nCrear un script senzill per realitzar una còpia de seguretat de la carpeta /home i desar-lo a /backup."
  },
  {
    "objectID": "exercises/02-booting/07-ex-week4.html#requeriments-previs",
    "href": "exercises/02-booting/07-ex-week4.html#requeriments-previs",
    "title": "Servei de Còpia de Seguretat Automàtica amb systemd",
    "section": "Requeriments Previs",
    "text": "Requeriments Previs\n\nTenir una màquina virtual (MV) amb Debian instal·lat.\nTotes les comandes s’han d’executar amb permisos de superusuari (root). Per tant, su -.\nRealitzar un apt update -y && apt upgrade -y per assegurar-se que el sistema està actualitzat.\nInstal·lar el paquet vim per editar fitxers: apt install vim -y.\nCrear la carpeta /backup on es desaran les còpies de seguretat: mkdir -p /backup."
  },
  {
    "objectID": "exercises/02-booting/07-ex-week4.html#servei-bàsic-amb-systemd",
    "href": "exercises/02-booting/07-ex-week4.html#servei-bàsic-amb-systemd",
    "title": "Servei de Còpia de Seguretat Automàtica amb systemd",
    "section": "Servei bàsic amb systemd",
    "text": "Servei bàsic amb systemd\n\nCrearem un script que farà la còpia de seguretat de la carpeta /home, per fer-ho simplement crearem un arxiu .tar.gz amb la data i hora actual al nom de l’arxiu. Aquest arxiu es desarà a la carpeta /backup que hem creat anteriorment. El script es col·locarà a /usr/local/bin/backup.sh.\n#!/bin/bash\ntar -czf /backup/system_backup_$(date +%Y%m%d_%H%M%S).tar.gz /home\nConfigurarem un servei que faci una còpia de seguretat cada cop que s’iniciï el sistema. Crearem un fitxer de servei a /etc/systemd/system/backup.service.\n[Unit]\nDescription=Backup Service\nAfter=network.target\n\n[Service]\nType=oneshot\nExecStart=/usr/local/bin/backup.sh\n\n[Install]\nWantedBy=multi-user.target\n\n\n\n\n\n\n\nNota\n\n\n\nEl target multi-user.target s’utilitza perquè el servei s’executi quan el sistema està en mode multiusuari, és a dir, quan la majoria dels serveis del sistema ja estan en funcionament.\n\n\n\nActivarem el servei perquè s’executi a l’inici del sistema amb la comanda:\nsystemctl start backup.service\nComprova l’estat del servei amb:\nsystemctl status backup.service\n\n\n\n\n\n\n\nImportant\n\n\n\nEl servei no s’ha arrancat degut a errors en l’script. Revisa el fitxer de registre amb journalctl -xeu backup.service per veure els errors i corregir-los. On xeu indica que volem veure els missatges d’error i advertència filtrant per unitat. El error que observareu és que el script no té permisos d’execució. Per solucionar-ho, simplement afegiu permisos d’execució a l’script amb chmod +x /usr/local/bin/backup.sh i torneu a iniciar el servei amb systemctl restart backup.service.\n\n\n\nComprovarem el contigut de la carpeta /backup. Un cop el servei s’hagi executat correctament, hauríeu de veure un fitxer de còpia de seguretat amb la data actual al nom del fitxer.\nls -lh /backup\nActivarem el servei perquè s’executi a l’inici del sistema amb la comanda:\nsystemctl enable backup.service\nFinalment, reiniciarem el sistema per assegurar-nos que el servei s’executa correctament a l’inici:\nreboot\nDesprés de reiniciar, comprova que el fitxer de còpia de seguretat s’ha creat correctament a la carpeta /backup:\nls -lh /backup"
  },
  {
    "objectID": "exercises/02-booting/07-ex-week4.html#servei-amb-timer-amb-systemd",
    "href": "exercises/02-booting/07-ex-week4.html#servei-amb-timer-amb-systemd",
    "title": "Servei de Còpia de Seguretat Automàtica amb systemd",
    "section": "Servei amb Timer amb systemd",
    "text": "Servei amb Timer amb systemd\nEl servei que hem creat anteriorment s’executa només una vegada a l’inici del sistema. Ara crearem un servei que s’executi diàriament a una hora específica utilitzant un timer de systemd. El primer pas és crear el servei que volem executar periòdicament, en aquest cas, el mateix script de còpia de seguretat que hem creat abans. El segon pas és crear un fitxer de timer que programi l’execució del servei.\n\nCrearem un fitxer de timer a /etc/systemd/system/backup-daily.timer per programar l’execució del servei diàriament a les 2:00 AM.\n[Unit]\nDescription=Runs backup-daily.service daily at 2:00 AM\nRequires=backup-daily.service\n\n[Timer]\nOnCalendar=*-*-* 02:00:00\nPersistent=true\n\n[Install]\nWantedBy=timers.target\non el camp OnCalendar, *-*-* 02:00:00 indica que el servei s’executarà diàriament a les 2:00 AM. La línia Persistent=true assegura que si el sistema està apagat a l’hora programada, el servei s’executarà tan aviat com el sistema s’iniciï. El *-*-* és un comodí que representa qualsevol any, mes i dia.\nCrearem el fitxer de servei a /etc/systemd/system/backup-daily.service que serà el que s’executarà diàriament.\n[Unit]\nDescription=Daily Backup Service\n\n[Service]\nType=oneshot\nExecStart=/usr/local/bin/backup.sh\nActivarem el timer perquè s’executi diàriament amb la comanda:\nsystemctl enable --now backup-daily.timer\n\n\n\n\n\n\n\nImportant\n\n\n\nL’argument --now activa el timer immediatament després d’habilitar-lo, de manera que no cal reiniciar el sistema per començar a utilitzar-lo.\n\n\n\nComprova l’estat del timer amb:\nsystemctl status backup-daily.timer\nPer veure quan s’executarà el proper cop el servei, utilitza la comanda:\nsystemctl list-timers --all\nPer provar que el servei funciona correctament, pots forçar l’execució del servei amb la comanda:\nsystemctl start backup-daily.service"
  },
  {
    "objectID": "exercises/02-booting/07-ex-week4.html#exercicis-proposats",
    "href": "exercises/02-booting/07-ex-week4.html#exercicis-proposats",
    "title": "Servei de Còpia de Seguretat Automàtica amb systemd",
    "section": "Exercicis Proposats",
    "text": "Exercicis Proposats\n\nModifica el servei perquè faci una còpia de seguretat de la carpeta /var i /etc en lloc de /home. Un cop fet això, utilitza systemd-analyze i systemd-analyze blame per analitzar el servei abans i després d’activar-lo. Comenta i justifica els resultats obtinguts.\nCrea un servei que permeti actualitzar el sistema automàticament cada diumenge a les 3:00 AM. Aquest servei hauria d’executar apt update && apt upgrade -y."
  },
  {
    "objectID": "exercises/02-booting/01-ex-week2.html",
    "href": "exercises/02-booting/01-ex-week2.html",
    "title": "Booting amb MBR i BIOS",
    "section": "",
    "text": "Entendre com funciona el procés d’arrencada amb BIOS i MBR.\nCrear un bootloader senzill de primera i segona etapa.\nPracticar l’ús de QEMU per emular una màquina amb BIOS."
  },
  {
    "objectID": "exercises/02-booting/01-ex-week2.html#objectiu",
    "href": "exercises/02-booting/01-ex-week2.html#objectiu",
    "title": "Booting amb MBR i BIOS",
    "section": "",
    "text": "Entendre com funciona el procés d’arrencada amb BIOS i MBR.\nCrear un bootloader senzill de primera i segona etapa.\nPracticar l’ús de QEMU per emular una màquina amb BIOS."
  },
  {
    "objectID": "exercises/02-booting/01-ex-week2.html#requisits-previs",
    "href": "exercises/02-booting/01-ex-week2.html#requisits-previs",
    "title": "Booting amb MBR i BIOS",
    "section": "Requisits previs",
    "text": "Requisits previs\n\nUna màquina virtual amb Debian i accés a la terminal.\n\n\nPart 1: El Bootloader de Primera Etapa (MBR)\nL’objectiu d’aquesta part és crear un disc virtual amb un MBR que la BIOS pugui reconèixer i executar, mostrant un missatge de benvinguda.\n\nCreació de la imatge del disc\nCrearem un fitxer de 10 MiB que servirà com a disc dur virtual. Utilitzarem la comanda dd:\ndd if=/dev/zero of=disk.img bs=512 count=20480\nObserveu que bs=512 estableix la mida del bloc a 512 bytes, i count=20480 indica que volem 20480 blocs, resultant en un fitxer de 10 MiB (512 bytes * 20480 blocs = 10 MiB). A més, aquest fitxer estarà inicialitzat amb zeros (if=/dev/zero) i es crearà amb el nom disk.img.\n\n\n\n\n\n\nNotaRecordatori\n\n\n\nMBR significa Master Boot Record i ocupa els primers 512 bytes del disc.\n\n\n\n\nBootloader de primera etapa\nEl bootloader de primera etapa és un petit programa que s’executa quan la BIOS carrega el MBR. Aquest programa ha de ser molt petit, ja que només té 512 bytes per treballar. En aquest exercici, escriurem un bootloader senzill en llenguatge d’assemblador que mostrarà un missatge de benvinguda.\nCrea un fitxer anomenat boot.asm amb el següent contingut:\n[org 0x7c00]      ; L'adreça on la BIOS carrega el nostre codi\n\njmp short start   ; Salt a la rutina principal per evitar que la BIOS executi la taula de particions\nnop               ; \n\nstart:\n    ; Configurem els registres del segment\n    xor ax, ax      ; Posa AX a 0\n    mov ds, ax      ; Configurem DS (segment de dades) a 0\n    mov es, ax      ; Configurem ES (segment extra) a 0\n    mov ss, ax      ; Configurem SS (segment de pila) a 0\n    mov sp, 0x7c00  ; Configurem el punter de pila\n\n    ; Imprimir el missatge de benvinguda\n    mov si, msg     ; Carreguem l'adreça del missatge a SI\n.print_loop:\n    lodsb           ; Carreguem un byte des de [DS:SI] a AL, i incrementem SI\n    cmp al, 0       ; Comparem AL amb zero\n    je .done_print  ; Si AL és zero, hem arribat al final del missatge\n    mov ah, 0x0e    ; Funció BIOS per a l'escriptura en mode teletip\n    int 0x10        ; Crida a la interrupció de vídeo\n    jmp .print_loop\n.done_print:\n\n    ; Bucle infinit per aturar l'execució\n    cli             ; Deshabilitem les interrupcions\n.halt:\n    hlt             ; Aturem la CPU\n    jmp .halt       ; Saltem a nosaltres mateixos en cas de despertar-nos d'un HLT\n\nmsg db \"Hola, soc l'MBR. La primera etapa d'arrencada ha funcionat!\", 0\n\n; Omplim la resta del sector amb zeros\ntimes 510 - ($-$$) db 0\n\n; La signatura MBR\ndw 0xaa55\nLa primera línia [org 0x7c00] indica a l’assemblador que el codi s’ha de considerar com si s’executés a l’adreça 0x7C00, que és on la BIOS carrega el sector MBR a la memòria.\nAbans de l’execució del nostre codi, els registres de segment de la CPU (DS, ES, SS) poden contenir valors aleatoris. Per garantir que les adreces de memòria siguin interpretades correctament en mode real, els inicialitzem a zero amb les instruccions mov ds, ax, mov es, ax i mov ss, ax.\nLa instrucció mov sp, 0x7c00 estableix el punter de pila (SP) a la mateixa adreça on s’ha carregat el MBR, evitant que la pila sobrescrigui el codi. En bootloaders més complexos, això permetria utilitzar instruccions com CALL, PUSH i POP sense problemes.\nLa rutina de bucle llegeix cada caràcter de la cadena de text i el mostra a la pantalla mitjançant la interrupció BIOS 0x10, funció teletip (AH=0x0E). Un cop s’ha imprès tot el missatge, s’utilitza la instrucció HLT dins d’un bucle infinit per aturar la CPU. Això evita que la CPU continuï executant dades no definides més enllà del sector MBR, cosa que podria provocar comportaments inesperats.\n\n\nEnsamblar i escriure el bootloader al disc\nUtilitzarem nasm per ensamblar el nostre codi i dd per escriure’l al disc virtual:\n# Instal·lar nasm si no el tens\nsu -c \"apt install nasm -y\"\n# Ensamblar el codi\nnasm -f bin -o boot.bin boot.asm\nOn -f bin indica que volem un fitxer binari pla, i -o boot.bin especifica el nom del fitxer de sortida.\n\n\n\n\n\n\nImportantProblemes\n\n\n\nSi la comanda d’instalació de qemu no acaba correctament, heu de fer un su -c \"apt update\" i problablement també un su -c \"apt upgrade -y\" abans de tornar a intentar instal·lar qemu.\n\n\nAra, escrivim el bootloader al disc virtual:\ndd if=boot.bin of=disk.img bs=512 count=1 conv=notrunc\nOn conv=notrunc assegura que no truncarem el fitxer de sortida, mantenint la resta del disc intacta.\nPer comprovar que el bootloader s’ha escrit correctament, podem utilitzar hexdump:\nhexdump -C -n 512 disk.img | sed -n '1,16p'\non -n 512 limita la sortida als primers 512 bytes (el sector MBR) i sed -n '1,16p' mostra només les primeres 16 línies de la sortida.\nTambé podem comprovar la signatura MBR (els últims dos bytes del sector) amb:\nhexdump -C -s 510 -n 2 disk.img\nHaurias de veure 55 aa, el 00000200 indica l’offset.\n\n\nExecutar la imatge del disc amb QEMU\nFinalment, podem executar la nostra imatge de disc amb QEMU per veure el nostre missatge de benvinguda:\n# Instal·lar QEMU si no el tens\nsu -c \"apt install qemu-system-x86 -y\"\n# Executar la imatge del disc\nqemu-system-x86_64 -drive file=disk.img,format=raw -nographic\n\n\n\n\n\n\nNotaNota\n\n\n\nLa nostra màquina virtual és mode text (-nographic), així que hauries de veure el missatge de benvinguda a la terminal. Si teniu una interfície gràfica, podeu ometre -nographic per veure la sortida en una finestra de QEMU.\n\n\nEnhorabona! Acabes de crear i executar un bootloader de primera etapa senzill que mostra un missatge de benvinguda. Aquest és el primer pas per entendre com funciona el procés d’arrencada d’un sistema operatiu.\n\n\n\n\n\n\nConsellSortir de QEMU\n\n\n\n\nPer sortir de QEMU, utilitza la combinació de tecles Ctrl + A, seguida de X.\nAlternativament, pots Ctrl + C a la terminal per anar a la línia de comandes de QEMU i després escriure quit per sortir.\n\n\n\n\n\n\nPart 2: El Bootloader de Segona\nEn aquest punt, ja tenim el nostre bootloader de primera etapa, però la seva funció principal és passar el control a un programa més gran. Aquest serà el nostre bootloader de segona etapa. Per fer-ho, el MBR ha de llegir un sector del disc i carregar-lo a la memòria. Normalment, el MBR analitzaria la taula de particions per trobar on comença el següent bootloader. No obstant això, per a aquest exercici, simplificarem aquest procés i codificarem directament l’adreça del nostre bootloader de segona etapa al codi.\nLa interrupció int 0x13h de la BIOS és la responsable de les operacions d’entrada/sortida de disc i requereix un paquet d’adreces de disc (DAP) per funcionar. Aquest DAP és una estructura de dades de 16 bytes que li diu a la BIOS on llegir i on escriure les dades. La proposta és configurar el nostre DAP per llegir el sector 2048 del disc (dword [si+8], 2048) i carregar-lo a la memòria a l’adreça 0x8000 (word [si+4], 0x8000).\nEscriu un fitxer anomenat second_boot.asm amb el següent contingut:\n[org 0x8000]     ; Stage2 carregat pel MBR a 0x8000\n\nmov si, msg\n.print_loop:\n    lodsb\n    or al, al\n    jz .done\n    mov ah, 0x0e\n    int 0x10\n    jmp .print_loop\n\n.done:\n    jmp $       \n\nmsg db \"Hola des del bootloader de segona etapa!\", 0\nAra ensamblarem aquest codi i el prepararem per ser carregat pel nostre bootloader de primera etapa.\nnasm -f bin -o second_boot.bin second_boot.asm\nAra, escriurem aquest bootloader de segona etapa al disc virtual, però no al principi. El MBR està dissenyat per carregar el bootloader de segona etapa des d’una ubicació específica del disc. En aquest cas, utilitzarem el sector 2048 (1 MiB) per a això. Representaria la primera partició d’un disc amb una taula de particions estàndard.\ndd if=second_boot.bin of=disk.img bs=512 count=1 seek=2048 conv=notrunc\nModifiqueu el vostre boot.asm per carregar aquest bootloader de segona etapa des del sector 2048:\n[org 0x7c00]\n\njmp short start\nnop\n\nstart:\n    xor ax, ax\n    mov ds, ax\n    mov es, ax\n    mov ss, ax\n    mov sp, 0x7c00\n\n    ; Missatge Stage1\n    mov si, msg_mbr\n.print_loop_mbr:\n    lodsb\n    or al, al\n    jz .load_next_stage\n    mov ah, 0x0e\n    int 0x10\n    jmp .print_loop_mbr\n\n.load_next_stage:\n    ; Configura DAP a 0x0600\n    mov si, 0x0600\n    mov byte [si], 0x10         ; mida del DAP\n    mov byte [si+1], 0x00\n    mov word [si+2], 1          ; sectors a llegir\n    mov word [si+4], 0x8000     ; offset destí\n    mov word [si+6], 0x0000     ; segment destí\n    mov dword [si+8], 2048      ; LBA\n    mov dword [si+12], 0        ; high LBA\n\n    ; BIOS extended read\n    mov ah, 0x42\n    mov dl, 0x80\n    int 0x13\n    jc .boot_failed\n\n    jmp 0:0x8000\n\n.boot_failed:\n    mov si, msg_fail\n.print_loop_fail:\n    lodsb\n    or al, al\n    jz .halt\n    mov ah, 0x0e\n    int 0x10\n    jmp .print_loop_fail\n.halt:\n    cli\n    hlt\n    jmp .halt\n\nmsg_mbr db \"Hola, soc l'MBR. Carregant Stage2...\",0\nmsg_fail db \"Error carregant Stage2!\",0\n\ntimes 510-($-$$) db 0\ndw 0xAA55\nAra ensamblarem el nou MBR:\nnasm -f bin -o boot.bin boot.asm\nI escriurem el nou MBR al disc virtual:\ndd if=boot.bin of=disk.img bs=512 count=1 conv=notrunc\nFinalment, executem la imatge del disc amb QEMU per veure el nostre missatge de benvinguda i la càrrega del bootloader de segona etapa:\nqemu-system-x86_64 -drive file=disk.img,format=raw -nographic\nEnhorabona! Acabes de crear i executar un bootloader de primera etapa que carrega un bootloader de segona etapa des d’una ubicació específica del disc."
  },
  {
    "objectID": "exercises/02-booting/04-ex-week3.html",
    "href": "exercises/02-booting/04-ex-week3.html",
    "title": "Modificant la contrasenya de l’usuari root a través del GRUB",
    "section": "",
    "text": "Entendre com funciona la edició temporal del GRUB.\nEntendre com protegir el GRUB amb una contrasenya.\nEntendre com GRUB pot ser un vector d’accés físic al sistema."
  },
  {
    "objectID": "exercises/02-booting/04-ex-week3.html#objectiu",
    "href": "exercises/02-booting/04-ex-week3.html#objectiu",
    "title": "Modificant la contrasenya de l’usuari root a través del GRUB",
    "section": "",
    "text": "Entendre com funciona la edició temporal del GRUB.\nEntendre com protegir el GRUB amb una contrasenya.\nEntendre com GRUB pot ser un vector d’accés físic al sistema."
  },
  {
    "objectID": "exercises/02-booting/04-ex-week3.html#escenari",
    "href": "exercises/02-booting/04-ex-week3.html#escenari",
    "title": "Modificant la contrasenya de l’usuari root a través del GRUB",
    "section": "Escenari",
    "text": "Escenari\nUn atacant amb accés físic al servidor podria modificar la contrasenya de l’usuari root iniciant el sistema des del GRUB. En aquesta pràctica assumirem aquest escenari de manera controlada."
  },
  {
    "objectID": "exercises/02-booting/04-ex-week3.html#requeriments-previs",
    "href": "exercises/02-booting/04-ex-week3.html#requeriments-previs",
    "title": "Modificant la contrasenya de l’usuari root a través del GRUB",
    "section": "Requeriments previs",
    "text": "Requeriments previs\n\nUna màquina virtual amb Debian 12 amb GRUB com a gestor d’arrencada."
  },
  {
    "objectID": "exercises/02-booting/04-ex-week3.html#procediment",
    "href": "exercises/02-booting/04-ex-week3.html#procediment",
    "title": "Modificant la contrasenya de l’usuari root a través del GRUB",
    "section": "Procediment",
    "text": "Procediment\n\nAccés al GRUB\n\nReinicia el sistema i accedeix al menú del bootloader GRUB.\nSelecciona la entrada del sistema operatiu i prem e per editar-la.\n\nModificació de la línia del kernel\n\nLocalitza la línia que comença amb linux i acaba amb ro.\nAfageix init=/bin/bash al final.\nAquesta opció indica al kernel iniciar directament un shell sense passar pel procés d’inicialització normal.\n\n\n\n\n\n\n\n\nNotainit=/bin/bash\n\n\n\nAquesta opció fa que el sistema arranqui directament en un shell de bash com a root, evitant els processos d’inicialització habituals. Tots els serveis systemd i altres processos no s’inicien, i el sistema es troba en un estat mínim, amb només el shell disponible.\n\n\n\nInici amb les opcions modificades\n\nPrem Ctrl + X per iniciar el sistema amb aquesta configuració.\nAccediràs a un prompt de bash amb permisos de root.\n\nMuntar el sistema de fitxers en mode escriptura\nmount -o remount,rw /\n\n\n\n\n\n\n\nNotamount -o remount,rw /\n\n\n\nCom alternativa, es pot editar la línia del kernel per canviar ro (read-only) a rw (read-write). Això permetrà que el sistema de fitxers es monti en mode escriptura des del principi, evitant la necessitat de remuntar-lo més tard.\n\n\n\nAccedir a l’arrel amb chroot\nchroot /\n\n\n\n\n\n\n\nNotachroot\n\n\n\nUna chroot (change root) és una operació que canvia el directori arrel aparent d’un procés i els seus fills a un directori especificat. Això crea un entorn aïllat on el procés veu el directori especificat com la seva arrel (/), permetent executar processos en un sistema de fitxers diferent sense afectar el sistema principal.\n\n\n\nCanviar la contrasenya de root\npasswd\n\nIntrodueix la nova contrasenya quan se’t demani.\n\nSincronitzar els canvis i reiniciar\nexit \nreboot\n\n\n\n\n\n\n\nNotaSolcució si reboot no funciona\n\n\n\nSi el sistema no respon a la comanda reboot, pots forçar un reinici físic de la màquina virtual.\n\n\n\nIniciar sessió amb l’usuari normal.\nCanviar a l’usuari root amb la nova contrasenya. su -"
  },
  {
    "objectID": "exercises/02-booting/04-ex-week3.html#protecció-del-grub",
    "href": "exercises/02-booting/04-ex-week3.html#protecció-del-grub",
    "title": "Modificant la contrasenya de l’usuari root a través del GRUB",
    "section": "Protecció del GRUB",
    "text": "Protecció del GRUB\nPer protegir el GRUB i evitar que un atacant amb accés físic pugui modificar les opcions d’arrencada, es pot configurar una contrasenya per al GRUB.\n\nGenerar una contrasenya xifrada\n\nUtilitza la comanda següent per generar una contrasenya xifrada:\ngrub-mkpasswd-pbkdf2\nIntrodueix la contrasenya desitjada i copia la sortida que comença amb pbkdf2.\n\nEditar la configuració del GRUB\n\nObre el fitxer de configuració del GRUB:\n# Com a root\nvi /etc/grub.d/40_custom\nAfegeix les línies següents al fitxer, substituint your_encrypted_password per la contrasenya xifrada que has generat:\nset superusers=\"root\"\npassword_pbkdf2 root your_encrypted_password\n\nActualitzar la configuració del GRUB\n\nDesprés d’haver editat el fitxer, actualitza la configuració del GRUB:\nupdate-grub    # Debian/Ubuntu\ngrub2-mkconfig -o /boot/grub2/grub.cfg  # Alma/Rocky (BIOS)\ngrub2-mkconfig -o /boot/efi/EFI/almalinux/grub.cfg  # Alma/Rocky (UEFI)\n\nReiniciar el sistema\n ```bash\n reboot\n ```\nVerificar la protecció del GRUB\n\nDurant l’arrencada, intenta editar una entrada del GRUB. Hauries de ser sol·licitat per una contrasenya.\n\n\n\n\n\n\n\n\nImportant👁️ Observació\n\n\n\nMalgrat l’ús d’una contrasenya per a protegir el GRUB, aquesta tècnica no és infal·lible. Un atacant amb accés físic pot montar un usb bootable i iniciar el sistema amb aquest dispositiu. Un cop iniciat el sistema, l’atacant podria montar el sistema de fitxers i modificar la contrasenya de l’usuari root. Ara bé, es podria configurar el BIOS o UEFI per a desactivar l’arrencada des de dispositius externs com els USBs. Això dificultaria l’accés no autoritzat al sistema a través d’aquesta tècnica."
  },
  {
    "objectID": "exercises/02-booting/04-ex-week3.html#reflexions",
    "href": "exercises/02-booting/04-ex-week3.html#reflexions",
    "title": "Modificant la contrasenya de l’usuari root a través del GRUB",
    "section": "Reflexions",
    "text": "Reflexions\n\nControl físic del servidor: Limitar l’accés físic és essencial.\nDesactivar arrencada des de dispositius externs: Configurar BIOS/UEFI per bloquejar USB/CD.\nAmb LUKS/dm-crypt, encara que l’atacant accedeixi físicament al GRUB, no podrà llegir ni modificar les dades sense la clau.\nUEFI Secure Boot: Si està activat i el GRUB està signat, no es podrà iniciar amb init=/bin/bash sense desactivar temporalment Secure Boot."
  },
  {
    "objectID": "exercises/02-booting/02-ex-week2.html",
    "href": "exercises/02-booting/02-ex-week2.html",
    "title": "Arrancada UEFI bàsica amb QEMU",
    "section": "",
    "text": "En aquest exercici aprendrem a crear un entorn d’arrencada UEFI senzill utilitzant QEMU. A diferència de la BIOS tradicional, la UEFI utilitza fitxers executables en format PE (Portable Executable) per carregar els sistemes operatius. Aquests fitxers es col·loquen en una partició especial del disc anomenada ESP (EFI System Partition).\nL’objectiu final és carregar i executar un petit joc de Tetris dins de l’entorn UEFI.\n\n\nPer a aquest laboratori, necessitem una màquina virtual amb Debian i una interfície gràfica, ja que la UEFI per defecte utilitza un entorn gràfic.\nSi no teniu una interfície gràfica, podeu instal·lar-la amb la següent comanda:\nsu -c \"apt install task-gnome-desktop -y\"\n\n\n\n\n\n\nNotaNota\n\n\n\nUn cop instal·lada la interfície gràfica, reinicieu la màquina virtual i inicieu sessió a l’entorn d’escriptori.\n\n\nA més, necessitem instal·lar les eines necessàries per compilar i executar el nostre codi UEFI.\nsu -c \"apt install qemu-system-x86 gcc-x86-64-linux-gnu nasm make gnu-efi gdisk mtools -y\"\nsu -c “apt install qemu-system-x86 make gdisk mtools -y”\nFinalment, clonem el repositori amb el codi font del joc de Tetris per UEFI:\ngit clone https://github.com/a1ive/uefi-tetris.git\ncd uefi-tetris\n\n\n\n\n\n\nNotaNota\n\n\n\nQuan executeu les comandes QEMU, no ho feu amb la conexió SSH ja que us donarà problemes amb la interfície gràfica. Utilitzeu la terminal de la màquina virtual directament.\n\n\n\n\n\nAquest mètode ens permetrà executar ràpidament un executable UEFI sense la necessitat de crear una imatge de disc. Utilitzarem la UEFI Shell, una línia de comandes que ens permet interactuar amb l’entorn UEFI.\nqemu-system-x86_64 -bios /usr/share/qemu/OVMF.fd -drive format=raw,file=fat:rw:./ -net none\nOn aquest comandament:\n\nbios /usr/share/qemu/OVMF.fd: Carrega el firmware OVMF (Open Virtual Machine Firmware), que és la implementació UEFI per a QEMU.\n-drive format=raw,file=fat:rw:./: Munta el directori actual (./) com si fos una partició FAT. La UEFI Shell reconeix aquest format de manera nativa, donant-nos accés al nostre fitxer tetris.efi.\n-net none: Deshabilita la xarxa, ja que no la necessitem per a aquest exercici.\n\nEn executar la comanda, QEMU s’iniciarà i, com que no hi ha cap sistema operatiu per arrencar, caurà directament a la UEFI Shell.\n\n\nUn cop a la UEFI Shell, accedim a la partició que QEMU ha muntat per nosaltres.\nfs0:\nLa comanda fs0: ens canvia a la partició FAT que correspon al nostre directori.\n\n\n\n\n\n\nNotaNotes\n\n\n\n\nEl teclat està en anglès per defecte. Per escriure el caràcter : heu de prémer Shift + Ñ.\nSi fs0: no funciona, podeu llistar les particions disponibles amb la comanda map i provar amb les altres.\n\n\n\n\n\n\n\n\n\nNotaNota\n\n\n\nUtilitzeu les comandes ls i cd per navegar pel sistema de fitxers fins que trobeu la carpeta uefi-tetris i dins d’ella el fitxer tetris.efi.\n\n\nFinalment, executem el bootloader UEFI:\ntetris.efi\n\n\n\n\nAquest mètode simula un escenari més real, on el fitxer executable es troba en una partició dedicada al disc. La partició ESP (EFI System Partition) és una partició especial, formatada en FAT32, on es guarden els fitxers d’arrencada del sistema operatiu.\n\n\nPrimer, creem un fitxer que farà de disc dur virtual. Amb 64 MB n’hi ha prou.\nqemu-img create -f raw tetris.img 64M\n\n\n\nUtilitzarem gdisk per crear la partició ESP. La GPT (GUID Partition Table) és el format modern de taules de particions, necessari per a la UEFI.\nsu -\ncd /path/to/uefi-tetris # Canvia al directori on has clonat el repositori\ngdisk tetris.img\nA la consola de gdisk, utilitzarem les següents comandes:\n\nPrémer o per crear una nova taula GPT.\nPrémer n per crear una nova partició.\nPrèmer 1 per assignar el número de partició.\nPrèmer Enter per acceptar l’inici per defecte.\nPrèmer Enter per acceptar la mida per defecte (fins al final del disc).\nPrèmer ef00 per assignar el tipus EFI System Partition.\nPrèmer w per escriure els canvis i sortir.\n\n\n\n\n\n\n\nNotaNota\n\n\n\nConfirmeu tots els canvis escrivint Y quan se us demani. Per assegurar-vos que la partició s’ha creat correctament, podeu utilitzar gdisk -l tetris.img per llistar les particions del fitxer d’imatge. Observeu que la partició té el tipus EF00, indicant que és una partició ESP.\n\n\n\n\n\nAra que tenim la partició, l’hem de formatar, és a dir, donar-li un sistema de fitxers. La UEFI requereix que la partició ESP estigui formatada en FAT32.\n\nIdentificar el dispositiu de bucle:\n\n# Com a root\nlosetup --partscan --find --show tetris.img\nAquesta comanda mostrarà el nom del dispositiu de bucle creat (p. ex., /dev/loop1) i la seva partició (/dev/loop1p1). Anoteu-ho.\n\nFormatejar la partició:\n\n# Com a root\nmkfs.fat -F 32 /dev/loop1p1\n\n\n\nAra, muntem la partició i copiem el fitxer tetris.efi a la ubicació correcta dins de l’estructura de directoris esperada per la UEFI.\n# Com a root\nmount /dev/loop1p1 /mnt\nmkdir -p /mnt/EFI/BOOT\ncp tetris.efi /mnt/EFI/BOOT/BOOTX64.EFI\numount /mnt\nlosetup -d /dev/loop1\n\n\n\n\n\n\nNotaObservació\n\n\n\nLa UEFI espera trobar el fitxer d’arrencada en aquesta ubicació específica: \\EFI\\BOOT\\BOOTX64.EFI per a sistemes x86_64. Si utilitzeu una arquitectura diferent, assegureu-vos de canviar el nom del fitxer segons sigui necessari (per exemple, BOOTAA64.EFI per a ARM64). Com estem emulant un sistema x86_64, utilitzem BOOTX64.EFI.\n\n\n\n\n\nFinalment, podem arrencar la nostra imatge de disc amb QEMU utilitzant el firmware UEFI.\nqemu-system-x86_64 -bios /usr/share/qemu/OVMF.fd -drive format=raw,file=tetris.img -net none\nSi tot ha anat bé, hauríeu de veure el joc de Tetris en funcionament a la pantalla directament sense necessitat d’entrar a la UEFI Shell."
  },
  {
    "objectID": "exercises/02-booting/02-ex-week2.html#tetris-amb-uefi",
    "href": "exercises/02-booting/02-ex-week2.html#tetris-amb-uefi",
    "title": "Arrancada UEFI bàsica amb QEMU",
    "section": "",
    "text": "En aquest exercici aprendrem a crear un entorn d’arrencada UEFI senzill utilitzant QEMU. A diferència de la BIOS tradicional, la UEFI utilitza fitxers executables en format PE (Portable Executable) per carregar els sistemes operatius. Aquests fitxers es col·loquen en una partició especial del disc anomenada ESP (EFI System Partition).\nL’objectiu final és carregar i executar un petit joc de Tetris dins de l’entorn UEFI.\n\n\nPer a aquest laboratori, necessitem una màquina virtual amb Debian i una interfície gràfica, ja que la UEFI per defecte utilitza un entorn gràfic.\nSi no teniu una interfície gràfica, podeu instal·lar-la amb la següent comanda:\nsu -c \"apt install task-gnome-desktop -y\"\n\n\n\n\n\n\nNotaNota\n\n\n\nUn cop instal·lada la interfície gràfica, reinicieu la màquina virtual i inicieu sessió a l’entorn d’escriptori.\n\n\nA més, necessitem instal·lar les eines necessàries per compilar i executar el nostre codi UEFI.\nsu -c \"apt install qemu-system-x86 gcc-x86-64-linux-gnu nasm make gnu-efi gdisk mtools -y\"\nsu -c “apt install qemu-system-x86 make gdisk mtools -y”\nFinalment, clonem el repositori amb el codi font del joc de Tetris per UEFI:\ngit clone https://github.com/a1ive/uefi-tetris.git\ncd uefi-tetris\n\n\n\n\n\n\nNotaNota\n\n\n\nQuan executeu les comandes QEMU, no ho feu amb la conexió SSH ja que us donarà problemes amb la interfície gràfica. Utilitzeu la terminal de la màquina virtual directament.\n\n\n\n\n\nAquest mètode ens permetrà executar ràpidament un executable UEFI sense la necessitat de crear una imatge de disc. Utilitzarem la UEFI Shell, una línia de comandes que ens permet interactuar amb l’entorn UEFI.\nqemu-system-x86_64 -bios /usr/share/qemu/OVMF.fd -drive format=raw,file=fat:rw:./ -net none\nOn aquest comandament:\n\nbios /usr/share/qemu/OVMF.fd: Carrega el firmware OVMF (Open Virtual Machine Firmware), que és la implementació UEFI per a QEMU.\n-drive format=raw,file=fat:rw:./: Munta el directori actual (./) com si fos una partició FAT. La UEFI Shell reconeix aquest format de manera nativa, donant-nos accés al nostre fitxer tetris.efi.\n-net none: Deshabilita la xarxa, ja que no la necessitem per a aquest exercici.\n\nEn executar la comanda, QEMU s’iniciarà i, com que no hi ha cap sistema operatiu per arrencar, caurà directament a la UEFI Shell.\n\n\nUn cop a la UEFI Shell, accedim a la partició que QEMU ha muntat per nosaltres.\nfs0:\nLa comanda fs0: ens canvia a la partició FAT que correspon al nostre directori.\n\n\n\n\n\n\nNotaNotes\n\n\n\n\nEl teclat està en anglès per defecte. Per escriure el caràcter : heu de prémer Shift + Ñ.\nSi fs0: no funciona, podeu llistar les particions disponibles amb la comanda map i provar amb les altres.\n\n\n\n\n\n\n\n\n\nNotaNota\n\n\n\nUtilitzeu les comandes ls i cd per navegar pel sistema de fitxers fins que trobeu la carpeta uefi-tetris i dins d’ella el fitxer tetris.efi.\n\n\nFinalment, executem el bootloader UEFI:\ntetris.efi\n\n\n\n\nAquest mètode simula un escenari més real, on el fitxer executable es troba en una partició dedicada al disc. La partició ESP (EFI System Partition) és una partició especial, formatada en FAT32, on es guarden els fitxers d’arrencada del sistema operatiu.\n\n\nPrimer, creem un fitxer que farà de disc dur virtual. Amb 64 MB n’hi ha prou.\nqemu-img create -f raw tetris.img 64M\n\n\n\nUtilitzarem gdisk per crear la partició ESP. La GPT (GUID Partition Table) és el format modern de taules de particions, necessari per a la UEFI.\nsu -\ncd /path/to/uefi-tetris # Canvia al directori on has clonat el repositori\ngdisk tetris.img\nA la consola de gdisk, utilitzarem les següents comandes:\n\nPrémer o per crear una nova taula GPT.\nPrémer n per crear una nova partició.\nPrèmer 1 per assignar el número de partició.\nPrèmer Enter per acceptar l’inici per defecte.\nPrèmer Enter per acceptar la mida per defecte (fins al final del disc).\nPrèmer ef00 per assignar el tipus EFI System Partition.\nPrèmer w per escriure els canvis i sortir.\n\n\n\n\n\n\n\nNotaNota\n\n\n\nConfirmeu tots els canvis escrivint Y quan se us demani. Per assegurar-vos que la partició s’ha creat correctament, podeu utilitzar gdisk -l tetris.img per llistar les particions del fitxer d’imatge. Observeu que la partició té el tipus EF00, indicant que és una partició ESP.\n\n\n\n\n\nAra que tenim la partició, l’hem de formatar, és a dir, donar-li un sistema de fitxers. La UEFI requereix que la partició ESP estigui formatada en FAT32.\n\nIdentificar el dispositiu de bucle:\n\n# Com a root\nlosetup --partscan --find --show tetris.img\nAquesta comanda mostrarà el nom del dispositiu de bucle creat (p. ex., /dev/loop1) i la seva partició (/dev/loop1p1). Anoteu-ho.\n\nFormatejar la partició:\n\n# Com a root\nmkfs.fat -F 32 /dev/loop1p1\n\n\n\nAra, muntem la partició i copiem el fitxer tetris.efi a la ubicació correcta dins de l’estructura de directoris esperada per la UEFI.\n# Com a root\nmount /dev/loop1p1 /mnt\nmkdir -p /mnt/EFI/BOOT\ncp tetris.efi /mnt/EFI/BOOT/BOOTX64.EFI\numount /mnt\nlosetup -d /dev/loop1\n\n\n\n\n\n\nNotaObservació\n\n\n\nLa UEFI espera trobar el fitxer d’arrencada en aquesta ubicació específica: \\EFI\\BOOT\\BOOTX64.EFI per a sistemes x86_64. Si utilitzeu una arquitectura diferent, assegureu-vos de canviar el nom del fitxer segons sigui necessari (per exemple, BOOTAA64.EFI per a ARM64). Com estem emulant un sistema x86_64, utilitzem BOOTX64.EFI.\n\n\n\n\n\nFinalment, podem arrencar la nostra imatge de disc amb QEMU utilitzant el firmware UEFI.\nqemu-system-x86_64 -bios /usr/share/qemu/OVMF.fd -drive format=raw,file=tetris.img -net none\nSi tot ha anat bé, hauríeu de veure el joc de Tetris en funcionament a la pantalla directament sense necessitat d’entrar a la UEFI Shell."
  },
  {
    "objectID": "exercises/02-booting/06-ex-week4.html",
    "href": "exercises/02-booting/06-ex-week4.html",
    "title": "Anàlisi del procés d’arrencada amb systemd",
    "section": "",
    "text": "Aprendre a utilitzar les eines de systemd per analitzar el procés d’arrencada del sistema.\nEntendre com identificar quines unitats són les més crítiques per al temps d’arrencada.\nAprendre a interpretar la sortida de les comandes systemd-analyze i systemctl."
  },
  {
    "objectID": "exercises/02-booting/06-ex-week4.html#objectius",
    "href": "exercises/02-booting/06-ex-week4.html#objectius",
    "title": "Anàlisi del procés d’arrencada amb systemd",
    "section": "",
    "text": "Aprendre a utilitzar les eines de systemd per analitzar el procés d’arrencada del sistema.\nEntendre com identificar quines unitats són les més crítiques per al temps d’arrencada.\nAprendre a interpretar la sortida de les comandes systemd-analyze i systemctl."
  },
  {
    "objectID": "exercises/02-booting/06-ex-week4.html#requeriments-previs",
    "href": "exercises/02-booting/06-ex-week4.html#requeriments-previs",
    "title": "Anàlisi del procés d’arrencada amb systemd",
    "section": "Requeriments Previs",
    "text": "Requeriments Previs\n\nTenir una màquina virtual (MV) amb Debian instal·lat.\nTotes les comandes s’han d’executar amb permisos de superusuari (root). Per tant, su -."
  },
  {
    "objectID": "exercises/02-booting/06-ex-week4.html#anàlisi-del-procés-darrencada-amb-systemd",
    "href": "exercises/02-booting/06-ex-week4.html#anàlisi-del-procés-darrencada-amb-systemd",
    "title": "Anàlisi del procés d’arrencada amb systemd",
    "section": "Anàlisi del procés d’arrencada amb systemd",
    "text": "Anàlisi del procés d’arrencada amb systemd\nLa comanda systemd ens permet gestionar els serveis del sistema i controlar el procés d’arrencada. Podeu comprovar les seves possibilitats amb la comanda man systemd. Una de les funcionalitats més útils de systemd és la capacitat de generar informació detallada sobre el procés d’arrencada del sistema.\nEl primer pas per analitzar el procés d’arrencada amb systemd és utilitzar la comanda systemd-analyze per obtenir informació sobre el temps que ha trigat el sistema a arrencar. Aquesta comanda mostrarà informació sobre el temps que ha trigat el sistema a arrencar, incloent el temps que ha trigat el kernel i l’espai d’usuari.\nStartup finished in 899ms (kernel) + 2.074s (userspace) = 2.973s\ngraphical.target reached after 2.068s in userspace.\n\n\n\nKernel\nEspai d’usuari\nTotal\n\n\n\n\n899ms\n2.074s\n2.973s\n\n\n\nEn aquest cas, els primers 899ms s’utilitzen per carregar les funcions del kernel com ara els controladors de dispositius i el sistema de fitxers. Els següents 2.074s s’utilitzen per carregar l’espai d’usuari, com ara els serveis i els processos del sistema. En total, el sistema ha trigat 2.973s a arrencar.\nAra que tenim aquesta informació, podem utilitzar la comanda systemd-analyze blame per obtenir informació detallada sobre el temps que ha trigat cada unitat a carregar durant el procés d’arrencada. Aquesta opció ens llistarà les unitats ordenades per temps d’arrencada, de major a menor.\n\n\n\nTemps\nUnitat\n\n\n\n\n1.876s\nsystemd-random-seed.service\n\n\n784ms\ndbus.service\n\n\n782ms\ne2scrub_reap.service\n\n\n778ms\nsystemd-logind.service\n\n\n…\n…\n\n\n4ms\nsystemd-update-utmp-runlevel.service\n\n\n\nAmb aquesta informació, podem identificar les unitats que poden estar retardant el procés d’arrencada i optimitzar-les si cal. Per obtenir més informació sobre una unitat específica, podeu utilitzar la comanda systemctl status seguida del nom de la unitat. Per exemple, si volem informació sobre la unitat systemd-random-seed.service, podem executar:\nsystemctl status systemd-random-seed.service\nAquesta informació ens mostrarà:\n\nL’estat actual de la unitat (inactiu, actiu, desactivat, error o recarregant).\nLa linia Loaded ens indica la ruta al fitxer on es desa la configuració de la unitat. En aquest cas, /lib/systemd/system/systemd-random-seed.service. A més ens indica static que vol dir que la unitat no es pot desactivar. Altres unitats ens poden indicar error, masked, not-found, enable o disabled\nLa entrada al manual de la unitat, si n’hi ha.\nFinalment, ens mostra informació sobre el procés: PID, estat del procés i temps que ha estat en execució (això en el exemple) també pot mostrar la memòria, el cgroup, o el nombre de tasques associades.\n\nSi volem saber exactament què fa aquest servei, podem consultar el manual amb la comanda man systemd-random-seed.service.\nEn el manual d’aquesta comanda us explicarà de forma detallada què aquest servei carrega una llavor aleatòria al espai del nucli quan arranca i la desa quan s’apaga. Aquesta llavor es guarda a /var/lib/systemd/random-seed. Per defecte, no s’assigna entropia quan s’escriu la llavor al nucli, però això es pot canviar amb $SYSTEMD_RANDOM_SEED_CREDIT. El servei s’executa després de muntar el sistema de fitxers /var/, per la qual cosa és recomanable utilitzar un carregador d’arrencada que passi una llavor inicial al nucli, com systemd-boot.\n\n\n\n\n\n\nNotaObservació\n\n\n\nAmb aquesta informació podem identificar quina és la funció de cada servei i decidir si pel nostre sistema és necessari o no. En aquest cas, el servei systemd-random-seed.service és necessari per a la generació de nombres aleatoris, per tant, no és recomanable desactivar-lo.\n\n\nSi volem informació sobre la unitat systemd-random-seed.service, podem utilitzar la comanda systemctl cat systemd-random-seed.service per veure la configuració de la unitat.\n# /lib/systemd/system/systemd-random-seed.service\n#  SPDX-License-Identifier: LGPL-2.1-or-later\n#\n#  This file is part of systemd.\n#\n#  systemd is free software; you can redistribute it and/or modify it\n#  under the terms of the GNU Lesser General Public License as published by\n#  the Free Software Foundation; either version 2.1 of the License, or\n#  (at your option) any later version.\n\n[Unit]\nDescription=Load/Save Random Seed\nDocumentation=man:systemd-random-seed.service(8) man:random(4)\nDefaultDependencies=no\nRequiresMountsFor=/var/lib/systemd/random-seed\nConflicts=shutdown.target\nAfter=systemd-remount-fs.service\nBefore=first-boot-complete.target shutdown.target\nWants=first-boot-complete.target\nConditionVirtualization=!container\nConditionPathExists=!/etc/initrd-release\n\n[Service]\nType=oneshot\nRemainAfterExit=yes\nExecStart=/lib/systemd/systemd-random-seed load\nExecStop=/lib/systemd/systemd-random-seed save\n\n# This service waits until the kernel's entropy pool is initialized, and may be\n# used as ordering barrier for service that require an initialized entropy\n# pool. Since initialization can take a while on entropy-starved systems, let's\n# increase the timeout substantially here.\nTimeoutSec=10min\nAquesta informació ens mostra la configuració de la unitat, incloent la descripció, la documentació, les dependències, les condicions, el tipus de servei, els comandaments d’inici i parada, i altres opcions de configuració. El servei té una dependència de muntatge per a /var/lib/systemd/random-seed, i s’executa després de systemd-remount-fs.service i abans de first-boot-complete.target i shutdown.target. A més, ens indica que és un servei de tipus oneshot, que s’executa una sola vegada i roman actiu després de la sortida. Els comandaments d’inici i parada són /lib/systemd/systemd-random-seed load i /lib/systemd/systemd-random-seed save, respectivament.\n\n\n\n\n\n\nNotaNota\n\n\n\nSi observeu el paramètre TimeoutSec=10min aquesta unitat pot trigar fins a 10 minuts a carregar. Si el sistema està en un entorn amb poca entropia, aquesta unitat pot trigar més temps a carregar.\n\n\nPer exemple, editarem la unitat systemd-random-seed.service per activar la entropia al sistema. Per editar la unitat podeu utilitzar qualsevol editor de text ( i.e vi) o bé la comanda systemctl edit systemd-random-seed.service que obrirà un editor de text per afegir la línia. Un cop obert l’editor heu d’afegir la lína a la secció [Service] i desar el fitxer. Recordeu que per fer aquesta acció necessitareu permisos d’administrador. Per tant, su - per canviar a l’usuari root i després fer la comanda.\nEnvironment=SYSTEMD_RANDOM_SEED_CREDIT=4096\n\nCompte! Si feu anar el systemctl edit aquest crearà un fitxer de configuració a /etc/systemd/system/systemd-random-seed.service.d/override.conf que sobreescriurà la configuració de la unitat original. Per afegir la configuració còpieu la configuració original i afegiu la línia Environment=SYSTEMD_RANDOM_SEED_CREDIT=4096 a la secció [Service].\n\nEstem assignant un crèdit de 4096 a la llavor aleatòria. Això augmentarà la quantitat d’entropia que es passa al nucli quan s’escriu la llavor. Un crèdit més alt pot augmentar la seguretat del sistema, però també pot augmentar el temps d’arrencada en sistemes amb poca entropia.\nUn cop hàgim fet els canvis, guardarem el fitxer i sortirem de l’editor. Després, podem fer un reboot per aplicar els canvis. Quan el sistema s’hagi reiniciat, podem tornar a utilitzar la comanda systemd-analyze per comprovar si els canvis han tingut algun impacte en el temps d’arrencada del sistema.\nUna altra opció interesant que ens ofereix systemd és la comanda systemd-analyze critical-chain. Aquesta comanda ens permet veure la cadena crítica de les unitats de temps del sistema. Això ens mostra quines unitats són les més crítiques per al temps d’arrencada del sistema. Per analizar la sortida, heu de mirar el temps després del caràcter @ per veure quant temps ha trigat la unitat a activar-se o iniciar-se, i el temps després del caràcter + per veure quant temps ha trigat la unitat a iniciar-se. A més, aquesta comanda només mostra el temps que les unitats han passat a l’estat activant-se, i no cobreix les unitats que mai han passat per l’estat activant-se (com les unitats de dispositius que passen directament de inactiu a actiu). Tot i això, és una eina útil per identificar les unitats que poden estar retardant el procés d’arrencada.\ngraphical.target @2.076s\n└─multi-user.target @2.075s\n  └─ssh.service @1.497s +578ms\n    └─network.target @1.494s\n      └─networking.service @1.225s +268ms\n        └─apparmor.service @1.158s +63ms\n          └─local-fs.target @1.158s\n            └─run-credentials-systemd\\x2dtmpfiles\\x2dsetup.service.mount @1.171s\n              └─local-fs-pre.target @242ms\n                └─systemd-tmpfiles-setup-dev.service @224ms +17ms\n                  └─systemd-sysusers.service @192ms +20ms\n                    └─systemd-remount-fs.service @131ms +54ms\n                      └─systemd-journald.socket @114ms\n                        └─-.mount @86ms\n                          └─-.slice @86ms\nEn aquest cas, podem veure que la unitat ssh.service és la més crítica per al temps d’arrencada del sistema, ja que ha trigat 578ms a iniciar-se. A més, podem veure les dependències de totes les unitats que s’han carregat durant el procés d’arrencada. Començant pel graphical.target i seguint per les unitats multi-user.target, aquestes dos unitats ens asseguren que el sistema ha arrencat en mode gràfic i multiusuari. A partir d’aquest moment es carreguen la resta de serveis.\nUn altra opció interessant és utilitzar la comanda systemd-analyze plot per generar un gràfic del procés d’arrencada del sistema. Aquesta comanda generarà un fitxer SVG amb el gràfic del procés d’arrencada, que podeu visualitzar amb un navegador web o un visor d’imatges.\n\nSi volem analitzar tots les unitats:\nsystemd-analyze plot &gt; boot_system.svg\nSi volem analitzar les unitats de la instancia de l’usuari:\nsystemd-analyze --user plot &gt; boot_user.svg\nSi volem les unitats de l’arrencada del sistema:\nsystemd-analyze --system plot &gt; boot_system.svg\n\n\n\n⚠️ Compte: Com puc visualtizar una imatge SVG en un debian sense interfície gràfica?\nPer visualitzar una imatge SVG en un sistema sense interfície gràfica, podeu descarregar el fitxer SVG a la vostra màquina local i visualitzar-lo amb un visor d’imatges o un navegador web. Per exemple, podeu utilitzar la comanda scp per descarregar el fitxer SVG a la vostra màquina local:\nscp user@remote:/path/to/boot.svg /path/to/local/boot.svg\n\n\n\n⚠️ Compte: Debian no permet conexions remotes com a root per defecte. Abans de fer-ho, com debian per defecte no permet l’execució de scp com a root, caldrà fer-ho com a usuari normal i després copiar el fitxer a la carpeta desitjada.\nmv boot.svg /tmp \nchown user:user /tmp/boot.svg  \n\nPer a més informació sobre les opcions de la comanda systemd-analyze, podeu consultar el manual amb la comanda man systemd-analyze.\nPer acabar, podem comentar que així com systemctl status unitat ens mostra la informació d’una unitat. També podem consultar la informació de totes les unitats amb:\n\nsystemctl status: Mostra informació sobre l’estat actual del sistema o d’una unitat específica acompanyada de les dades més recents del registre del diari.\nsystemctl list-units: Mostra una llista de totes les unitats carregades al sistema, incloent les unitats actives, inactives i fallades."
  },
  {
    "objectID": "exercises/01-foundations-of-systems-administration/01-ex-week1.html",
    "href": "exercises/01-foundations-of-systems-administration/01-ex-week1.html",
    "title": "Configuració d’entorn de virtualització",
    "section": "",
    "text": "Aquest exercici té com a objectiu recordar i consolidar les habilitats en la configuració d’entorns de virtualització utilitzant màquines virtuals (MV). Durant el curs, la creació i destrucció de MV serà una tasca recurrent, per la qual cosa és fonamental tenir una base sòlida. Preparant una plantilla preinstal·lada, podreu estalviar temps significatiu evitant la reinstal·lació completa del sistema operatiu cada cop que necessiteu un nou entorn de treball."
  },
  {
    "objectID": "exercises/01-foundations-of-systems-administration/01-ex-week1.html#requeriments-previs",
    "href": "exercises/01-foundations-of-systems-administration/01-ex-week1.html#requeriments-previs",
    "title": "Configuració d’entorn de virtualització",
    "section": "Requeriments previs",
    "text": "Requeriments previs\n\nDisposar d’un hipervisor de virtualització instal·lat a la vostra màquina hoste. Es recomana utilitzar VMware Workstation Pro o VMware Fusion. Podeu reutilitzar la instal·lació que ja vau fer a l’assignatura de Sistemes Operatius."
  },
  {
    "objectID": "exercises/01-foundations-of-systems-administration/01-ex-week1.html#objectius",
    "href": "exercises/01-foundations-of-systems-administration/01-ex-week1.html#objectius",
    "title": "Configuració d’entorn de virtualització",
    "section": "Objectius",
    "text": "Objectius\n\nCrear i configurar màquines virtuals amb distribucions Linux.\nUtilitzar snapshots per gestionar l’estat de les MV.\nConfigurar i establir una connexió remota segura a les MV utilitzant SSH."
  },
  {
    "objectID": "exercises/01-foundations-of-systems-administration/01-ex-week1.html#tasques",
    "href": "exercises/01-foundations-of-systems-administration/01-ex-week1.html#tasques",
    "title": "Configuració d’entorn de virtualització",
    "section": "Tasques",
    "text": "Tasques\n\nCreació de màquines virtuals\nCreareu dues màquines virtuals amb les distribucions Linux que farem servir durant el curs. Assegureu-vos de descarregar les imatges ISO correctament:\n\nAlmaLinux: Una distribució de GNU/Linux basada en Red Hat Enterprise Linux (RHEL).Descarregueu la versió 9.6.\nDebian: Una distribució popular coneguda per la seva estabilitat. Descarregueu la versió 12.5.0.\n\nEn la configuració no necessitareu finestres gràfiques, i de moment podeu utilitzar una configuració de disc i particions estàndard. Més endavant, durant el curs, anirem ajustant la configuració segons les necessitats específiques de cada pràctica.\n\n\nCreació de snapshots\nUn cop instal·lades les dues màquines virtuals, creeu una snapshot de cadascuna. Una snapshot és una instantània de l’estat actual de la màquina virtual, incloent-hi la seva memòria, configuració i l’estat dels seus discos virtuals. Aquesta eina us permetrà tornar ràpidament a un estat inicial net en qualsevol moment, evitant haver de reinstal·lar el sistema si alguna configuració falla.\n\n\nConfiguració d’accés remot amb SSH\nPer facilitar la connexió i gestió de les màquines virtuals, configurarem l’accés remot mitjançant SSH (Secure Shell). Això us permetrà connectar-vos a les MV des de la vostra màquina hoste utilitzant una terminal o PowerShell amb suport SSH (Linux o MacOS).\nssh user@vm_ip_address\n\n\nÚs de la snapshot\nUn cop hàgiu completat la configuració inicial i les proves amb les màquines virtuals, practiqueu l’ús de les snapshots:\n\nInstal·leu algun programari a la MV amb debian com les eines de desenvolupament (gcc, make, etc).\n\n# Recordeu instal·lar com a root\napt install build-essential\n\nComproveu que el programari està instal·lat correctament.\n\ngcc --version\n\nDesprés, torneu a la snapshot creada anteriorment per veure que el programari ja no està instal·lat."
  },
  {
    "objectID": "exercises/01-foundations-of-systems-administration/01-ex-week1.html#activitat-proposada",
    "href": "exercises/01-foundations-of-systems-administration/01-ex-week1.html#activitat-proposada",
    "title": "Configuració d’entorn de virtualització",
    "section": "Activitat proposada",
    "text": "Activitat proposada\n\nEscriu un script senzill que et permeti obrir la MV i connectar-te via SSH amb un sol comandament. Aquest script hauria de:\n\nIniciar la màquina virtual si no està en funcionament.\nEsperar fins que la MV estigui completament engegada.\nConnectar-se a la MV mitjançant SSH."
  },
  {
    "objectID": "exercises/03-fs/09-ex-week6.html",
    "href": "exercises/03-fs/09-ex-week6.html",
    "title": "Administrant RAIDs",
    "section": "",
    "text": "Dos discs durs virtuals de 20 GB cadascun per la configuració del RAID1.\nImatge iso basada en Alma Linux.\nUn software de virtualització com VirtualBox, VMware, UTM o QEMU.\n\n\n\n\nConfigurar un RAID1 per la partició root (/) durant la instal·lació d’Alma Linux.\n\n\n\n\nInicieu la instal·lació d’Alma Linux fins a la pantalla de selecció de discs.\n\nSeleccioneu els dos discs virtuals i trieu l’opció Personalitzat.\n\nFeu clic a Fet.\n\nApareixerà la finestra de particions manuals:\n\nLes particions creades seran:\n\n/boot/efi – 600 MB\n\n/boot – 1 GB\n\nswap – 2 GB\n\n/ – 16,4 GB\n\nPer configurar el RAID1, seleccioneu la partició / i feu clic a Editar.\n\n\nTrieu RAID1 com a tipus de dispositiu.\n\nFeu clic a Fet → Acceptar canvis.\n\n\n\n\n\n\n\nUn cop finalitzada la instal·lació, el sistema es reiniciarà.\n\nSi tot és correcte, Alma Linux arrencarà sense problemes.\n\nObserveu que tenim dues particions / (una per disc).\n\n\n\n\n\n\n\nAlertaQuè passa si el disc vda falla?\n\n\n\nEn cas de fallada del disc vda, el sistema no arrencarà perquè la partició /boot no està replicada en RAID. Tenim replicada només la partició /. Per tant, si el disc vda falla, el sistema no podrà accedir a la partició /boot i no podrà arrencar."
  },
  {
    "objectID": "exercises/03-fs/09-ex-week6.html#installació-dun-raid1-a-alma-linux",
    "href": "exercises/03-fs/09-ex-week6.html#installació-dun-raid1-a-alma-linux",
    "title": "Administrant RAIDs",
    "section": "",
    "text": "Dos discs durs virtuals de 20 GB cadascun per la configuració del RAID1.\nImatge iso basada en Alma Linux.\nUn software de virtualització com VirtualBox, VMware, UTM o QEMU.\n\n\n\n\nConfigurar un RAID1 per la partició root (/) durant la instal·lació d’Alma Linux.\n\n\n\n\nInicieu la instal·lació d’Alma Linux fins a la pantalla de selecció de discs.\n\nSeleccioneu els dos discs virtuals i trieu l’opció Personalitzat.\n\nFeu clic a Fet.\n\nApareixerà la finestra de particions manuals:\n\nLes particions creades seran:\n\n/boot/efi – 600 MB\n\n/boot – 1 GB\n\nswap – 2 GB\n\n/ – 16,4 GB\n\nPer configurar el RAID1, seleccioneu la partició / i feu clic a Editar.\n\n\nTrieu RAID1 com a tipus de dispositiu.\n\nFeu clic a Fet → Acceptar canvis.\n\n\n\n\n\n\n\nUn cop finalitzada la instal·lació, el sistema es reiniciarà.\n\nSi tot és correcte, Alma Linux arrencarà sense problemes.\n\nObserveu que tenim dues particions / (una per disc).\n\n\n\n\n\n\n\nAlertaQuè passa si el disc vda falla?\n\n\n\nEn cas de fallada del disc vda, el sistema no arrencarà perquè la partició /boot no està replicada en RAID. Tenim replicada només la partició /. Per tant, si el disc vda falla, el sistema no podrà accedir a la partició /boot i no podrà arrencar."
  },
  {
    "objectID": "exercises/03-fs/09-ex-week6.html#migració-de-la-carpeta-home-a-un-raid5",
    "href": "exercises/03-fs/09-ex-week6.html#migració-de-la-carpeta-home-a-un-raid5",
    "title": "Administrant RAIDs",
    "section": "Migració de la carpeta /home a un RAID5",
    "text": "Migració de la carpeta /home a un RAID5\n\n🧰 Requisits\nEn la màquina virtual anterior, podem afegir quatre discs durs virtuals de 1 GB cadascun (vdc, vdd, vde, vdf).\n\n\n🎯 Objectiu\nMigrar el contingut de la carpeta /home a un dispositiu RAID5 format per quatre discs virtuals.\n\n\n🪛 Procediment\n\nCreem el RAID5 amb la comanda següent:\nmdadm --create --verbose /dev/md0 --level=5 --raid-devices=4 /dev/vd[c-f]\nComprovem que el RAID s’ha creat correctament amb la comanda:\ncat /proc/mdstat\nCreem un sistema de fitxers XFS en el dispositiu RAID5:\nmkfs.xfs /dev/md0\nMuntarem el dispositiu RAID5 en un directori temporal:\nmkdir /mnt/raid\nmount /dev/md0 /mnt/raid\nCopiem el contingut de la carpeta /home al dispositiu RAID5:\ncp -r /home/* /mnt/raid\nDesmuntem el dispositiu RAID5 del directori temporal:\numount /mnt/raid\nMuntarem el dispositiu RAID5 en la carpeta /home:\nmount /dev/md0 /home\nObtenim el UUID del dispositiu RAID5 amb la comanda:\nblkid /dev/md0\nFem una còpia de seguretat del fitxer /etc/fstab:\n```bash\nPer fer que el muntatge sigui permanent, afegim la següent línia al fitxer /etc/fstab:\nUUID=&lt;UUID&gt;  /home  xfs  defaults  0 0\n\n\n\n✅ Resultat final\n\nEl contingut de la carpeta /home s’ha migrat correctament al dispositiu RAID5.\n\nEl sistema utilitza ara el RAID5 per emmagatzemar les dades dels usuaris"
  },
  {
    "objectID": "exercises/03-fs/09-ex-week6.html#simulació-de-fallades-en-el-raid5",
    "href": "exercises/03-fs/09-ex-week6.html#simulació-de-fallades-en-el-raid5",
    "title": "Administrant RAIDs",
    "section": "Simulació de fallades en el RAID5",
    "text": "Simulació de fallades en el RAID5\nAra simularem una fallada en un dels discs durs virtuals del RAID5. I observarem com el sistema continua funcionant sense problemes.\n\nCrearem un usuari de prova i un fitxer de text a la seva carpeta /home:\nuseradd test\necho \"Hola món\" &gt; /home/test/hola.txt\nchown -R test:test /home/test\nSimulem la fallada d’un disc dur virtual del RAID5:\nmdadm --manage /dev/md127 --fail /dev/vdc\nComprovem que podem accedir al fitxer de text creat anteriorment:\ncat /home/test/hola.txt\nAra intentarem simular la fallada d’un segon disc dur virtual del RAID5:\nmdadm --manage /dev/md127 --fail /dev/vdd\nComprovem que el sistema ens avisa que no es pot fallar un segon disc perquè el RAID5 només tolera la fallada d’un disc:\nmdadm: Cannot remove /dev/vdd from /dev/md0,\n       array will be failed."
  },
  {
    "objectID": "exercises/03-fs/09-ex-week6.html#exercicis",
    "href": "exercises/03-fs/09-ex-week6.html#exercicis",
    "title": "Administrant RAIDs",
    "section": "Exercicis",
    "text": "Exercicis\nEs demana instal·lar un sistema AlmaLinux de forma tradicional sense RAID en un disc virtual de 20 GB (vda), creant les quatre particions habituals: /boot/efi, /boot, swap i /.\nUn cop finalitzada la instal·lació:\n\nAfegiu dos discs durs virtuals addicionals de 20 GB cadascun (vdb i vdc).\nMigrar les particions existents a RAID1 de la següent manera:\n\n/boot/efi → RAID1 amb vdb1 i vdc1.\n/boot → RAID1 amb vdb2 i vdc2.\nswap → RAID1 amb vdb3 i vdc3.\n/ → RAID1 amb vdb4 i vdc4.\n\nConfigureu el sistema perquè arranqui correctament des dels discs vdb i vdc.\nUn cop comprovat el correcte funcionament, elimineu el disc original vda.\nVerificar que el sistema arranca correctament després de la migració.\nConfirmar que totes les particions es troben en RAID1.\nDocumentar tot el procés amb captures de pantalla, explicacions detallades i justificacions tècniques en un informe final."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "AMSA: Administration and Maintenance of Systems and Applications",
    "section": "",
    "text": "Welcome to the AWS (Amazon Web Services) lab. This lab is designed to provide the knowledge and skills necessary to manage and maintain computer systems in professional environments.\n\n\n\nCourse Title\nSystems and Applications Administration and Management\n\n\nSemester\n1st Semester of the Bachelor’s Degree in Computer Engineering\n\n\nCourse Year\nThird Year\n\n\nProfessor\nFrancesc Solsona\n\n\nSchool\n\n\n\nUniversity\n\n\n\nDepartment"
  },
  {
    "objectID": "laboratories/02-network/01-aws-wordpress.html",
    "href": "laboratories/02-network/01-aws-wordpress.html",
    "title": "Deployment a high-availability web application",
    "section": "",
    "text": "ARCHITECTURE\nIn this lab, we will design and implement a robust and secure network architecture to host a WordPress application. The architecture is based on the use of 2 Availability Zones (AZ) located in 1 Region to ensure that our WordPress is highly available and fault-tolerant.\nThe image shows how, through the internet, users access the Load Balancer, which distributes traffic to the EC2 instances hosting WordPress. These instances connect to the RDS database to manage WordPress content. The EC2 instance in the DMZ allows secure access for the administration of private resources\nComponents:",
    "crumbs": [
      "3 · Deployment of a high-availability web application"
    ]
  },
  {
    "objectID": "laboratories/02-network/01-aws-wordpress.html#vpc-and-subnets",
    "href": "laboratories/02-network/01-aws-wordpress.html#vpc-and-subnets",
    "title": "Deployment a high-availability web application",
    "section": "1. VPC and Subnets",
    "text": "1. VPC and Subnets\nThe first step in our architecture is to define a VPC (Virtual Private Cloud) and the necessary subnets to isolate the different components of the application. The VPC will provide a virtualized network environment where we can deploy our AWS resources. We will configure it with the network 10.0.0.0/16, which gives us up to 65,536 IP addresses, more than enough for our use case.\n\n\n\n\n\n\nNoteCIDR, Hosts and Reserved Adresses 🧠\n\n\n\nThe subnet mask determines the number of IP addresses available within a network or subnet. This is expressed using CIDR notation (Classless Inter-Domain Routing), where the value (/n) indicates the number of bits reserved for the Network portion. A subnet mask of /16 means that the first 16 bits of the IP address are reserved for network identification, leaving the other 16 bits for host identification. This allows up to 65,536 IP addresses (\\(2^{32-16}\\)) within that network.\nWhen you perform subnetting to create subnets within your VPC, you increase the CIDR value (for example, from /16 to /24) to reduce the size of the subnets and better isolate traffic. For example, a subnet with CIDR /24 has 256 IP addresses (\\(2^{32-24}\\)).\nRemember that the total calculated addresses are not the total usable addresses for your servers (hosts). Some addresses are reserved for special uses, such as network identification and broadcast.\n\n\nWe can define the VPC through the AWS web interface, using the available forms:\n\n\n\nVPC definition\n\n\n\n1.2. Creating the Subnets\nAdd the necessary subnets for our architecture. Go to VPC → Subnets → Create subnet. Select the VPC we just created and add the following subnets:\n\nAMSA-DMZ-01: Public subnet in the zone us-east-1a. This subnet will host the EC2 instance that will serve as a secure access bridge (via SSH tunnel) for managing all private resources. (10.0.1.0/24).\n\n\n\n\nAMSA-DMZ-01\n\n\n\nAMSA-DMZ-02: Public subnet in the zone us-east-1b. This subnet will host the EC2 instance that will serve as a secure access bridge (via SSH tunnel) for managing all private resources. (10.0.2.0/24).\n\n\n\n\nAMSA-DMZ-02\n\n\n\nAMSA-Private01: Private subnet for the WordPress instances in the availability zone us-east-1a. (10.0.3.0/24).\n\n\n\n\nAMSA-Private01\n\n\n\nAMSA-Private02: Private subnet for the WordPress instances in the availability zone us-east-1b. (10.0.4.0/24)\n\n\n\n\nAMSA-Private02\n\n\n\nAMSA-Data: Private subnet for the WordPress instances in the availability zone us-east-1c. (10.0.5.0/24)\n\n\n\n\nAMSA-Data",
    "crumbs": [
      "3 · Deployment of a high-availability web application"
    ]
  },
  {
    "objectID": "laboratories/02-network/01-aws-wordpress.html#routing-tables-and-associations",
    "href": "laboratories/02-network/01-aws-wordpress.html#routing-tables-and-associations",
    "title": "Deployment a high-availability web application",
    "section": "2. Routing Tables and Associations",
    "text": "2. Routing Tables and Associations\nTo manage traffic routes and determine how it is distributed among the subnets, we will create route tables and associate them with the corresponding subnets..\n\n2.1. Internet Gateway Configuration\nWe will use an Internet Gateway (IGW) to allow the public subnets (AMSA-DMZ-01 and AMSA-DMZ-02) to have both inbound and outbound Internet access. To do this, we will first create the IGW and then associate it with our VPC.\nThe first step is to create the Internet Gateway. Go to VPC → Internet Gateways → Create internet gateway. Once created, name it AMSA-IG.\n\n\n\nInternet Gateway for the VPC\n\n\nThe second step is to associate the Internet Gateway with the VPC. Select the Internet Gateway we just created and click on Actions → Attach to VPC. Select the VPC AMSA-VPC and click on Attach internet gateway.\n\n\n\nAssociation of the Internet Gateway with the VPC\n\n\n\n\n\nAssociation of the Internet Gateway with the VPC\n\n\n\n\n\n\n\n\nWarningAttached IGW 🛑\n\n\n\nMake sure the Internet Gateway is correctly associated with the VPC. If it is not associated, the public subnets will not be able to access the Internet.\n\n\n\n\n2.2. Creation of Routing Tables\nEach subnet needs a route table to define how inbound and outbound traffic is directed. We will create specific route tables for each type of subnet (public and private) and associate them with the corresponding subnets.\n\n2.2.1. Routing for public subnets (DMZ)\nThe first step is to create the route table for the public subnets. Go to VPC → Route Tables → Create route table. Select VPC AMSA-VPC and name the route table AMSA-DMZ01-RT.\n\n\n\nRoute table for the subnet AMSA-DMZ01-RT\n\n\nThe second step is to associate the route table (AMSA-DMZ01-RT) with the subnet AMSA-DMZ-01 allow outbound traffic to the Internet through the Internet Gateway we created earlier.\n\n\n\nAssociation of the route table with the subnet AMSA-DMZ-01\n\n\nThe third step is to allow outbound traffic to the Internet through the Internet Gateway we created earlier. To do this, go to the section Routes and click on Edit routes. Next, Add route and edit (Destination: 0.0.0.0/0; Target:Seleccionar el AMSA-IG).\n\n\n\nAllowing traffic with the outside through the IG\n\n\n\n\n\n\n\n\nWarningAMSA-DMZ-02 🛑\n\n\n\nPerform the same steps for the subnet AMSA-DMZ-02, modifying only the name of the route table and the association with the subnet.\n\n\n\n\n2.2.2. Routing for private subnets\nPrivate subnets do not have direct access to the Internet for security reasons. Therefore, we need to configure the route tables for these subnets so that they can access the Internet through a NAT Gateway (Network Address Translation Gateway). This will allow instances within the private subnets to initiate outbound connections, but prevent external sources from initiating connections to them.\n\n\n\n\n\n\nNoteNAT Gateway 🧠\n\n\n\nA NAT Gateway is a managed service by AWS that allows instances in a private subnet to access the Internet for software updates, package downloads, etc., without exposing those instances directly to the Internet. The NAT Gateway translates the private IP addresses of the instances into a public IP address when those instances make requests to the Internet.\n\n\nTo create the NAT Gateway, we need an Elastic IP. Therefore, we will first create an Elastic IP and then use it to create the NAT Gateway. Name it AMSA-NAT-EIP.\n\n\n\nCreating the Elastic IP\n\n\n\n\n\nUpdate the name of the Elastic IP\n\n\nOnce we have the Elastic IP, we can create the NAT Gateway. Name it AMSA-NG and associate it with the subnet AMSA-DMZ-01.\n\n\n\nCreating the NAT Gateway\n\n\nCreate the route table (AMSA-Private01-RT) for the subnet AMSA-Private01 and we will associate it with the subnet. This route table will allow the instances within this subnet to access the Internet through the NAT Gateway.\n\n\n\nRoute table for the subnet AMSA-Private01\n\n\nThe second step is to associate the route table (AMSA-Private01-RT) with the subnet AMSA-Private01 and allow outbound traffic to the Internet through the NAT Gateway we created earlier.\n\n\n\nCreating the route table for the subnet AMSA-Private01\n\n\nThe third step is to allow outbound traffic to the Internet through the NAT Gateway we created earlier. To do this, go to the section Routes and click on Edit routes. Next, Add route and edit (Destination: 0.0.0.0/0; Target:Select AMSA-NG).\n\n\n\n\n\n\nWarningAMSA-Private02 🛑\n\n\n\nRepeat the same steps for the subnet AMSA-Private02, modifying only the name of the route table and the association with the subnet.\n\n\n\n\n2.2.3. Routing for the data subnet (AMSA-Data)\nThe subnet AMSA-Data will not host instances that require Internet access. Therefore, we do not need to configure any route for this subnet. We will create an empty route table and associate it with the subnet AMSA-Data. This network will be completely isolated and will only allow internal communication within the VPC.",
    "crumbs": [
      "3 · Deployment of a high-availability web application"
    ]
  },
  {
    "objectID": "laboratories/02-network/01-aws-wordpress.html#security-groups",
    "href": "laboratories/02-network/01-aws-wordpress.html#security-groups",
    "title": "Deployment a high-availability web application",
    "section": "3. Security Groups",
    "text": "3. Security Groups\nSecurity Groups are a tool for controlling network traffic for instances and other AWS resources, acting as a virtual firewall. They allow defining rules that specify which connections are allowed for both inbound and outbound traffic\n\nTrafic inbound: It allows you to decide which types of incoming connections (to the resource) are permitted.\nTrafic outbound: Control which outbound connections (from the resource to other destinations) are authorized.\n\n\n3.1. Security Group for EC2 instances\n\nInbound connections for web services HTTP (port 80) and HTTPS (port 443), accessible from any origin.\nSSH conections (port 22) for remote administration, also accessible from any origin (initially, but later they will be restricted).\nAll outbound connections (outbound). By default, they are allowed in AWS, which enables EC2 instances to communicate with other resources such as RDS.\n\nTo do this, we will navigate to the AWS VPC console, select the Security Groups section, and click Create security group. Next, we will fill in the fields with the necessary information and click Create security group. You can name it AMSA-WP-SG.\n\n\n\nSecurity Group for EC2 instances\n\n\n\n\n\n\n\n\nNoteSecurity note 🔐\n\n\n\nNow we allow all network traffic for web services and SSH. Once everything is configured, we will restrict this access only to inbound traffic coming from the load balancer for web services and from our internal network for SSH.\n\n\n\n\n3.2. Security Group for the database RDS\n\nInbound connections: t will only allow traffic on port 3306 (MySQL) and exclusively from EC2 instances that belong to the security group AMSA-WP-SG.\nOutbound connections: By default, AWS will allow all outbound connections, which ensures that the database can communicate with other resources if necessary.\n\nTo do this, we will navigate to the AWS VPC console, select the Security Groups section, and click Create security group. Next, we will fill in the fields with the necessary information and click Create security group.\n\n\n\nSecurity Group for the database RDS\n\n\n\n\n3.3. Summary\n\n\n\n\n\n\n\n\nSecurity Group\nInbound\nOutbound\n\n\n\n\nAMSA-WP-SG\nHTTP (80) and HTTPS (443) from 0.0.0.0/0; SSH (22) from 0.0.0.0/0\nAll allowed\n\n\nAMSA-DB-SG\nMySQL (3306) from AMSA-Web-SG\nAll allowed",
    "crumbs": [
      "3 · Deployment of a high-availability web application"
    ]
  },
  {
    "objectID": "laboratories/02-network/01-aws-wordpress.html#creation-of-the-rds-database",
    "href": "laboratories/02-network/01-aws-wordpress.html#creation-of-the-rds-database",
    "title": "Deployment a high-availability web application",
    "section": "4. Creation of the RDS Database",
    "text": "4. Creation of the RDS Database\nWe already configured the database in the previous lab Deploying a web application with AWS. The only difference is that now the database is located in a private subnet and is only accessible from EC2 instances that belong to the security group AMSA-Web-SG.\n\nCompute resources: Don’t connect to an EC2 compute resource\nVPC: AMSA-VPC\nSubnet Group: Create new DB Subnet Group\nPublic accessibility: No\nVPC security group: AMSA-DB-SG\nAvailability Zone: us-east-1d",
    "crumbs": [
      "3 · Deployment of a high-availability web application"
    ]
  },
  {
    "objectID": "laboratories/02-network/01-aws-wordpress.html#creation-of-ec2-instances-and-web-server-configuration-with-wordpress",
    "href": "laboratories/02-network/01-aws-wordpress.html#creation-of-ec2-instances-and-web-server-configuration-with-wordpress",
    "title": "Deployment a high-availability web application",
    "section": "5. Creation of EC2 instances and Web Server Configuration with WordPress",
    "text": "5. Creation of EC2 instances and Web Server Configuration with WordPress\nThe EC2 instances that will host WordPress will be deployed in private subnets. AWS allows us to create instance templates (Launch Templates) that make it easier to create instances with a predefined configuration. Therefore, we will create an instance template that includes the necessary configuration for our WordPress EC2 instances.\n\nCreate an EC2 instance with Amazon Linux, selecting the VPC AMSA-VPC and the subnet AMSA-DMZ-01. Make sure that the instance uses the security group AMSA-WP-SG. You can name it AMSA-DB-Config. Select assign public IP. We will only use this instance to initialize the database and then we can delete it.\nOnce the instance is configured, connect to it via SSH using the private key corresponding to the public key you associated with the instance during its creation. Then configure the MySQL database for WordPress.\nLet’s create a launch template (Launch Template) for the EC2 instances that will host WordPress. This template will include the necessary configuration for the instances, including the installation and configuration script for WordPress.\n\nTemplate name: AMSA-WP-Template\nAMI: Amazon Linux 2023 (64-bit x86)\nInstance Type: t2.micro\nKey Pair: AMSA-KEY\nSubnet: Do not select any subnet (it will be selected dynamically\nSecurity group: AMSA-WP-SG\nAdvanced Details: Add the following script to the User Data section.\n\n\n\n\n\n\n\n\nNoteWordPress installation and configuration script 📝\n\n\n\nModify the database connection details according to your own data.\n#!/bin/bash\n# sudo bash install_wp.sh\n\n# Adjust the following data according to your own details\nDB_NAME=\"\" \nDB_USER=\"\"\nDB_USER_PASSWORD=\"\"\nDB_HOST=\"\" \n\nif [ \"$(id -u)\" -ne 0 ]; then\n    echo \"Please run this script with sudo or as root.\"\n    exit 1\nfi\n\ndnf install -y wget php-mysqlnd httpd php-fpm php-mysqli php-json php php-devel php-gd expect\n\ncd /tmp\nwget https://wordpress.org/latest.tar.gz\ntar -xzf latest.tar.gz\n\n# Configure WordPress\ncp wordpress/wp-config-sample.php wordpress/wp-config.php\nsed -i \"s/database_name_here/$DB_NAME/g\" wordpress/wp-config.php\nsed -i \"s/username_here/$DB_USER/g\" wordpress/wp-config.php\nsed -i \"s/password_here/$DB_USER_PASSWORD/g\" wordpress/wp-config.php\nsed -i \"s/localhost/$DB_HOST/g\" wordpress/wp-config.php\n\nsudo cp -r wordpress/* /var/www/html/\n\nsudo sed -i 's/AllowOverride None/AllowOverride All/g' /etc/httpd/conf/httpd.conf\n\nsudo chown -R apache:apache /var/www\nsudo chmod 2775 /var/www\n\nsudo systemctl restart httpd\n\n\nOnce the launch template is created, you can use it to create EC2 instances with WordPress already configured and ready to connect to your RDS database. Go to EC2 and select Launch Instance. Then select the launch template AMSA-WP-Template and configure the remaining parameters according to your needs.\n\nNumber of instances: 2\nSubnet: Select the subnet AMSA-Private01 for the first instance and AMSA-Private02 for the second instance. You can name them AMSA-WP-01 i AMSA-WP-02 respectively.\n\n\n\n\n\n\n\nImportantNote about EC2 instances 🖥️\n\n\n\nThese instances will not have a public IP, as they will only be accessible through the load balancer that we will configure later. For now, you will not be able to access them directly via SSH or HTTP.",
    "crumbs": [
      "3 · Deployment of a high-availability web application"
    ]
  },
  {
    "objectID": "laboratories/02-network/01-aws-wordpress.html#load-balancer-configuration",
    "href": "laboratories/02-network/01-aws-wordpress.html#load-balancer-configuration",
    "title": "Deployment a high-availability web application",
    "section": "6. Load Balancer Configuration",
    "text": "6. Load Balancer Configuration\nAt this point, we will create a load balancer for our EC2 instances. This load balancer will be responsible for evenly distributing traffic among the EC2 instances hosting WordPress.\nThere are 3 types of load balancers in AWS: Application Load Balancer (ALB), Network Load Balancer (NLB) and Gateway Load Balancer (GWLB). In this case, we will use an Application Load Balancer (ALB), as it is recommended for web applications that use HTTP and HTTPS.\nNavigate to the AWS console and select the EC2 service. In the sidebar, select Load Balancers and then Create Load Balancer. Choose Application Load Balancer and click Create.\n\nLoad Balancer name: AMSA-ALB\nScheme: Internet-facing\nIP Address Type: IPv4\n\n\n\n\nLoad Balancer Configuration\n\n\n\nVPC: AMSA-VPC\nAvailability Zones: Select the availability zones where we have the public subnet AMSA-DMZ-01 (us-east-1a) and AMSA-DMZ-02 (us-east-1b).\nSecurity Groups: New security group (AMSA-ALB-SG), this security group will allow inbound traffic for ports 80 (HTTP) and 443 (HTTPS) from any source but will restrict outbound traffic to the EC2 instances (security group AMSA-WP-SG).\n\n\n\nSecurity Group for the Load Balancer\n\n\n\n\n\nLoad balancer configuration\n\n\nListeners: Create a listener for port 80 (HTTP), which will redirect traffic to port 80 of the EC2 instances. For port 443 (HTTPS), we will not configure any redirection for now. To do this, you must first create a Target Group. This group is necessary to indicate to the load balancer where to send the traffic.\n\nTarget Group:\n\nTarget Type: Instances\nNom: AMSA-WP-TG\nProtocol: HTTP\nPort: 80\nVPC: AMSA-VPC\nHealth checks: HTTP, ruta /\n\n\n\n\nTarget group configuration\n\n\n\n\n\n\n\n\n\n\nNoteHealth Check 🎯\n\n\n\nThe load balancer checks the health of the EC2 instances through port 80 and the path /. This means that the load balancer will send traffic to EC2 instances that respond correctly to HTTP requests on the / path. Since our EC2 instances have WordPress installed, these instances will respond correctly to HTTP requests on the / path. We can leave the default configuration. The WordPress installation includes a home page that will respond with 302 (Found) when accessing the root path (/), which is why the health check may show that the instance is unhealthy. Once WordPress is configured, the health check will show that the instance is healthy.\n\n\n\nSelect the two EC2 instances that host WordPress (AMSA-WP-01 and AMSA-WP-02) and add them to the target group using the Include as pending below button and then Add to registered.\n\n\n\nTarget group configuration\n\n\nOnce the target group has been created, we will select it as the target for the load balancer’s listener.\n\n\n\nLoad balancer configuration\n\n\nOnce the load balancer has been created, you must wait a few minutes until its status changes from Provisioning to Active. Once the status change to Active, you can access the load balancer through its DNS address\n\n\n\n\nActive load balancer\n\n\n\nNow we can access the load balancer through its DNS address and see the WordPress installation page:\n\n\n\n\nWordPress installation through the load balancer\n\n\nWe will proceed to install WordPress through the load balancer. Follow the installation steps and configure the administrator username and password. Now you have the web server configured with WordPress and the load balancer to distribute traffic between the EC2 instances.",
    "crumbs": [
      "3 · Deployment of a high-availability web application"
    ]
  },
  {
    "objectID": "laboratories/02-network/01-aws-wordpress.html#vpn-configuration",
    "href": "laboratories/02-network/01-aws-wordpress.html#vpn-configuration",
    "title": "Deployment a high-availability web application",
    "section": "7. VPN configuration",
    "text": "7. VPN configuration\n\n7.1.Create an EC2 to deploy the VPN server\nTo deploy the VPN server, we will create a new EC2 instance that will act as the VPN server. This EC2 instance must be in a public subnet connected to the internet. We will name this instance AMSA-VPN and place it in the public subnet AMSA-DMZ-01. This EC2 instance will use the security group AMSA-VPN-SG, which will allow the necessary traffic for the VPN server to function.\n\nNavigate to the AWS console and select the EC2 service. In the sidebar, select Instances and then Launch Instances.\nSelect the image Ubuntu Server 22.04 LTS.\nSelect the instance t2.micro.\nConfigure the instance:\n\nNetwork: AMSA-VPC\nSubnet: AMSA-DMZ-01\nAuto-assign Public IP: Enable\n\n\n\n\nEC2 instance configuration for the VPN server\n\n\nConfigure the security group: AMSA-VPN-SG.\n\nIf you review the installation documentation for the OpenVPN server: OpenVPN: OpenVPN Access Server System Administrator Guide, you will see that we need the following ports open: TCP 943, UDP 1194.\n![Security group configuration for the VPN server](../../figs/laboratories/03-aws-wp/wordpress/AMSA-SG-VPN.png)\n\nConnect to the EC2 instance through the AWS online console or with an SSH connection and run the following command to install the OpenVPN server:\nsudo apt update -y\nsudo apt install ca-certificates gnupg wget net-tools -y\nsudo wget https://as-repository.openvpn.net/as-repo-public.asc -qO /etc/apt/trusted.gpg.d/as-repo-public.asc\nsudo echo \"deb [arch=amd64 signed-by=/etc/apt/trusted.gpg.d/as-repo-public.asc] http://as-repository.openvpn.net/as/debian jammy main\" | sudo tee /etc/apt/sources.list.d/openvpn-as-repo.list\nsudo apt update && sudo apt install openvpn-as -y\n\n\n\nOpenVPN server installation\n\n\nWith these credentials, you will be able to access the OpenVPN server’s web interface through your web browser. Navigate to the public IP of the EC2 instance (in my case https://44.199.196.242:943/admin). Since we don’t have the SSL certificate configured, a warning message will appear—ignore it and continue. Log in with the credentials you configured earlier..\n\nNote: If you have lost the openvpn user credentials, you can recover them by checking the OpenVPN server log file. For example, you can view the log file with the following command:\nsudo less /usr/local/openvpn_as/init.log \n\n\n\n\nOpenVPN server web interface\n\n\n\nAccept the license terms..\n\n\n\n\nAccepting the license terms.\n\n\n\nGo to VPN Server/Network Settings and set the Hostname or IP Address to the public IP of the EC2 instance where your OpenVPN server is running. Once done, click Save.\n\n\n\nConfiguring the VPN Server’s Public IP\n\n\nGo to Access Controls/Internet Access and DNS and select the Split Tunnel option to prevent all client traffic from being redirected through the VPN. Only traffic destined for the VPC subnets will be routed through the VPN.\n\n\n\nConfiguring Split Tunnel\n\n\nGo to Access Controls/Global Access Rules and add a rule to allow VPN traffic to the VPC subnets:\n\n\n\nConfiguring Global Access Rules\n\n\nGo to User and create a username and password to connect to the VPN server.\n\n\n\nCreating a VPN Server User\n\n\nOnce you have the configuration file, you can Restart the OpenVPN service to apply all changes. Then, access the OpenVPN server web interface again.\nGo to User/user/Connection Profiles and create a default connection profile. Once created, a configuration file will be downloaded, which we will later use to connect to the VPN server.\n\n\n\nDownloading the VPN client configuration file\n\n\nInstall the OpenVPN Connect application on your computer. This application is the VPN client we will use to connect to the VPN server.\nOnce installed, open the application and import the configuration file you downloaded earlier.\n\nOnce everything is configured, we will update the security group of the EC2 instances to allow traffic on port 22 only from the VPN server. This means that the EC2 instances will only accept SSH traffic from the VPN server and not from any other source.\n\n\n\nConfiguring SSH traffic to EC2 from the VPN server.\n\n\n\nAt this point, you will no longer be able to access the EC2 instances running the WordPress service via SSH, since SSH traffic is only allowed from the VPN server. To access the EC2 instances, you must first connect to the VPN server and then connect to the EC2 instances. To do this:\n\nImport the OpenVPN Connect client configuration file into the application and connect to the VPN server.\n\n\n\nConnecting to the VPN Server\n\n\n\nTroubleShooting: If you see in the configuration file (Server Hostname) an IP in the range 10.0.X.X, this means that the VPN has not been configured correctly. Make sure to restart the server and download the client configuration file again; it must include the VPN server’s public IP address.\n\nUse the same password as the user openvpn to connect to the VPN server.\n\n\n\nConnection to the VPN server\n\n\nIf everything went well, you will see that you are connected to the VPN server.\n\n\n\nConnection to the VPN server\n\n\n\nFinally, connect to the EC2 instances:\n\n\n\nAccess to EC2 instances through the VPN server\n\n\n\nImportant considerations: The VPN server allows us to access the EC2 instances via SSH, but using the internal address (10.0.X.X) of the EC2 instance. We will not be able to access the EC2 instances through their public address because we have configured the VPN to access the VPC subnets.",
    "crumbs": [
      "3 · Deployment of a high-availability web application"
    ]
  },
  {
    "objectID": "laboratories/02-network/01-aws-wordpress.html#cleanup",
    "href": "laboratories/02-network/01-aws-wordpress.html#cleanup",
    "title": "Deployment a high-availability web application",
    "section": "8. Cleanup",
    "text": "8. Cleanup\nOnce completed, you can delete all EC2 instances and the RDS database to avoid unnecessary charges to your AWS account.",
    "crumbs": [
      "3 · Deployment of a high-availability web application"
    ]
  },
  {
    "objectID": "laboratories/01-foundations/02-aws-wordpress.html",
    "href": "laboratories/01-foundations/02-aws-wordpress.html",
    "title": "Deploying a web application",
    "section": "",
    "text": "ARCHITECTURE\nCONTENTS:",
    "crumbs": [
      "2 · Deploying a web application"
    ]
  },
  {
    "objectID": "laboratories/01-foundations/02-aws-wordpress.html#creating-a-data-base-db-with-rds",
    "href": "laboratories/01-foundations/02-aws-wordpress.html#creating-a-data-base-db-with-rds",
    "title": "Deploying a web application",
    "section": "1. Creating a Data Base (DB) with RDS",
    "text": "1. Creating a Data Base (DB) with RDS\nAWS’ relational database service (RDS) is a very interesting option for deploying MySQL, MariaDB, PostgreSQL, Oracle, SQL Server, and Aurora databases. This service offers easy and efficient database management, as well as the ability to perform backups, scalability, and high availability.\n\nLet’s go to the dashboard of Aurora and RDS.\nIn the Aurora and RDS dashboard, click on Create a database\n\nChoose a database creation method Full configuration\nSelect data base engine MySQL\nSelect the data base version MySQL 8.0.43\nSelect the template Sandbox\nSelect Single-AZ DB instance deployment (1 instance)\nDB instance identifier wordpress-db\nMaster username admin\nCredential management: self-managed\nSet the password (Lleida2030!!). Type a password for the master and confirm it. Be sure to save this password—you’ll need it later.\nLeave the rest of the parameters as default. Once finished, click Create database.\n\nWait a few minutes until the column Status turns green and says Available. The database creation process may take some time.\nOnce the database is available, click on the database and go to the tab Connectivity & security to view the connection details.\n\nDB identifier: wordpress-db\nEndpoint (similar to): wordpress-db.cp66aquygfg3.us-east-1.rds.amazonaws.com\nPort: 3306\n\nSave Endpoint (this is the Hostname of the DB). It will be used later.\nTo test the connection, we need a MySQL client. The easiest way is to create an EC2 instance and install the MySQL client.\n5.1. Create an EC2 instance with Amazon Linux 2023\n\nGo to the EC2 dashboard. You can do this by typing EC2 into the search bar and clicking on the EC2 service:\n\n\n\n\nAWS Dashboard\n\n\n\nOnce you’re on the EC2 dashboard, you can import a Key pair (aws-keypair) created previously.\nNext, click on Instances &gt; Launch Instances, as shown below:\n\n\n\n\nEC2 Dashboard\n\n\n\nEnter a (EC2) name: AMSA\nLeave everything as it is except Key pair name : If you have created a private key pair (as aws-keypair in the figure), select it, else select vockey. Then click Launch instance.\n\n\n\n\nEC2 Dashboard\n\n\nWe now have a running EC2 instance. This means we have a remote virtual machine on AWS that we can connect to from the EC2 dashboard or from our local computer using SSH (explained in ).\nLet’s see how to access from the EC2 dashboard.\n5.2. Connect to the EC2 instance\nGo to the EC2 dashboard. Select the EC2 instance just created: AMSA click on Connect, select Connect using a Public IP and then click Connect again.\nYou will access a terminal on the EC2 instance you created, logged in as ec2-user, as shown below::\n\nAlternatively, you may access the EC2 instance through an SSH connection from a local console, as shown below:\ncd   # we suppose the .ssh directory is located in the home of the user francesc\nssh -i .ssh/aws-keypair ec2-user@&lt;public-ip&gt;\nTo get the public-ip, Go to the EC2 dashboard and click Instances. Then click the AMSA EC2 instance. Copy the public-ip.\n5.3. Install the MySQL client:\n# Search for the package to install\ndnf search mysql\n# Let’s install the MariaDB client\nsudo dnf install mariadb105 -y\nAdd a rule to the Security Group of the database to allow connections from the EC2 instance.\n6.1. Go to the dashboard of Aurora and RDS\n6.2. Click Databases and select our database instance (wordpress-db)\n6.3. In the section Connectivity & security, search for the Security Group associated with the database\n6.4. Click on the default security group  of type EC2 Security Group - Inbound to edit the rules (similar to default sg-0efc4051ab6288a2d). Click again in the same security group (default sg-0efc4051ab6288a2d) and then in Inboud rules, click on Edit Inboud rules:\n\n6.5. Click Delete the existing Inboud rule\n6.6. Add a new inbound rule to allow connections from the IP address of our EC2 instance. Click Add rule. Select the type MySQL/Aurora, Source type Custom and Source the default security group of the EC2 instance (similar to launch-wizard-1) to allow it to connect to the DB, like this:\nType: MySQL/Aurora\nProtocol: TCP\nPort Range: 3306\nSource: Custom\nSelect the security group of the EC2 instance (launch-wizard-1)\nClick Save rules\nConnect to the RDS database from the EC2 terminal:\nmysql -h hostname -u admin -p\n# Enter the admin password (created earlier) when prompted\nhostname is the database (Endpoint) saved earlier (wordpress-db.cp66aquygfg3.us-east-1.rds.amazonaws.com) and admin is the master user created earlier, along with its password. This is:\nmysql -h wordpress-db.cp66aquygfg3.us-east-1.rds.amazonaws.com -u admin -p\nEnter password: Lleida2030!!\nWhen entering MySQL, at the MySQL promtp (MySQL [(none)]&gt; ), create the database wordpressdb, user wordpressuser and password wordpresspasswd, with all permissions:\nCREATE DATABASE wordpressdb;\nCREATE USER 'wordpressuser'@'%' IDENTIFIED BY 'wordpresspasswd';\nGRANT ALL PRIVILEGES ON wordpressdb.* TO 'wordpressuser'@'%';\nFLUSH PRIVILEGES;\nexit\nWe already have the database ready for the WordPress installation",
    "crumbs": [
      "2 · Deploying a web application"
    ]
  },
  {
    "objectID": "laboratories/01-foundations/02-aws-wordpress.html#installing-wordpress-on-the-ec2-instance",
    "href": "laboratories/01-foundations/02-aws-wordpress.html#installing-wordpress-on-the-ec2-instance",
    "title": "Deploying a web application",
    "section": "2. Installing WordPress on the EC2 instance",
    "text": "2. Installing WordPress on the EC2 instance\n\nTo install WordPress, a web server (Apache) must be installed first in the EC2 instance:\nsudo dnf install httpd -y\nsudo systemctl start httpd\nsudo systemctl enable httpd\n\n\n\n\n\n\n\nTipNote\n\n\n\nNote that the start command start the Apache service, but it does not make it start automatically when the machine is rebooted. Therefore, we also need to run the enable command\n\n\n\nBy default, the security group of the EC2 instance does not allow HTTP connections (port 80). You can verify this by trying to access the public IP address of the EC2 instance from a web browser. Enter EC2, click Instances, choose the instance wordpress, copy the Public IPv4 address (i.e. 44.200.65.68). Insert http://44.200.65.68 in a browser. You will see that it cannot connect.\n\n\n\n\n\n\n\nTipNote\n\n\n\nIf you click the link to the public IP address, it will try to access via HTTPS, but since we don’t have an SSL certificate, it won’t work. Manually modify the URL to http://\n\n\n\nWe need to add an inbound rule to the security group to allow HTTP connections:\n\nGo to the EC2 dashboard\nSelect our EC2 instance\nIn the section of Security, click on the Security Group associated with the instance (sg-038f49ebd3fbe8b5a (launch-wizard-1)).\nAdd a new inbound rule to allow HTTP connections.\n\nClick Edit Inbound rules. Click Add rule. Insert the following:\nType: HTTP\nProtocol: TCP\nPort Range: 80\nSource: Anywhere-IPv4 (0.0.0.0/0)\nClick Save rules\n\n\n\n\n\n\n\n\n\nTipNote\n\n\n\nThis rule will allow HTTP connections from anywhere\n\n\n\nOnce the rule has been added, we can access the public IP address of the EC2 instance from the web browser and verify it:\nInsert http://44.200.65.68 in a browser. It will appear in the screen: It works!\nA requirement for WordPress is to have PHP installed. Let’s install PHP and the necessary extensions in the EC2 instance:\nsudo dnf install php8.1 -y\nsudo dnf install php-curl php-zip php-gd php-soap php-intl php-mysqlnd php-pdo -y\nRestart the Apache service to load the PHP extensions:\nsudo systemctl restart httpd\nNow we can install WordPress. First, we download the latest version of WordPress and save it to Apache’s default directory:\ncd /tmp\nwget https://wordpress.org/latest.tar.gz\ntar -xvzf latest.tar.gz\nsudo mv wordpress/* /var/www/html/\nsudo rm -rf wordpress latest.tar.gz\nsudo chown -R apache:apache /var/www/html/\nAccess the public IP address of the EC2 instance from your web browser (http://44.200.65.68). You should see the WordPress installation page\nFollow the steps of the WordPress installation:\n\nSelect the language (English)\nClick on Continue\nClick on Let’s go\nEnter the database connection details:\n\nDatabase Name: wordpressdb (created earlier in the MySQL console)\nUsername: wordpressuser (created earlier in the MySQL console)\nPassword: wordpresspasswd (created earlier in the MySQL console)\nDatabase Host: the RDS database endpoint (for example: wordpress-db.cp66aquygfg3.us-east-1.rds.amazonaws.com)\nTable Prefix: wp_ (default)\n\nClick on Submit\nIf everything is correct, click on Run the installation\nEnter the site title (AMSA AWS-Lab), the user name (francesc), the password (9T3nEBqnFqDW3uhc7S) and the email (francesc.solsona@udl.cat)\nClick on Install WordPress\nOnce the installation is complete, click on Log in and enter the credentials you created\nYou will enter in the login page of the WordPress administration (http://44.200.65.68/wp-admin). Enter username francesc and Password 9T3nEBqnFqDW3uhc7S\n\nGood luck! It’s time to play with WordPress…",
    "crumbs": [
      "2 · Deploying a web application"
    ]
  },
  {
    "objectID": "laboratories/01-foundations/02-aws-wordpress.html#cleanup",
    "href": "laboratories/01-foundations/02-aws-wordpress.html#cleanup",
    "title": "Deploying a web application",
    "section": "3. Cleanup",
    "text": "3. Cleanup\nOnce completed, you can delete all EC2 instances and the RDS database to avoid unnecessary charges to your AWS account.",
    "crumbs": [
      "2 · Deploying a web application"
    ]
  },
  {
    "objectID": "slides/02-booting-part3.html#etapes-de-larrancada",
    "href": "slides/02-booting-part3.html#etapes-de-larrancada",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Etapes de l’arrancada",
    "text": "Etapes de l’arrancada"
  },
  {
    "objectID": "slides/02-booting-part3.html#pid-1-initsystemd",
    "href": "slides/02-booting-part3.html#pid-1-initsystemd",
    "title": "Arrencada del sistema (Part 3)",
    "section": "PID 1: init/systemd",
    "text": "PID 1: init/systemd\nQuan s’acaba el procés d’inicialització del sistema en l’espai del kernel i es descomprimeix i executa l’initramfs, es produeix una transició important cap a l’espai d’usuari.\nexec switch_root /mnt /sbin/init\n\nEl comandament switch_root substitueix l’arrel del sistema de fitxers actual (l’initramfs) per la partició arrel real del sistema operatiu.\nEl kernel deixa de gestionar directament els processos i passa el control a un procés en l’espai d’usuari.\nEl procés PID 1 és el primer procés que s’inicia en l’espai d’usuari i és responsable de la gestió dels processos del sistema operatiu.\nTradicionalment, aquest procés era el programa init, però en els sistemes moderns, systemd ha substituït init com a responsable principal de la gestió de processos."
  },
  {
    "objectID": "slides/02-booting-part3.html#funcions-de-pid-1",
    "href": "slides/02-booting-part3.html#funcions-de-pid-1",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Funcions de PID 1",
    "text": "Funcions de PID 1\n\nGestió de la inicialització del sistema. Carrega els serveis i dimonis necessaris per al bon funcionament del sistema.\nGestió dels processos del sistema. Controla la creació, execució i finalització dels processos. Si un procés orfe (un procés que perd el seu procés pare) continua en execució, el PID 1 assumeix la seva gestió i, eventualment, la seva terminació.\nArrel de l’arbre de processos: Tots els altres processos del sistema pengen d’ell, directament o indirectament. Això fa que sigui fonamental per a l’estabilitat i la continuïtat del sistema.\nApagat i reinici del sistema: El PID 1 també és responsable de controlar l’apagat i reinici del sistema, garantint que els processos es tanquin adequadament i que el sistema es desconnecti de manera segura"
  },
  {
    "objectID": "slides/02-booting-part3.html#systemd-vs-sysvinit",
    "href": "slides/02-booting-part3.html#systemd-vs-sysvinit",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Systemd vs SysVinit",
    "text": "Systemd vs SysVinit\nEl canvi de SysVinit a Systemd en moltes distribucions de Linux va ser motivat per la necessitat de millorar l’eficiència i la gestió dels serveis del sistema.\n\n\nSysVinit\n\nSeqüencial: Basat en scripts. Cada servei depèn de l’execució completa del servei anterior, la qual cosa pot ser lenta.\nSimple: Cada servei s’inicia amb un script directament llegible i modificable per l’administrador del sistema.\nInflexible: Dificultat engestionar dependències. No permet arrencar serveis en paral·lel ni controlar els processos un cop arrencats.\n\n\nSystemd\n\nRendiment: Capacitat de carregar serveis en paral·lel. Reducció temps d’inici del sistema.\nModularitat: Els serveis es gestionen a través d’unitats (unit files) que poden especificar dependències, condicions de reinici automàtic,etc.\nCgroups: Limitar/gestionar els recursos assignats a cada servei.\nMonitoratge: Control i seguiment granular dels serveis amb journalctl."
  },
  {
    "objectID": "slides/02-booting-part3.html#crítiques-a-systemd",
    "href": "slides/02-booting-part3.html#crítiques-a-systemd",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Crítiques a Systemd",
    "text": "Crítiques a Systemd\n\nComplexitat: Integra múltiples funcionalitats (gestió de serveis, journal, timers, logind, networkd, etc.) en un sol procés. Això pot augmentar la superfície de fallada i dificultar la depuració.\nTrenca amb la filosofia Unix tradicional\n\nUnix promou eines petites, especialitzades i composables.\n\nSystemd concentra moltes tasques en un únic sistema de gestió.\n\nDependència del sistema: Molts scripts, paquets i eines modernes depenen de systemd, dificultant la compatibilitat amb sistemes alternatius (SysVinit, OpenRC).\n\n\nDebat en la comunitat\n\nEls defensors de systemd argumenten que simplifica l’administració de sistemes moderns i ofereix funcions que abans requerien múltiples eines externes.\n\nEls crítics insisteixen en que és massa intrusiu i redueix la flexibilitat per a administradors avançats i entorns mínims."
  },
  {
    "objectID": "slides/02-booting-part3.html#backdoor-en-xz-utils-i",
    "href": "slides/02-booting-part3.html#backdoor-en-xz-utils-i",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Backdoor en XZ Utils (I)",
    "text": "Backdoor en XZ Utils (I)\nRecents vulnerabilitats en paquets com xz-utils han posat en evidència la complexitat de Systemd i com una backdoor ocult pot comprometre gran part de la infraestructura moderna de Linux.\n\nEl backdoor va ser introduït de manera gradual, començant amb contribucions sospitoses al projecte libarchive el 2021.\nDurant el 2022, un desenvolupador desconegut, JiaT75, va guanyar influència dins del projecte xz-utils, substituint el contacte del mantenidor original i introduint canvis que van ocultar les vulnerabilitats.\nEl 2023, JiaT75 va introduir modificacions malicioses a xz-utils, aprofitant-les per comprometre sistemes a través de dependències amb Systemd.\n\nCVE-2024-3094: Vulnerabilitat que permet l’execució de codi maliciós en el sistema mitjançant un defecte en la descompressió de fitxers .xz."
  },
  {
    "objectID": "slides/02-booting-part3.html#backdoor-en-xz-utils-ii",
    "href": "slides/02-booting-part3.html#backdoor-en-xz-utils-ii",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Backdoor en XZ Utils (II)",
    "text": "Backdoor en XZ Utils (II)\nAquesta vulnerabilitat va afectar molts servidors Linux, que van actualitzar xz-utils amb la versió compromesa.\n\nliblzma és una llibreria de compressió que es pot enllaçar amb altres programes. Per exemple, OpenSSH es pot vincular a liblzma per gestionar la descompressió de fitxers de configuració.\nEn sistemes amb systemd, OpenSSH enllaça amb systemd, que a la vegada enllaça amb liblzma. Això permet a XZ Utils controlar indirectament serveis essencials com sshd.\nMitjançant una backdoor oculta en versions modificades de xz-utils, un atacant amb una clau de xifrat prèviament establerta podria carregar codi maliciós en certificats SSH i executar-lo en dispositius compromesos.\n\n\nAquests esdeveniments posen de manifest les contrapartides de la complexitat de Systemd i com una vulnerabilitat en un paquet aparentment inofensiu com xz-utils pot tenir un impacte significatiu en la seguretat del sistema i serveis crítics com sshd."
  },
  {
    "objectID": "slides/02-booting-part3.html#executar-els-targets-o-runlevels",
    "href": "slides/02-booting-part3.html#executar-els-targets-o-runlevels",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Executar els Targets o Runlevels",
    "text": "Executar els Targets o Runlevels\nEl PID 1 executa els targets de systemd o runlevels d’init. Els targets representen un conjunt de serveis i mòduls que s’executen per a cada estat del sistema. La seva funció és definir l’estat del sistema i els serveis que s’han de carregar en aquest estat. La transició entre els targets es pot fer manualment amb la comanda systemctl isolate o automàticament amb la comanda systemctl set-default.\n\n\ndefault.target: Apunta a graphical.target o multi-user.target-\ngraphical.target: Defineix un entorn gràfic.\nmulti-user.target: Proporciona un entorn no gràfic, permetent múltiples usuaris al sistema, habitual per a servidors.\nrescue.target: Proporciona un entorn de rescat amb una consola de línia de comandes.\nemergency.target: Ofereix un entorn d’emergència que inicialitza el mínim de serveis necessaris per a la solució de problemes.\nshutdown.target: Gestiona l’apagat del sistema.\nreboot.target: Gestiona el reinici del sistema."
  },
  {
    "objectID": "slides/02-booting-part3.html#units-de-systemd",
    "href": "slides/02-booting-part3.html#units-de-systemd",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Units de systemd",
    "text": "Units de systemd\nEls units són els fitxers de configuració de systemd que defineixen els serveis, ens permeten gestionar-los i controlar-los.\n\n/etc/systemd/system/: Fitxers d’unitat personalitzats per l’administrador.\n/run/systemd/system/: Configuració en temps d’execució, és a dir, afecta només un arrencada única.\n/usr/lib/systemd/system/: Configuració proporcionada per la distribució. A Debian és /lib/systemd/system/.\n\n\nQuan hi ha dos fitxers de configuració amb el mateix nom, systemd carregarà només un des del directori que estigui més alt en la jerarquia. Per exemple, la configuració a /etc sempre sobreescriu la configuració a /usr.\n\n\nDesprés de canviar la configuració, és necessari recarregar systemd amb: systemctl daemon-reload."
  },
  {
    "objectID": "slides/02-booting-part3.html#tipus-dunitats",
    "href": "slides/02-booting-part3.html#tipus-dunitats",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Tipus d’unitats",
    "text": "Tipus d’unitats\n\nServeis: Fitxers que defineixen com s’inicien, s’aturen i es gestionen els serveis. Ex: /etc/systemd/system/sshd.service (servei SSH).\nSockets: Units que gestionen els sockets de comunicació per als serveis.\nDevices: Units que representen dispositius de maquinari.\nMounts: Units que gestionen els punts de muntatge del sistema de fitxers.\nPaths: Units que monitoren els canvis en fitxers o directoris específics.\nTimers: Units que planifiquen tasques per a la seva execució en moments específics.\nTargets: Units que agrupen altres units per a l’arrencada d’estats del sistema."
  },
  {
    "objectID": "slides/02-booting-part3.html#targets-i-systemd",
    "href": "slides/02-booting-part3.html#targets-i-systemd",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Targets i Systemd",
    "text": "Targets i Systemd"
  },
  {
    "objectID": "slides/02-booting-part3.html#exemple-de-fitxer-dunitat",
    "href": "slides/02-booting-part3.html#exemple-de-fitxer-dunitat",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Exemple de fitxer d’unitat",
    "text": "Exemple de fitxer d’unitat\n\n\n[Unit]\nDescription=CUPS Scheduler\nDocumentation=man:cupsd(8)\nAfter=network.target\n[Service]\nExecStart=/usr/sbin/cupsd -l\nType=notify\n[Install]\nAlso=cups.socket cups.path\nWantedBy=printer.target\n\n\nCUPS (Common Unix Printing System) és un sistema d’impressió utilitzat en sistemes Unix i Linux.\nTé una dependència amb la xarxa (After=network.target), ja que sovint es connecta a impressores de xarxa.\n\n\n\nS’inicia amb el comandament /usr/sbin/cupsd -l, que posa en marxa el servei d’impressió.\nEs configura per iniciar-se automàticament quan s’arrenca el sistema (WantedBy=printer.target).\nCups.socket és una unitat de tipus socket que permet a CUPS escoltar connexions entrants per a serveis d’impressió.\nCups.path és una unitat de tipus path que monitoritza canvis en fitxers o directoris relacionats amb la configuració d’impressió.\n\n\nAquest fitxer defineix el servei CUPS (Common Unix Printing System) és un sistema que té una depenència amb la xarxa (After=network.target), s’inicia amb el comandament /usr/sbin/cupsd -l i es configura per iniciar-se automàticament quan s’arrenca el sistema (WantedBy=printer.target). Printer.target és un target que agrupa serveis relacionats amb la impressió. Cups.socket i cups.path són altres unitats que també s’inicien quan s’inicia el servei CUPS ja que estan lligades a aquest servei. El tipus de servei és notify, el qual indica que el servei enviarà una notificació a systemd quan estigui llest."
  },
  {
    "objectID": "slides/02-booting-part3.html#dependències-entre-unitats-i",
    "href": "slides/02-booting-part3.html#dependències-entre-unitats-i",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Dependències entre unitats (I)",
    "text": "Dependències entre unitats (I)\nLes unitats són objectes gestionats per systemd. Les dependències són associacions entre elles. Cada tipus d’unitat té algunes dependències per defecte (a menys que s’especifiqui el contrari).\nRelacionals\n\nRequires: Indica que una unitat depèn d’una altra unitat per a la seva activació. Si la unitat requerida no està activa, la unitat que la requereix no s’activarà.\nWants: Similar a Requires, però no és tan estricte. Si la unitat requerida no està activa, la unitat que la vol no es bloquejarà.\nBindsTo: Similar a Requires, però si la unitat requerida es deté, la unitat que la vincula també es detindrà.\nPartOf: Indica que una unitat és part d’una altra unitat. Si la unitat pare es deté, la unitat fill també es detindrà.\nConflicts: Indica que dues unitats no poden estar actives al mateix temps. Si una unitat s’activa, l’altra es detindrà automàticament."
  },
  {
    "objectID": "slides/02-booting-part3.html#dependències-entre-unitats-ii",
    "href": "slides/02-booting-part3.html#dependències-entre-unitats-ii",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Dependències entre unitats (II)",
    "text": "Dependències entre unitats (II)\nOrdenació\n\nAfter: Indica que una unitat s’ha d’iniciar després d’una altra unitat. No crea una dependència estricta, només defineix l’ordre d’inici.\nBefore: Indica que una unitat s’ha d’iniciar abans d’una altra unitat. No crea una dependència estricta, només defineix l’ordre d’inici."
  },
  {
    "objectID": "slides/02-booting-part3.html#transaccions-a-systemd-i",
    "href": "slides/02-booting-part3.html#transaccions-a-systemd-i",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Transaccions a systemd (I)",
    "text": "Transaccions a systemd (I)\nCada vegada que l’usuari o un servei sol·licita una acció (per exemple, iniciar o aturar un servei), es crea una transacció que gestiona l’execució ordenada de les unitats afectades.\n\nCreació de feines (jobs)\n\nEs crea una feina per a la unitat sol·licitada.\n\nS’afegeixen recursivament les feines corresponents a totes les dependències de la unitat.\n\nMinimització de la transacció\n\nEliminar feines duplicades o redundants.\n\nEliminar feines que no estiguin referenciades per cap altre job (ancoratge).\n\nResolució de cicles de dependències\n\nDetectar loops en el gràfic de dependències.\n\nTrencar-los eliminant feines problemàtiques per evitar deadlocks."
  },
  {
    "objectID": "slides/02-booting-part3.html#transaccions-a-systemd-i-1",
    "href": "slides/02-booting-part3.html#transaccions-a-systemd-i-1",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Transaccions a systemd (I)",
    "text": "Transaccions a systemd (I)\n\nFusió i optimització de feines\n\nFusionar feines similars per reduir el nombre d’operacions.\n\nPrioritzar feines ja existents a la cua.\n\nEnviament i execució\n\nAfegir les feines a la cua de jobs de systemd.\n\nExecutar les feines segons la dependència i l’ordre optimitzat.\n\n\n\nGaranteix que les unitats es gestionin de manera atòmica i ordenada, permetent a systemd paral·lelitzar serveis mentre respecta les dependències.\n\n\n\nLes transaccions garanteixen que les unitats es gestionin de manera atòmica i ordenada.\n\nAixò permet a systemd paral·lelitzar serveis mentre respecta les dependències.\n\nCadascuna de les feines conté informació sobre la unitat, la seva acció (start, stop, reload) i les condicions d’execució."
  },
  {
    "objectID": "slides/02-booting-part3.html#systemctl-i",
    "href": "slides/02-booting-part3.html#systemctl-i",
    "title": "Arrencada del sistema (Part 3)",
    "section": "systemctl (I)",
    "text": "systemctl (I)\nLa comanda systemctl és l’eina principal per interactuar amb systemd i gestionar els serveis i unitats del sistema. Algunes de les operacions més comunes inclouen:\n\n\n\n\n\n\n\nComanda\nDescripció\n\n\n\n\nsystemctl start &lt;unit&gt;\nInicia una unitat (servei, socket, etc.).\n\n\nsystemctl stop &lt;unit&gt;\nAtura una unitat.\n\n\nsystemctl restart &lt;unit&gt;\nReinicia una unitat.\n\n\nsystemctl status &lt;unit&gt;\nMostra l’estat actual d’una unitat.\n\n\nsystemctl enable &lt;unit&gt;\nHabilita una unitat perquè s’iniciï automàticament en arrencar el sistema.\n\n\nsystemctl disable &lt;unit&gt;\nDeshabilita una unitat perquè no s’iniciï automàticament.\n\n\nsystemctl is-active &lt;unit&gt;\nComprova si una unitat està activa.\n\n\nsystemctl is-enabled &lt;unit&gt;\nComprova si una unitat està habilitada per arrencar automàticament."
  },
  {
    "objectID": "slides/02-booting-part3.html#systemctl-ii",
    "href": "slides/02-booting-part3.html#systemctl-ii",
    "title": "Arrencada del sistema (Part 3)",
    "section": "systemctl (II)",
    "text": "systemctl (II)\n\n\n\n\n\n\n\nComanda\nDescripció\n\n\n\n\nsystemctl list-units\nLlista totes les unitats carregades actualment.\n\n\nsystemctl list-unit-files\nLlista tots els fitxers d’unitats disponibles.\n\n\nsystemctl list-dependencies &lt;SERVICE&gt;\nMostra les dependències d’una unitat.\n\n\nsystemctl list-jobs\nMostra les feines pendents i en execució."
  },
  {
    "objectID": "slides/02-booting-part3.html#unitat-install",
    "href": "slides/02-booting-part3.html#unitat-install",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Unitat [INSTALL]",
    "text": "Unitat [INSTALL]\n[Install]\nWantedBy=multi-user.target\nAlso=sysstat-collect.timer\nAlso=sysstat-summary.timer\nAlias=monitoring.service\n\nLa secció [Install] defineix com s’instal·la i s’inicia una unitat.\nWantedBy=multi-user.target indica que aquesta unitat s’ha d’iniciar quan s’arrenca el sistema en mode multiusuari (runlevel 3).\nAlso= permet associar altres unitats que s’han d’iniciar juntament amb aquesta.\nAlias= crea un nom alternatiu per a la unitat, facilitant la seva referència.\n\n\nEn aquest cas, la unitat s’iniciarà automàticament en arrencar el sistema en mode multiusuari, i també s’iniciaran els temporitzadors sysstat-collect.timer i sysstat-summary.timer. A més, es pot referenciar aquesta unitat amb el nom alternatiu monitoring.service."
  },
  {
    "objectID": "slides/02-booting-part3.html#opcions-service-i",
    "href": "slides/02-booting-part3.html#opcions-service-i",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Opcions [Service] (I)",
    "text": "Opcions [Service] (I)\n\n\n\n\n\n\n\nOpció\nDescripció\n\n\n\n\nType=\nDefineix el tipus de servei (simple, forking, oneshot, notify, idle).\n\n\nExecStart=\nComanda que s’executa per iniciar el servei.\n\n\nExecStop=\nComanda que s’executa per aturar el servei.\n\n\nExecReload=\nComanda que s’executa per recarregar la configuració del servei.\n\n\nRemainAfterExit=\nIndica si el servei es manté actiu després de finalitzar.\n\n\nRestart=\nDefineix si el servei s’ha de reiniciar en cas de fallada.\n\n\nUser=\nDefineix l’usuari amb el qual s’executa el servei.\n\n\nGroup=\nDefineix el grup amb el qual s’executa el servei."
  },
  {
    "objectID": "slides/02-booting-part3.html#opcions-service-ii",
    "href": "slides/02-booting-part3.html#opcions-service-ii",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Opcions [Service] (II)",
    "text": "Opcions [Service] (II)\n\n\n\n\n\n\n\nOpció\nDescripció\n\n\n\n\nEnvironment=\nDefineix variables d’entorn per al servei.\n\n\nWorkingDirectory=\nDefineix el directori de treball del servei.\n\n\nPIDFile=\nEspecifica el fitxer que conté el PID del servei.\n\n\nTimeoutStartSec=\nTemps d’espera per a l’inici del servei.\n\n\nTimeoutStopSec=\nTemps d’espera per a l’aturada del servei.\n\n\nStandardOutput=\nDefineix on s’envia la sortida estàndard del servei.\n\n\nStandardError=\nDefineix on s’envia l’error"
  },
  {
    "objectID": "slides/02-booting-part3.html#tipus-de-serveis-i",
    "href": "slides/02-booting-part3.html#tipus-de-serveis-i",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Tipus de serveis (I)",
    "text": "Tipus de serveis (I)\n\nSimple: Per defecte, aquest servei s’inicia immediatament després del fork(). No espera cap senyal de que el servei estigui llest.\nForking: Aquest tipus de servei és per a processos que es bifurquen (fork) i es converteixen en dimonis. El servei es considera actiu després que el procés pare finalitzi.\nOneshot: Aquest tipus és per a serveis que realitzen una tasca única i després finalitzen. Systemd espera que el procés acabi abans de considerar el servei com a actiu.\nNotify: Aquest tipus de servei utilitza el mecanisme de notificació de systemd per informar quan està llest. El servei ha d’enviar una notificació explícita a systemd.\nDBus: Aquest tipus de servei s’utilitza per a serveis que es comuniquen a través de DBus. El servei es considera actiu quan el nom del bus apareix al bus de sistema.\nIdle: Aquest tipus de servei s’inicia només quan el sistema està inactiu, és a dir, quan no hi ha altres feines pendents."
  },
  {
    "objectID": "slides/02-booting-part3.html#efecte-del-tipus-de-servei-al-runtime",
    "href": "slides/02-booting-part3.html#efecte-del-tipus-de-servei-al-runtime",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Efecte del tipus de servei al runtime",
    "text": "Efecte del tipus de servei al runtime"
  },
  {
    "objectID": "slides/02-booting-part3.html#script-de-lusuari",
    "href": "slides/02-booting-part3.html#script-de-lusuari",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Script de l’usuari",
    "text": "Script de l’usuari\nUn cop s’han carregat tots els serveis i el sistema està en marxa, els usuaris poden iniciar sessió al sistema. Els scripts de l’usuari es troben a la carpeta /etc/profile.d/ i s’executen quan l’usuari inicia sessió.\n\n/etc/profile: Conté la configuració global per a tots els usuaris. S’executa en iniciar sessió en un entorn de shell.\n/etc/bashrc: Proporciona configuració per a shells interactius. S’executa cada vegada que s’inicia una nova sessió de shell.\n~/.bashrc: Fitxer de configuració específic per a l’usuari, que s’executa en iniciar una sessió de shell interactiu.\n~/.bash_profile: S’executa quan l’usuari inicia sessió a la terminal. Normalment, s’utilitza per configurar l’entorn de l’usuari, incloent la configuració de l’PATH.\n~/.bash_logout: S’executa quan l’usuari tanca la sessió de shell. Aquí es poden incloure comandes de neteja o tancament.\n~/.bash_history: Fitxer que emmagatzema l’històric de les comandes executades per l’usuari en la sessió de shell."
  },
  {
    "objectID": "slides/02-booting-part3.html#exercicis-propostas",
    "href": "slides/02-booting-part3.html#exercicis-propostas",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Exercicis Propostas",
    "text": "Exercicis Propostas\n\nAnàlisi del procés d’arrencada amb systemd\nServei de Còpia de Seguretat Automàtica amb systemd\nDiscussió: Secure Boot és realment segur?: Cerca notícies recents sobre Secure Boot i comparteix-les al fòrum del curs. Debatiu sobre avantatges, desavantatges, vulnerabilitats conegudes i experiències personals.\nPràctica 01: Snapshots i restauració amb systemd i initramfs"
  },
  {
    "objectID": "slides/02-booting-part3.html#thats-all",
    "href": "slides/02-booting-part3.html#thats-all",
    "title": "Arrencada del sistema (Part 3)",
    "section": "That’s all",
    "text": "That’s all\n\n\n\n\n\n\n\n\n\nTake Home Message\n\n\nEl procés d’arrencada és un procés complex. Els administradors de sistemes han de conèixer aquest procés per poder gestionar i solucionar problemes durant l’arrencada del sistema i garantir un sistema segur, estable i eficient."
  },
  {
    "objectID": "slides/03-filesystem-part2.html#què-és-un-raid",
    "href": "slides/03-filesystem-part2.html#què-és-un-raid",
    "title": "Sistema de fitxers (II)",
    "section": "Què és un RAID?",
    "text": "Què és un RAID?\nUn RAID (Redundant Array of Independent (originalment Inexpensive) Disks) és un conjunt de dispositius d’emmagatzematge que es combinen per a formar un sistema d’emmagatzematge únic. Aquest nou sistema d’emmagatzematge permet distribuir les dades entre els diferents dispositius que el formen i millorar-ne mètriques com la redundància o el rendiment.\n\n\nEls RAIDs són un conjunt de dispositius d’emmagatzematge que es combinen per a formar un sistema d’emmagatzematge únic.\nEl principal objectiu d’aquesta combinació és tolerar les fallades que es poden produir en els dispositius d’emmagatzematge. Aquesta redundància es pot aconseguir mitjançant la duplicació de les dades o mitjançant la paritat, com veurem més endavant.\nUn altre objectiu important dels RAIDs és millorar el rendiment del sistema mitjançant la distribució de les dades entre els diferents dispositius. Això permet millorar la velocitat de lectura i escriptura de les dades. Es coneix també com striping o en altres paraules ens permet incrementar la ample de banda."
  },
  {
    "objectID": "slides/03-filesystem-part2.html#què-és-el-rendiment-i-la-redundància",
    "href": "slides/03-filesystem-part2.html#què-és-el-rendiment-i-la-redundància",
    "title": "Sistema de fitxers (II)",
    "section": "Què és el rendiment i la redundància?",
    "text": "Què és el rendiment i la redundància?\n\nLa redundància és la capacitat d’un sistema de continuar funcionant en cas de fallada d’un o més dispositius. Aquesta capacitat es pot aconseguir mitjançant la duplicació de les dades o mitjançant la paritat.\nEl rendiment és la capacitat d’un sistema de processar un volum de dades en un temps determinat. Aquesta capacitat es pot aconseguir mitjançant la distribució de les dades entre els diferents dispositius, mitjançant una tècnica coneguda com striping."
  },
  {
    "objectID": "slides/03-filesystem-part2.html#conceptes-bàsics",
    "href": "slides/03-filesystem-part2.html#conceptes-bàsics",
    "title": "Sistema de fitxers (II)",
    "section": "Conceptes bàsics",
    "text": "Conceptes bàsics\n\nRedundància: Capacitat de tolerar fallades de dispositiu (quantitat de discs que poden fallar sense perdre dades).\nRendiment: Mesurat en IOPS i ample de banda MB/s. Depèn de la mida de stripe,nombre de discs i patró d’accés (seqüencial vs aleatori).\nCapacitat: La capacitat total del sistema és la suma de les capacitats dels dispositius que el formen, tenint en compte la redundància.\nStripe: Un stripe és una unitat d’informació que es distribueix entre els diferents dispositius que formen el RAID. Conjunt de blocs distribuïts entre discs dins del RAID.\nBloc: Un bloc és una unitat d’informació que es llegeix o s’escriu en un dispositiu d’emmagatzematge. (512B, 4KB…).\n\n\n\n\n\n\n\n\nDiferència entre Stripe i Bloc\n\n\nAmb 2 dispositius i un stripe de 64 KB, cada dispositiu guarda 64 KB alternatius d’un fitxer."
  },
  {
    "objectID": "slides/03-filesystem-part2.html#implementacions-de-raids",
    "href": "slides/03-filesystem-part2.html#implementacions-de-raids",
    "title": "Sistema de fitxers (II)",
    "section": "Implementacions de RAIDs",
    "text": "Implementacions de RAIDs\n\nSoftware RAID: Implementat a nivell de sistema operatiu.\n\nAvantatges: flexibilitat, transparència, no depèn del hardware.\nInconvenients: CPU utilitzat per càlculs de paritat.\n\nHardware RAID: Controladora dedicada (característiques pròpies, cache, acceleració XOR).\n\nAvantatges: millors rendiments en alguns escenaris;\nInconvenients: dependència del controlador, propietat de metadades.\n\nFake/BIOS RAID: Solució mixta (controladora amb firmware mínim). Pot generar problemes de portabilitat i compatibilitat."
  },
  {
    "objectID": "slides/03-filesystem-part2.html#implementacions-de-raids-1",
    "href": "slides/03-filesystem-part2.html#implementacions-de-raids-1",
    "title": "Sistema de fitxers (II)",
    "section": "Implementacions de RAIDs",
    "text": "Implementacions de RAIDs"
  },
  {
    "objectID": "slides/03-filesystem-part2.html#raid-lineal",
    "href": "slides/03-filesystem-part2.html#raid-lineal",
    "title": "Sistema de fitxers (II)",
    "section": "RAID Lineal",
    "text": "RAID Lineal\n\ncat lògic entre diversos dispositius d’emmagatzematge físics. JBOD (Just a Bunch Of Disks). No millora ni la redundància ni el rendiment.\n\n\n\n\n\n\nEl RAID lineal és el més bàsic de tots els tipus de RAID.\nEn aquest sistema, la informació es distribueix primer en un disc i després en l’altre, seguint un ordre seqüencial. Cada unitat d’informació es coneguda com a stripe, i correspon a un bloc.\nLa figura mostra un exemple de RAID Lineal (/dev/md0) amb dos discos (/dev/vda i /dev/vdb). En aquest exemple s’han guardat els primers blocs (1 al 6) a la partició (/dev/vda1). Ara, s’ha d’assumir que la partició (/dev/sda1) es plena. Els següents blocs es guarden a la següent partició disponible (/dev/vdb1). I així successivament."
  },
  {
    "objectID": "slides/03-filesystem-part2.html#raid-0-striping",
    "href": "slides/03-filesystem-part2.html#raid-0-striping",
    "title": "Sistema de fitxers (II)",
    "section": "RAID 0 (Striping)",
    "text": "RAID 0 (Striping)\n\n\n\n\n\n\n\nObjectiu: augmentar rendiment i capacitat (capacitat = suma de discos).\nMida de stripe:\n\nPetits milloren IOPS aleatoris.\nGrans stripes milloren seqüencials.\n\nSi les dades són prou grans, es poden llegir/escriure en paral·lel.\nTolerància a fallades: 0 (pèrdua total si un disc falla).\nAplicacions: cache, fitxers temporals, tasques on la redundància no és prioritària.\n\n\n\n\nEl nivell 0 de RAID és un dels més senzills i més utilitzats. El seu objectiu principal és millorar el rendiment del sistema mitjançant la distribució de les dades entre els diferents dispositius.\nAquesta distribució es realitza mitjançant una tècnica coneguda com striping. Aquesta tècnica permet dividir les dades en blocs més petits i distribuir-los entre els diferents dispositius. Fent Round Robin a tots els dispositius.\nAixò permet millorar la velocitat de lectura i escriptura de les dades, per tant incrementa l’ample de banda.\nLa capacitat del sistema també es veu incrementada, ja que la capacitat total del sistema és la suma de les capacitats dels dispositius que el formen.\nEl principal desavantatge del nivell 0 de RAID és que no ofereix cap tipus de redundància. Això vol dir que si un dels dispositius falla, es perden totes les dades del sistema.\nLa figura mostra un exemple de RAID0 (/dev/md0) amb dos discos (/dev/vda i /dev/vdb). En aquest exemple s’han guardat els primers blocs (1 al 6) de forma alternada 1 a cada disc. El següent bloc (9) es guarda al disc (/dev/vdb). En aquest exemple, els blocs parells es guarden al disc (/dev/vdb) i els senars al disc (/dev/vda)."
  },
  {
    "objectID": "slides/03-filesystem-part2.html#raid-1-mirror",
    "href": "slides/03-filesystem-part2.html#raid-1-mirror",
    "title": "Sistema de fitxers (II)",
    "section": "RAID 1 (Mirror)",
    "text": "RAID 1 (Mirror)\n\n\n\n\n\nObjectiu: redundància via duplicació exacta (mirrors).\nLectures: potencialment paral·leles (millora), depèn del controlador.\nEscriptures: es repliquen en tots els mirrors (overhead escritura).\nCapacitat usable: 50% amb 2 discos (en general n/2 en conjunts de mirrors).\nAplicacions: sistema root, dades crítiques on la coherència immediata és prioritària.\n\n\n\n\nEl nivell 1 té com a objectiu principal millorar la redundància del sistema mitjançant la duplicació de les dades en dos dispositius.\nLa figura 1.3 mostra un exemple de RAID1 (/dev/md0) amb dos discos (/dev/vda i /dev/vdb). En aquest exemple s’han guardat els primers blocs (1 al 6) de forma idèntica en els dos discos. Això significa que si un dels discos falla, l’altre disc pot continuar funcionant sense interrupció, ja que conté una còpia completa de totes les dades.\nPer tant, el principal avantatge del nivell 1 de RAID és la redundància. Això vol dir que si un dels dispositius falla, es poden recuperar les dades sense problemes.\nUn altre avantatge del nivell 1 de RAID és que permet realitzar lectures gairebé el doble de ràpides, ja que es poden llegir les dades de forma simultània des dels dos dispositius.\nPer contra, el nivell 1 de RAID també té alguns desavantatges. El principal desavantatge és el cost, ja que es necessiten més dispositius per a duplicar les dades. Això vol dir que el cost del sistema es duplica. A més, l’escriptura és més lenta, ja que es necessita escriure les dades en els dos dispositius de forma simultània. Finalment, la capacitat del sistema també es veu reduïda, ja que només es pot utilitzar la meitat de la capacitat total dels dispositius."
  },
  {
    "objectID": "slides/03-filesystem-part2.html#raid-2",
    "href": "slides/03-filesystem-part2.html#raid-2",
    "title": "Sistema de fitxers (II)",
    "section": "RAID 2",
    "text": "RAID 2\n\n\n\n\nEl stripe és a nivell de bit i no de bloc com fins ara.\nPràcticament obsolet en sistemes moderns: exigeix molts discs i accès sincronitzat.\n\n\n\nEl nivell 2 de RAID utilitza la paritat per detectar i corregir errors en les dades. Aquesta paritat es calcula mitjançant bits de control anomenats bits de paritat.\nObservem que el stripe és a nivell de bit i no de bloc com fins ara. Això vol dir que les dades es divideixen en bits més petits i es distribueixen entre els diferents dispositius.\nLa Figura 1.4 mostra un exemple d’una configuració RAID 2 que implementa un codi Hamming(4,3), és a dir, 4 bits de dades i 3 bits de paritat. Aquesta configuració pot semblar poc pràctica en molts contextos, però ens proporciona una comprensió clara de com funciona la codificació de les dades i, en particular, la codificació de Hamming.\nEls codis Hamming són una classe de codis de correcció d’errors que es basen en la paritat. Aquests codis són molt útils per a la detecció i correcció d’errors en les dades, ja que permeten identificar i corregir errors en les dades sense necessitat de retransmissió.\nEl seu ús es poc pràctic en molts contextos, ja que requereix una gran quantitat de dispositius i afegeix la complexitat de la implementació de la codificació de Hamming (encoded)."
  },
  {
    "objectID": "slides/03-filesystem-part2.html#codis-de-hamming",
    "href": "slides/03-filesystem-part2.html#codis-de-hamming",
    "title": "Sistema de fitxers (II)",
    "section": "Codis de Hamming",
    "text": "Codis de Hamming\nEls codis de Hamming són una classe de codis de correcció d’errors que es basen en la paritat. Aquests codis són molt útils per a la detecció i correcció d’errors en les dades, ja que permeten identificar i corregir errors en les dades sense necessitat de retransmissió.\n\nEl codi de Hamming permet detectar i corregir un sol error de bit.\n\nS’utilitza en el RAID 2 per protegir dades a nivell de bit.\nS’intercalen bits de paritat entre els bits de dades.\n\nCada bit de paritat comprova un conjunt específic de bits de dades.\n\nSi un bit es corromp, la combinació dels bits de paritat indica quin bit s’ha de corregir."
  },
  {
    "objectID": "slides/03-filesystem-part2.html#xor-operació-bàsica",
    "href": "slides/03-filesystem-part2.html#xor-operació-bàsica",
    "title": "Sistema de fitxers (II)",
    "section": "XOR (Operació bàsica)",
    "text": "XOR (Operació bàsica)\nLa operació XOR (exclusive OR) és una operació lògica que compara dos bits i retorna un bit de resultat. El resultat és 1 si els bits comparats són diferents, i 0 si són iguals.\n\n\n\nA\nB\n\\(A \\oplus B\\)\n\n\n\n\n0\n0\n0\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n1\n1\n0"
  },
  {
    "objectID": "slides/03-filesystem-part2.html#hamming74---0110",
    "href": "slides/03-filesystem-part2.html#hamming74---0110",
    "title": "Sistema de fitxers (II)",
    "section": "Hamming(7,4) -> [0110]",
    "text": "Hamming(7,4) -&gt; [0110]\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n\n\n\\(p_1\\)\n\\(p_2\\)\n\\(d_1\\)\n\\(p_3\\)\n\\(d_2\\)\n\\(d_3\\)\n\\(d_4\\)\n\n\nDades\n\n\n0\n\n1\n1\n0\n\n\n\\(p_1\\)\n1\n\n0\n\n1\n\n0\n\n\n\\(p_2\\)\n\n1\n0\n\n\n1\n0\n\n\n\\(p_3\\)\n\n\n\n0\n1\n1\n0\n\n\nCodi\n1\n1\n0\n0\n1\n1\n0\n\n\n\n\n\n\nEls bits que són potència de 2 (\\(2^k\\), k=0,1, 2…) són els bits de paritat.\nBits de paritat = XOR bits de dades amb el \\(n^o\\) de bit de paritat.\n\n\n\n\n[0110] es codifica com [1100110]"
  },
  {
    "objectID": "slides/03-filesystem-part2.html#comprovació-derrors-amb-hamming-1100110",
    "href": "slides/03-filesystem-part2.html#comprovació-derrors-amb-hamming-1100110",
    "title": "Sistema de fitxers (II)",
    "section": "Comprovació d’errors amb Hamming [1100110]",
    "text": "Comprovació d’errors amb Hamming [1100110]\n\nEs calcula els bits de Comprovació = XOR del bits de paritat i de tots els seus bits de dades associats:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n\n\n\np\\(_1\\)\np\\(_2\\)\nd\\(_1\\)\np\\(_3\\)\nd\\(_2\\)\nd\\(_3\\)\nd\\(_4\\)\nComprovació\n\n\nCodi\n1\n1\n0\n0\n1\n1\n0\n\n\n\np\\(_1\\)\n1\n\n0\n\n1\n\n0\n0\n\n\np\\(_2\\)\n\n1\n0\n\n\n1\n0\n0\n\n\np\\(_3\\)\n\n\n\n0\n1\n1\n0\n0\n\n\n\n\nTots els bits de comprovació = 0 → cap error detectat."
  },
  {
    "objectID": "slides/03-filesystem-part2.html#comprovació-derrors-amb-hamming-1100111",
    "href": "slides/03-filesystem-part2.html#comprovació-derrors-amb-hamming-1100111",
    "title": "Sistema de fitxers (II)",
    "section": "Comprovació d’errors amb Hamming [1100111]",
    "text": "Comprovació d’errors amb Hamming [1100111]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n\n\n\np\\(_1\\)\np\\(_2\\)\nd\\(_1\\)\np\\(_3\\)\nd\\(_2\\)\nd\\(_3\\)\nd\\(_4\\)\nComprovació\n\n\nCodi\n1\n1\n0\n0\n1\n1\n1\n\n\n\np\\(_1\\)\n1\n\n0\n\n1\n\n1\n1\n\n\np\\(_2\\)\n\n1\n0\n\n\n1\n1\n1\n\n\np\\(_3\\)\n\n\n\n0\n1\n1\n1\n1\n\n\n\n\nS’ha alterat el bit 7 corresponent a d\\(_4\\)."
  },
  {
    "objectID": "slides/03-filesystem-part2.html#comprovació-derrors-amb-hamming-0100110",
    "href": "slides/03-filesystem-part2.html#comprovació-derrors-amb-hamming-0100110",
    "title": "Sistema de fitxers (II)",
    "section": "Comprovació d’errors amb Hamming [0100110]",
    "text": "Comprovació d’errors amb Hamming [0100110]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n\n\n\np\\(_1\\)\np\\(_2\\)\nd\\(_1\\)\np\\(_3\\)\nd\\(_2\\)\nd\\(_3\\)\nd\\(_4\\)\nComprovació\n\n\nCodi\n0\n1\n0\n0\n1\n1\n0\n\n\n\np\\(_1\\)\n0\n\n0\n\n1\n\n0\n1\n\n\np\\(_2\\)\n\n1\n0\n\n\n1\n0\n0\n\n\np\\(_3\\)\n\n\n\n0\n1\n1\n0\n0\n\n\n\n\nEls bits de comprovació = 001 → s’ha alterat el bit 1 corresponent a \\(p_1\\)."
  },
  {
    "objectID": "slides/03-filesystem-part2.html#raid-3-i-4",
    "href": "slides/03-filesystem-part2.html#raid-3-i-4",
    "title": "Sistema de fitxers (II)",
    "section": "RAID 3 i 4",
    "text": "RAID 3 i 4\n\n\n\n\n\nRAID 3: striping a nivell de byte, paritat en disc dedicat; accés molt sincronitzat → bo per fitxers grans i seqüencials (p.ex. streaming).\nRAID 4: striping a nivell de bloc, paritat en disc dedicat; permet accessos independents per bloc però pateix bottleneck al disc de paritat.\nEn ambdós casos la paritat dedicada pot ser coll d’ampolla per escriptura.\n\n\n\n\nLa diferència entre un RAID 3 i 4 és la granularitat de la paritat. En un RAID 3 la paritat es calcula a nivell de bytes i en un RAID 4 a nivell de blocs.\nLes dades es distribueixen com un RAID 0 i la paritat es guarda en un disc dedicat.\nEn realitat, en un RAID 3 o 4, les dades no es dupliquen, sinó que es calcula una paritat. Si un disc falla, les dades es poden recuperar utilitzant la informació de paritat dels altres discs.\nLa figura il·lustra un exemple de configuració RAID 4. En aquest exemple, el RAID 4, identificat com a /dev/md0, està format per cinc discos: /dev/vda, /dev/vdb, /dev/vdc, /dev/vdd i /dev/vde. En aques- ta configuració RAID 4, els primers quatre discos (/dev/vda, /dev/vdb, /dev/vdc, i /dev/vdd) s’utilitzen per emmagatzemar les dades. El cin- què disc (/dev/vde) s’utilitza exclusivament per a la paritat."
  },
  {
    "objectID": "slides/03-filesystem-part2.html#raid-5",
    "href": "slides/03-filesystem-part2.html#raid-5",
    "title": "Sistema de fitxers (II)",
    "section": "RAID 5",
    "text": "RAID 5\n\n\n\n\n\nParitat distribuïda entre tots els discos (evita coll d’ampolla únic).\nTolerància: 1 disc (hi ha un petit risc durant rebuild). Probabilitat de fallada en discs grans.\nLectura: alta (com RAID0).\nEscriptura: penalització per read-modify-write (llegir bloc antic, llegir paritat antiga, escriure dades i paritat nova) — crític per a càrregues amb moltes escriptures petites.\nCapacitat: \\((n-1)/n\\).\nAplicacions: sistemes de fitxers, bases de dades, servidors web.\n\n\n\n\nEl RAID 5 és un dels nivells de RAID més utilitzats en els sistemes informàtics actuals. Aquest RAID ofereix un bon equilibri entre rendiment i redundància.\nLa principal diferència entre un RAID 4 i un RAID 5 és que en un RAID 5 la paritat es distribueix entre els diferents discs per evitar el coll d’ampolla.\nLa figura il·lustra un exemple de configuració RAID 5. En aquesta configuració, la paritat es distribueix entre tots els discs, en lloc de ser emmagatzemada en un disc dedicat com en el RAID 4."
  },
  {
    "objectID": "slides/03-filesystem-part2.html#raid-6",
    "href": "slides/03-filesystem-part2.html#raid-6",
    "title": "Sistema de fitxers (II)",
    "section": "RAID 6",
    "text": "RAID 6\n\nExtensió de RAID5 amb doble paritat (P i Q) → tolera 2 fallades simultànies.\nRecomanat en conjunts grans (n gran) on la probabilitat de fallada durant rebuild és significativa.\nPenalització d’escriptura més elevada que RAID5, però millor tolerància."
  },
  {
    "objectID": "slides/03-filesystem-part2.html#raid-10",
    "href": "slides/03-filesystem-part2.html#raid-10",
    "title": "Sistema de fitxers (II)",
    "section": "RAID 10",
    "text": "RAID 10\n\nmirror + stripe. Tolerància variable segons quins discs fallen; reconstrucció molt més ràpida."
  },
  {
    "objectID": "slides/03-filesystem-part2.html#raid-50",
    "href": "slides/03-filesystem-part2.html#raid-50",
    "title": "Sistema de fitxers (II)",
    "section": "RAID 50",
    "text": "RAID 50\n\nStripe sobre múltiples conjunts RAID5. Millora rendiment i tolerància depenent de cada grup.\n\n\n."
  },
  {
    "objectID": "slides/03-filesystem-part2.html#comparativa-de-raids",
    "href": "slides/03-filesystem-part2.html#comparativa-de-raids",
    "title": "Sistema de fitxers (II)",
    "section": "Comparativa de RAIDs",
    "text": "Comparativa de RAIDs\n\n\n\n\n\n\n\n\n\n\n\nNivell\nMin discs\nCapacitat\nTolerància\nLectura\nEscriptura\n\n\n\n\nRAID 0\n2\n100%\n0\nAlt\nAlt\n\n\nRAID 1\n2\n50% (amb 2 discos)\n1 per mirror\nPot ser Alt\nMitjà\n\n\nRAID 5\n3\n\\((n-1)/n\\)\n1\nAlt\nMitjà-Baix\n\n\nRAID 6\n4\n\\((n-2)/n\\)\n2\nAlt\nMitjà-Baix (pitjor que RAID5)\n\n\nRAID 10\n4\n50% (depèn)\n≥1 (segons fallades)\nAlt\nAlt\n\n\nRAID 50\n6\naproximadament \\((n-1)/n\\) per grup\n≥1 per grup\nAlt\nMitjà\n\n\n\n\n\nLa taula mostra una comparativa entre els diferents nivells de RAID més comuns. Aquesta comparativa inclou les característiques més importants de cada RAID, com ara el nombre mínim de dispositius, la redundància, el rendiment en lectura i escriptura i la capacitat.\nCom es pot observar, cada RAID té les seves pròpies característiques i avantatges. Per exemple, el RAID 0 ofereix un rendiment molt alt en lectura i escriptura, però no ofereix cap tipus de redundància. En canvi, el RAID 1 ofereix una alta redundància, però el rendiment en escriptura és baix.\nPer exemple, la instal·lació d’un sistema operatiu es podria fer en un RAID 1, ja que la redundància és més important que el rendiment.\nEn canvi, un servidor web seria més adequat en un RAID 5, ja que ofereix un bon equilibri entre rendiment i redundància.\nEn general, la selecció del RAID més adequat depèn de les necessitats del sistema i dels usuaris."
  },
  {
    "objectID": "slides/03-filesystem-part2.html#dispositiu-devmd",
    "href": "slides/03-filesystem-part2.html#dispositiu-devmd",
    "title": "Sistema de fitxers (II)",
    "section": "Dispositiu /dev/md*",
    "text": "Dispositiu /dev/md*\n\nLinux implementa Software RAID mitjançant el subsistema del kernel MD (Multiple Device).\nEl mòdul principal és md_mod, que crea dispositius virtuals de bloc /dev/mdX sobre dispositius físics (/dev/sd*, /dev/nvme*, etc.).\nCada dispositiu MD és gestionat per un controlador de tipus mdX que manté una taula de mapatge (metadata) amb:\n\nnivell RAID (level)\nnombre de dispositius (raid_disks)\nsuperblocs (superblock)\nestat de sincronització i fallades"
  },
  {
    "objectID": "slides/03-filesystem-part2.html#components-del-subsistema-md",
    "href": "slides/03-filesystem-part2.html#components-del-subsistema-md",
    "title": "Sistema de fitxers (II)",
    "section": "Components del subsistema MD",
    "text": "Components del subsistema MD\n\n\n\n\n\n\n\nComponent\nFunció principal\n\n\n\n\nmd_mod\nGestor principal del subsistema MD (creació i manteniment de /dev/mdX).\n\n\nraid0, raid1, raid5, raid6, raid10\nMòduls del kernel que implementen la lògica específica de cada nivell RAID.\n\n\nmdadm\nEina user-space que interactua amb el subsistema MD via ioctl i sysfs.\n\n\n/proc/mdstat\nPunt d’entrada per consultar estat de sincronització, reconstrucció i fallades.\n\n\n/sys/block/mdX\nDirectori amb informació detallada i opcions de configuració per a cada mdX."
  },
  {
    "objectID": "slides/03-filesystem-part2.html#flux-doperacions",
    "href": "slides/03-filesystem-part2.html#flux-doperacions",
    "title": "Sistema de fitxers (II)",
    "section": "Flux d’operacions",
    "text": "Flux d’operacions\n\n\n\n\n\nsequenceDiagram\n    participant A as Aplicació\n    participant B as Sistema de fitxers\n    participant C as VFS\n    participant D as /dev/mdX (md_mod)\n    participant E as Driver RAIDn\n    participant F as Discos físics\n\n    A-&gt;&gt;B: Read/Write\n    B-&gt;&gt;C: Operació de fitxer\n    C-&gt;&gt;D: Accés a /dev/mdX\n    D-&gt;&gt;E: Gestió RAID\n    E-&gt;&gt;F: Accés a discos físics\n\n\n\n\n\n\n\nLes operacions de paritat, mirroring o striping s’executen al context del kernel, sovint amb tasques asíncrones (mdX_raid_thread).\nLes metadades del RAID s’emmagatzemen al final (o inici) de cada disc com a superblock MD v1.x.\nDes del kernel 4.0 es pot utilitzar reshape per canviar el nivell RAID o afegir dispositius en viu."
  },
  {
    "objectID": "slides/03-filesystem-part2.html#paquet-mdadm",
    "href": "slides/03-filesystem-part2.html#paquet-mdadm",
    "title": "Sistema de fitxers (II)",
    "section": "Paquet mdadm",
    "text": "Paquet mdadm\nEn la majoria de les distribucions de Linux, el paquet mdadm permet la creació i gestió de dispositius RAID.\n\n\nDistribucions basades en Red Hat\ndnf search mdadm\ndnf install mdadm -y\n\nDistribucions basades en Debian\napt search mdadm\napt install mdadm -y\n\n\nEl funcionament del paquet mdadm és similar en totes les distribucions de Linux. Per tant, les instruccions d’ús són similars i no importa la distribució que s’utilitzeu."
  },
  {
    "objectID": "slides/03-filesystem-part2.html#creació-de-dispositius-raids",
    "href": "slides/03-filesystem-part2.html#creació-de-dispositius-raids",
    "title": "Sistema de fitxers (II)",
    "section": "Creació de Dispositius RAIDs",
    "text": "Creació de Dispositius RAIDs\n\n\nOpcions Bàsiques\nmdadm --create --verbose /dev/[nom] \n--level=[nivell] \n--raid-devices=[nº dispositius] [dispositius]\n\n--create: Crea un nou dispositiu RAID.\n--verbose: Mostra informació detallada sobre el procés.\n/dev/[nom]: Nom del dispositiu RAID.\n--level=[nivell]: RAID.\n--raid-devices=[nº dispositius]: Nombre de dispositius que formen el RAID.\n[dispositius]: Llista de dispositius que formen el RAID.\n\n\n\n\nAltres Opcions\nmdadm --create --help\n\n--metadata=[tipus]: Tipus de metadades.\n--spare-devices=[nº dispositius]: Nombre de dispositius reservats.\n--chunk=[mida]: Mida dels blocs.\n--layout=[esquema]: Esquema de distribució de les dades."
  },
  {
    "objectID": "slides/03-filesystem-part2.html#gestió-del-raid---manage",
    "href": "slides/03-filesystem-part2.html#gestió-del-raid---manage",
    "title": "Sistema de fitxers (II)",
    "section": "Gestió del RAID (--manage)",
    "text": "Gestió del RAID (--manage)\nmdadm --manage /dev/[nom] [options] [dispositius]\n  --add         -a   : afegeix dispositius posteriors a l'array\n  --re-add           : els dispositius posteriors són reafegits si eren\n                     : membres recents de l'array\n  --remove      -r   : elimina els dispositius posteriors, que no han d'estar actius\n  --fail        -f   : marca els dispositius posteriors com a defectuosos\n  --set-faulty       : igual que --fail\n  --replace          : marca el(s) dispositiu(s) per ser reemplaçat(s) per recanvis. \n                     : Un cop completat el reemplaçament, el dispositiu es marcarà \n                     : com a defectuós\n  --with             : indica quin recanvi hauria de preferir un '--replace' anterior\n  --run         -R   : inicia un array parcialment construït\n  --stop        -S   : desactiva l'array, alliberant tots els recursos\n  --readonly    -o   : marca l'array com a només lectura\n  --readwrite   -w   : marca l'array com a lectura i escriptura"
  },
  {
    "objectID": "slides/03-filesystem-part2.html#informació-i-monitoratge-del-raid",
    "href": "slides/03-filesystem-part2.html#informació-i-monitoratge-del-raid",
    "title": "Sistema de fitxers (II)",
    "section": "Informació i Monitoratge del RAID",
    "text": "Informació i Monitoratge del RAID\nLes opcions --detail i --examine permeten obtenir informació detallada sobre un dispositiu RAID. La principal diferència entre ambdues opcions és que --examine mostra informació més detallada sobre el dispositiu.\n\n\nmdadm --detail /dev/[nom]\n\nmdadm --examine /dev/[nom]\n\nLa opció --monitor permet monitorar un dispositiu RAID en temps real. Obtenint informació sobre els esdeveniments que es produeixen en el dispositiu i ens permet prendre accions en conseqüència.\nmdadm --monitor /dev/[nom]"
  },
  {
    "objectID": "slides/03-filesystem-part2.html#ensamblatge---assemble",
    "href": "slides/03-filesystem-part2.html#ensamblatge---assemble",
    "title": "Sistema de fitxers (II)",
    "section": "Ensamblatge --assemble",
    "text": "Ensamblatge --assemble\n\nPermet muntar un array RAID existent.\nAquesta opció no crea un nou array, sinó que reuneix un array existent a partir dels dispositius que especifiquem.\n\nmdadm --assemble /dev/[nom] [dispositius]\n\nCada cop que el sistema s’inicia, aquesta opció s’executa al kernel. Escaneja els discs, busca els superblocks i reconstrueix tots els arrays per a nosaltres."
  },
  {
    "objectID": "slides/03-filesystem-part2.html#initramfs-i-raid",
    "href": "slides/03-filesystem-part2.html#initramfs-i-raid",
    "title": "Sistema de fitxers (II)",
    "section": "Initramfs i RAID",
    "text": "Initramfs i RAID\nEn entorns amb RAID, initramfs inclou els binaris i la configuració necessaris per gestionar els arrays RAID. Durant la fase d’arrencada, es fa servir la comanda:\nmdadm --assemble --scan\nDetecta i munta automàticament tots els arrays definits a /etc/mdadm/mdadm.conf. Això assegura que les particions RAID estiguin operatives abans de muntar la partició root i iniciar el sistema operatiu.\nA més, initramfs pot incloure scripts per comprovar la integritat dels dispositius RAID i gestionar fallades de discs durant l’arrencada, assegurant un boot fiable en entorns amb mirroring (RAID1)."
  },
  {
    "objectID": "slides/03-filesystem-part2.html#actualització-amb---grow",
    "href": "slides/03-filesystem-part2.html#actualització-amb---grow",
    "title": "Sistema de fitxers (II)",
    "section": "Actualització amb --grow",
    "text": "Actualització amb --grow\nAquesta opció permet actualitzar un dispositiu RAID. Per exemple, canviar el RAID, augmentar el nombre de dispositius o canviar la mida dels blocs.\nmdadm --grow /dev/[nom] --level=[nivell] --raid-devices=[nº dispositius]\n\nSituació I: En un RAID5 format per 3 discs, ens pot interessar al cap del temps afegir un disc més.\nSituació II: En un RAID5 format per 4 discs, ens pot interessar al cap del temps canviar el RAID a 6.\nSituació III: En un RAID5 format per 4 discs, ens pot interessar al cap del temps canviar la mida dels blocs.\n\n\n\n\n\n\n\n\nCompte!\n\n\nAmb aquestes operacions, el sistema pot quedar inutilitzat. És recomanable fer una còpia de seguretat abans de realitzar aquestes operacions."
  },
  {
    "objectID": "slides/03-filesystem-part2.html#aturar-i-eliminar-un-raid",
    "href": "slides/03-filesystem-part2.html#aturar-i-eliminar-un-raid",
    "title": "Sistema de fitxers (II)",
    "section": "Aturar i Eliminar un RAID",
    "text": "Aturar i Eliminar un RAID\nPer aturar un RAID, podem utilitzar l’opció --stop del mode --manage de mdadm. Aquesta opció desactiva l’array i allibera tots els recursos associats.\nmdadm --manage /dev/[nom] --stop\n\n\n\n\n\n\n\nCompte!\n\n\nAquesta operació no destruirà l’array, sinó que simplement el desactivarà. Per eliminar un raid podem eliminar el seu dispositiu associat, sempre primer aturant l’array.\nmdadm --manage /dev/[nom] --stop\nrm /dev/[nom]"
  },
  {
    "objectID": "slides/03-filesystem-part2.html#etcmdadmmdadm.conf",
    "href": "slides/03-filesystem-part2.html#etcmdadmmdadm.conf",
    "title": "Sistema de fitxers (II)",
    "section": "/etc/mdadm/mdadm.conf",
    "text": "/etc/mdadm/mdadm.conf\nAquest fitxer conté informació que permet al sistema reconèixer i muntar automàticament els arrays RAID durant l’arrencada i també proporciona paràmetres per a la creació, monitorització i manteniment dels arrays.\nARRAY /dev/md0 UUID=12345678:90ab:cdef:1234:567890abcdef\nARRAY /dev/md1 UUID=abcdef12:3456:7890:abcd:ef1234567890\n\nARRAY: indica un dispositiu RAID gestionat per mdadm.\n/dev/mdX: dispositiu de bloc que representa l’array RAID.\nUUID: identificador únic de l’array RAID, utilitzat per assegurar que el sistema connecta correctament les particions corresponents encara que canviïn els noms dels dispositius físics (per exemple, vdb1 esdevé vdc1)."
  },
  {
    "objectID": "slides/03-filesystem-part2.html#cas-pràctic-i",
    "href": "slides/03-filesystem-part2.html#cas-pràctic-i",
    "title": "Sistema de fitxers (II)",
    "section": "Cas Pràctic (I)",
    "text": "Cas Pràctic (I)\nAssumeix que vols configurar un RAID per configurar la partició root del teu servidor Debian. quin RAID recomanaries i que t’aportaria?\n\nEl RAID 5. Aquest RAID ofereix redundància i una millora en la velocitat de lectura. No obstant això, requereix un mínim de tres discs i la velocitat d’escriptura pot veure’s afectada per les operacions de paritat. Aquest RAID pot ser una bona opció per a emmagatzemament de dades, però pot ser massa complex per a un sistema root.\nEl RAID 10 combina les característiques del RAID 1 i del RAID 0, oferint tant redundància com una millora en la velocitat de lectura i escriptura. Aquest RAID pot ser una bona opció per a un sistema que requereixi un alt rendiment, però pot ser massa costós per a un sistema root.\n\n\n\nLa meva recomanació és utilitzar RAID 1 per a un sistema root, ja que proporciona la redundància necessària per assegurar la integritat de les dades del sistema. Si la velocitat de lectura és una preocupació, es podria considerar l’ús d’un disc SSD"
  },
  {
    "objectID": "slides/03-filesystem-part2.html#cas-pràctic-ii",
    "href": "slides/03-filesystem-part2.html#cas-pràctic-ii",
    "title": "Sistema de fitxers (II)",
    "section": "Cas Pràctic (II)",
    "text": "Cas Pràctic (II)\nAssumeix que vols configurar un servidor amb dos discs SATA per fer renders de vídeo on l’objectiu principal es millorar el rendiment i la capacitat d’enmagatzemament temporal. Quin RAID recomanaries?\n\nCom únicament es disposa de dos discs, el RAID 0 seria la millor opció. Aquest RAID millora el rendiment i la capacitat d’emmagatzemament temporal, ja que les dades es divideixen i s’emmagatzemen en els dos discs de forma simultània. No obstant això, cal tenir en compte que el RAID 0 no ofereix cap mena de redundància. Per tant, si un dels discs falla, es perdran totes les dades. S’haurien de fer còpies de seguretat regulars per evitar la pèrdua de dades."
  },
  {
    "objectID": "slides/03-filesystem-part2.html#cas-pràctic-iii",
    "href": "slides/03-filesystem-part2.html#cas-pràctic-iii",
    "title": "Sistema de fitxers (II)",
    "section": "Cas Pràctic (III)",
    "text": "Cas Pràctic (III)\nAssumeix un servidor de bases de dades on la integritat de les dades es crítica i les transaccions han de ser ràpides. Quin RAID recomanaries?\n\nEn aquest cas, el RAID 10 seria la millor opció. Aquest RAID combina les característiques del RAID 1 i del RAID 0, oferint tant redundància com una millora en la velocitat de lectura i escriptura. Això és important per a un servidor de bases de dades on la integritat de les dades és crítica i les transaccions han de ser ràpides."
  },
  {
    "objectID": "slides/03-filesystem-part2.html#exercici",
    "href": "slides/03-filesystem-part2.html#exercici",
    "title": "Sistema de fitxers (II)",
    "section": "Exercici",
    "text": "Exercici\n\nConfiguració d’un RAID 1 a AlmaLinux amb una instal·lació neta.\nMigració de /home a un RAID 1 en un sistema Debian existent.\nSimulació de fallada d’un disc en un RAID 5.\nMigració d’un sistema legacy a un sistema amb RAIDs.\n\n\nExercicis: Administrant RAIDs"
  },
  {
    "objectID": "slides/03-filesystem-part2.html#thats-all",
    "href": "slides/03-filesystem-part2.html#thats-all",
    "title": "Sistema de fitxers (II)",
    "section": "That’s all",
    "text": "That’s all\n\n\n\n\n\n\n\n\n\nTake Home Message\n\n\n\nRAID manté les dades, però la bona administració manté el servei.\nLa redundància no és seguretat si no s’ha provat mai l’arrencada.\nConfigurar RAID és fàcil; garantir que arrenca quan els discs fallen és el camí de l’administrador.\nRAID no és substitut de les còpies de seguretat."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#benvinguda",
    "href": "slides/01-foundations-of-systems-administration.html#benvinguda",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Benvinguda",
    "text": "Benvinguda\n\n\n\n\n\n\n\n\n\n\n\nAdministració i Manteniment de Sistemes i Aplicacions (AMSA)\n\n\n1r Semestre, 3r Curs del Grau en Enginyeria Informàtica. Impartida per Jordi Mateo, professor del Departament d’Enginyeria Informàtica i Disseny Digital (DEIDD).\n\n\n\n\n\n\n\n\n\n(Font: Extret de Neowin)\n\n\n\n\nBenvinguts al curs 25/26 de Administració i Manteniment de Sistemes i Aplicacions. Aquesta assignatura pretén introduir-vos en el món de l’administració de sistemes i aplicacions, així com en la seva gestió i manteniment.\nAquesta vinyeta, amb un toc d’humor, il·lustra la dedicació d’un administrador de sistemes. Malgrat el caos i els reptes, la seva prioritat és assegurar que els sistemes funcionin correctament i estiguin sempre disponibles. Independentment del que passi fora de la sala de servidors. La seva feina consisteix a mantenir la infraestructura, prevenir problemes i resoldre’ls ràpidament per garantir la continuïtat dels serveis."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#què-és-ladministració-de-sistemes",
    "href": "slides/01-foundations-of-systems-administration.html#què-és-ladministració-de-sistemes",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Què és l’Administració de Sistemes?",
    "text": "Què és l’Administració de Sistemes?\n\n\n\n\nPer començar, m’agradaria conèixer la vostra opinió sobre què és l’Administració de Sistemes. Per fer-ho, crearem un núvol de paraules amb les vostres respostes, al final de curs analitzarem les respostes i veurem si la vostra opinió ha canviat. Enllaç al wordcloud"
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#què-és-ladministració-de-sistemes-1",
    "href": "slides/01-foundations-of-systems-administration.html#què-és-ladministració-de-sistemes-1",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Què és l’Administració de Sistemes?",
    "text": "Què és l’Administració de Sistemes?\n\n\n\n\nL’administració de sistemes és la disciplina tècnica que implica la configuració, la gestió, la supervisió i el manteniment continu d’infraestructures informàtiques (servidors, xarxes, emmagatzematge de dades, programari, seguretat, etc.), per garantir la seva disponibilitat, rendiment, seguretat i funcionalitat, amb l’objectiu de satisfer les necessitats operacionals i estratègiques de l’organització.\n\n\nSi preguntem a ChatGPT que ens defineixi formalment què és l’Administració de Sistemes, ens dirà que és la disciplina tècnica que implica la configuració, la gestió, la supervisió i el manteniment continu d’infraestructures informàtiques (servidors, xarxes, emmagatzematge de dades, programari, seguretat, etc.), per garantir la seva disponibilitat, rendiment, seguretat i funcionalitat, amb l’objectiu de satisfer les necessitats operacionals i estratègiques de l’organització."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#què-és-un-administrador",
    "href": "slides/01-foundations-of-systems-administration.html#què-és-un-administrador",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Què és un administrador?",
    "text": "Què és un administrador?\n\n\n\n\nUn administrador és una persona que té cura, gestiona o dirigeix els béns o els interessos d’una altra persona o entitat. En aquest cas, configurar, gestionar, supervisar i mantenir sistemes informatics.\n\n\nFixeu-vos en els elements clau de la definició:\nSegons la RAE, un administrador és una persona que té cura, gestiona o dirigeix els béns o els interessos d’una altra persona o entitat. En aquest cas, configurar, gestionar, supervisar i mantenir sistemes informatics. Això implica que la primera part de la definició de ChatGPT està en línia amb la definició de l’administrador."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#què-és-un-sistema",
    "href": "slides/01-foundations-of-systems-administration.html#què-és-un-sistema",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Què és un sistema?",
    "text": "Què és un sistema?\n\n\n\n\nUn sistema és un conjunt d’elements interconnectats que treballen junts per aconseguir un objectiu comú. El Sistema Informàtic està format per hardware, programari, dades, xarxes, persones, etc., que treballen junts per processar informació.\n\n\nSegons la RAE, un sistema és un conjunt d’elements interconnectats que treballen junts per aconseguir un objectiu comú. El Sistema Informàtic està format per hardware, programari, dades, xarxes, persones, etc., que treballen junts per processar informació. Això implica que la segona part de la definició de ChatGPT necessita ser més específica per reflectir la complexitat i diversitat dels sistemes informàtics i no únicament la infraestructura."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#quines-són-les-métriques-a-garantir",
    "href": "slides/01-foundations-of-systems-administration.html#quines-són-les-métriques-a-garantir",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Quines són les métriques a garantir?",
    "text": "Quines són les métriques a garantir?\n\nDisponibilitat: Capacitat d’un sistema per estar operatiu i accessible als usuaris en tot moment.\nRendiment: Mesura de l’eficiència amb què un sistema utilitza els recursos disponibles per executar tasques.\nSeguretat: Capacitat d’un sistema per protegir les dades i recursos contra accessos no autoritzats, atacs i pèrdues.\nFuncionalitat: Conjunt de característiques i capacitats que un sistema ofereix per complir amb els requisits operatius i les necessitats dels usuaris.\n\n\nA què ens referim quan diem garantir unes mètriques com la disponibilitat, el rendiment, la seguretat i la funcionalitat d’un sistema?\n\nDisponibilitat: La disponibilitat d’un sistema es refereix a la capacitat d’aquest de romandre operatiu i accessible als usuaris en tot moment, minimitzant el temps d’inactivitat. Això implica assegurar que el sistema estigui disponible per a l’ús en qualsevol moment, evitant interrupcions i fallades.\nRendiment: El rendiment d’un sistema es refereix a la mesura de l’eficiència amb què aquest utilitza els recursos disponibles per executar tasques de manera ràpida i efectiva. Això implica garantir que el sistema pugui processar dades i executar tasques de manera eficient, sense retards ni interrupcions.\nSeguretat: La seguretat d’un sistema es refereix a la capacitat d’aquest de protegir les dades i recursos contra accessos no autoritzats, atacs i pèrdues. Això implica implementar mesures de seguretat, com xifrat, autenticació, control d’accés i monitorització, per protegir la informació i els recursos del sistema.\nFuncionalitat: La funcionalitat d’un sistema es refereix al conjunt de característiques i capacitats que aquest ofereix per complir amb els requisits operatius i les necessitats dels usuaris. Això implica garantir que el sistema pugui realitzar les tasques i funcions requerides, oferint una experiència d’usuari satisfactòria i complint amb les expectatives dels usuaris."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#quines-són-les-necessitats-a-satisfer",
    "href": "slides/01-foundations-of-systems-administration.html#quines-són-les-necessitats-a-satisfer",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Quines són les necessitats a satisfer?",
    "text": "Quines són les necessitats a satisfer?\n\nNecessitats Operacionals: Requisits i objectius relacionats amb l’execució diària i el funcionament eficient dels sistemes, com ara la disponibilitat, el rendiment i la seguretat.\nNecessitats Estratègiques: Objectius i metes a llarg termini de l’organització, com ara la innovació, la competitivitat i l’adaptabilitat o la escalabilitat dels sistemes.\n\n\nFinalment, la definició de ChatGPT també fa referència a les necessitats operacionals i estratègiques de l’organització. Això implica que l’administració de sistemes no només es centra en garantir el funcionament i la seguretat dels sistemes, sinó que també té en compte els objectius i les metes de l’organització en conjunt. Això significa que els administradors de sistemes han de tenir en compte les necessitats operacionals i estratègiques de l’organització per garantir que els sistemes compleixin amb els requisits i expectatives de l’empresa."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#millorant-la-definició-feta-per-chatgpt",
    "href": "slides/01-foundations-of-systems-administration.html#millorant-la-definició-feta-per-chatgpt",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Millorant la definició feta per ChatGPT",
    "text": "Millorant la definició feta per ChatGPT\nL’administració de sistemes és la disciplina tècnica que implica la configuració, gestió, supervisió i manteniment continu d’infraestructures informàtiques (servidors, xarxes, emmagatzematge de dades, programari, seguretat, etc.)\naixí com la coordinació de les persones usuàries, polítiques, procediments i dades associades\nper garantir la disponibilitat, rendiment, seguretat i funcionalitat del sistema, amb l’objectiu de satisfer les necessitats operacionals i estratègiques de l’organització en conjunt.\n\nLa definició de ChatGPT no és incorrecta, però és una mica limitada. Un sistema no només està format per infraestructures (hardware, programari, xarxes, etc.), sinó que també inclou altres elements com les persones, les polítiques, els procediments, les dades que estan relacionades amb les necessitats operacionals i estratègiques. Per tant, la definició millorada inclou aquests elements per proporcionar una visió més completa de l’administració de sistemes."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#analogia-amb-matrix",
    "href": "slides/01-foundations-of-systems-administration.html#analogia-amb-matrix",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Analogia amb Matrix",
    "text": "Analogia amb Matrix\n\nQuants de vosaltres heu vist la pel·lícula Matrix? Què té a veure amb l’Administració de Sistemes?\n\n\n\n\n\nIntroducció a System Administration - CBT Nuggets (0:32 fins a 2:16)\n\n\n\n\nL’autor del clip fa una analogia entre l’administració de sistemes i la pel·lícula Matrix. En aquesta pel·lícula, els personatges principals són capaços de controlar i manipular el món virtual de Matrix, canviant la realitat a voluntat. Aquesta analogia reflecteix la capacitat dels administradors de sistemes per controlar i gestionar els sistemes informàtics, configurant-los, supervisant-los i mantenint-los per garantir el seu funcionament i seguretat. Compara matrix amb un super administrador de sistemes que controla tots els aspectes i us permet menjar dos pastilles per canviar la realitat (una de blava i una de vermella). Una us permet ser administrador de sistemes i l’altra us permet ser usuari de sistemes. Aquesta analogia és una manera divertida de visualitzar el paper dels administradors de sistemes i la seva capacitat per controlar i gestionar els sistemes informàtics."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#evolució",
    "href": "slides/01-foundations-of-systems-administration.html#evolució",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Evolució",
    "text": "Evolució\n\n\n\n\n\nsequenceDiagram\n    participant Maquinari\n    participant Virtualització\n    participant Contenidors\n    participant DevOps\n    participant IaC as Infraestructura com a Codi\n    participant FaaS as Funcions com a Servei\n\n    rect rgb(255, 255, 204)\n        Note over Maquinari: 1. Configuració Tradicional\n        Maquinari-&gt;&gt;Maquinari: L'administrador es centra en el hardware\n    end\n\n    rect rgb(204, 255, 204)\n        Note over Maquinari,Virtualització: 2. Virtualització\n        Maquinari-&gt;&gt;Virtualització: Aïllament de S.O.\n    end\n\n    rect rgb(204, 255, 255)\n        Note over Maquinari,DevOps: 3. Contenidors i DevOps\n        Virtualització-&gt;&gt;Contenidors: Aïllament d'aplicacions\n        Contenidors-&gt;&gt;DevOps: Faciliten el desplegament continu\n    end\n\n    rect rgb(255, 204, 255)\n        Note over Maquinari,IaC: 4. Infraestructura com a Codi (IaC)\n        DevOps-&gt;&gt;IaC: Automatització total de la infraestructura\n    end\n\n    rect rgb(255, 204, 204)\n        Note over Maquinari,FaaS: 5. Funcions com a Servei (FaaS)\n        IaC-&gt;&gt;FaaS: Abstracció completa de la plataforma\n    end\n\n\n\n\n\n\n\nFa una dècada, el món del software i el hardware era molt diferent del que coneixem avui en dia. Els servidors eren físics, les aplicacions s’executaven en un únic servidor i la infraestructura era estàtica i difícil de modificar. Els administradors de sistemes treballaven en un entorn dominat pel hardware i els cables, dedicant moltes hores a configurar i mantenir els servidors. Al mateix temps, els desenvolupadors de software operaven en un univers separat, on les aplicacions s’executaven en servidors físics i tenien poc control sobre la infraestructura. Aquesta separació va generar una divisió notable entre els dos grups, amb escassa comunicació i col·laboració.\nLa situació va canviar radicalment amb l’arribada de la virtualització. Aquesta tecnologia va permetre als administradors de sistemes crear màquines virtuals i clons de servidors, simplificant enormement la gestió i configuració de la infraestructura. La virtualització va marcar un punt d’inflexió, transformant la manera de gestionar els sistemes i permetent als desenvolupadors provar i desplegar aplicacions en entorns aïllats, millorant així la qualitat i fiabilitat del software i apropant els dos grups.\nL’aparició dels contenidors va suposar un altre gran avanç en l’administració de sistemes. Aquesta tecnologia va permetre als desenvolupadors empaquetar aplicacions i les seves dependències en contenidors lleugers i portàtils, que podien ser executats en qualsevol entorn. Això va impulsar el concepte de DEVOPS, facilitant la col·laboració entre els equips de desenvolupament i operacions per automatitzar i millorar els processos de desplegament, monitorització i gestió de la infraestructura.\nDEVOPS va emergir com a resposta a aquest canvi, promovent la col·laboració, comunicació i integració entre els equips de desenvolupament i operacions, amb l’objectiu de millorar la qualitat del software i accelerar el desplegament d’aplicacions. Aquesta metodologia va permetre als equips treballar conjuntament per automatitzar i perfeccionar els processos relacionats amb la infraestructura.\nLa pràctica de Infrastructure as Code (IAC) va completar aquest procés, permetent gestionar la infraestructura de manera programàtica mitjançant codi. Això va permetre als equips de desenvolupament i operacions tractar la infraestructura com a codi, aplicant les mateixes pràctiques de desenvolupament de software en la seva gestió. Com a resultat, la col·laboració, integració i automatització dels processos van millorar, augmentant la fiabilitat i escalabilitat de la infraestructura.\nFinalment, amb l’aparició dels conceptes serverless i Function as a Service (FAAS), la diferenciació entre desenvolupament i operacions va desaparèixer completament. Aquest nou model (actual) permet als desenvolupadors executar funcions de manera aïllada i eficient, sense preocupar-se de la infraestructura subjacent. Aquesta nova forma de treballar ha millorat la productivitat i flexibilitat dels equips de desenvolupament, facilitant el desenvolupament i desplegament d’aplicacions en entorns dinàmics i escalables. Els administradors de sistemes han evolucionat de tècnics centrats en la infraestructura a enginyers de sistemes i aplicacions, amb un enfocament més ampli i integrat en el desenvolupament de software."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#sortides-professionals",
    "href": "slides/01-foundations-of-systems-administration.html#sortides-professionals",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Sortides Professionals",
    "text": "Sortides Professionals\n\n\nL’administració de sistemes és una disciplina àmplia i diversa, que no segueix una única via d’aprenentatge. Aquesta professió inclou una gran varietat de rols i especialitzacions, però no compta amb un itinerari professional clarament establert, fet que dificulta l’ensenyament de tots els seus aspectes en una sola assignatura. Si observeu el pla d’estudis del Grau en Enginyeria Informàtica, veureu que inclou assignatures orientades a la programació, amb sortides professionals com a desenvolupadors de software en diferents àmbits. Alhora, també ofereix formació en computació (xarxes, sistemes operatius, bases de dades), amb possibilitats laborals com a enginyer de xarxes o administrador de bases de dades.\nTradicionalment, l’administració de sistemes ha estat vinculada a les operacions, amb sortides professionals com a tècnic de suport o tècnic de centre de dades, sovint allunyades dels perfils d’un enginyer informàtic. No obstant això, avui en dia, l’administració de sistemes ha evolucionat significativament, donant lloc a perfils més avançats i tècnics com DevOps, SRE (Site Reliability Engineer), i Cloud Engineer, que ofereixen oportunitats laborals molt més atractives i alineades amb les necessitats del mercat actual.\nAquesta assignatura té com a objectiu introduir-vos al món de l’administració de sistemes i aplicacions, així com a la seva gestió i manteniment. Ho farem amb una visió actualitzada, orientada cap a les sortides professionals més demandades en el mercat laboral, preparant-vos per a perfils amb més responsabilitat i especialització dins del camp de les tecnologies de la informació."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#objectius-del-curs",
    "href": "slides/01-foundations-of-systems-administration.html#objectius-del-curs",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Objectius del curs",
    "text": "Objectius del curs\n\nIntroduir-vos en el món de l’administració de sistemes i aplicacions, així com en la seva gestió i manteniment.\nRepasar llenguatges de programació i scripting per a l’automatització de tasques. Bash, AWK, YAML, que ens permetran utilitzar eines com Ansible, AWS CloudFormation, Docker, Kubernetes, etc.\nApendre a gestionar, configurar i monitoritzar servidors en entorns físics i virtuals.\nIntroduir-vos en el món del Cloud Computing i les seves principals plataformes (AWS, Azure, Google Cloud).\nDesplegar serveis Web, Bases de Dades, Aplicacions i Infraestructures en diferents entorns."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#metodologia",
    "href": "slides/01-foundations-of-systems-administration.html#metodologia",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Metodologia",
    "text": "Metodologia\n\nTeoria: En aquestes sessions, es presentaran els continguts teòrics de l’assignatura, que es complementaran amb exemples il·lustratius. Com a material de suport, s’utilitzaran les diapositives de l’assignatura.\nPràctiques: Aquestes sessions es basen en una metodologia activa i asincrònica que permet a cada estudiant o grup avançar al seu ritme. El contingut és autosuficient, i la funció del professor és fomentar el debat i ajudar a resoldre dubtes.\nTreball autònom: Aquesta part del curs implica la finalització dels laboratoris i l’elaboració d’informes a partir dels reptes proposats. També inclou la lectura i visualització de documentació tècnica; així com la realització d’activitats al cloud AWS."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#planificació-part-i",
    "href": "slides/01-foundations-of-systems-administration.html#planificació-part-i",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Planificació Part I",
    "text": "Planificació Part I\n\n\n\n\n\n\n\n\nSet.\nDilluns\nDimecres\n\n\n\n\n1a\n-\nU1: Fonaments de l’Administració\n\n\n2a\nU2: Procés d’Arrencada i Inicialització del Sistema\nU2: Procés d’Arrencada i Inicialització\n\n\n3a\nU2: Procés d’Arrencada i Inicialització del Sistema\nU2: Procés d’Arrencada i Inicialització\n\n\n4a\nU3: Sis. de Fitxers i Emmagatzematge\nU3: Sis. de Fitxers i Emmagatzematge\n\n\n5a\nU3: Sis. de Fitxers i Emmagatzematge\nU3: Sis. de Fitxers i Emmagatzematge\n\n\n6a\nU3: Sis. de Fitxers i Emmagatzematge\nU4: Autenticació i Autorització\n\n\n7a\nU4: Autenticació i Autorització\nU4: Autenticació i Autorització\n\n\n8a\nWorkshop\nWorkshop\n\n\n9a\nPARCIALS"
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#planificació-part-ii",
    "href": "slides/01-foundations-of-systems-administration.html#planificació-part-ii",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Planificació Part II",
    "text": "Planificació Part II\n\n\n\nSet.\nDilluns\nDimecres\n\n\n\n\n10a\nU5: Virtualització\nU5: Virtualització\n\n\n11a\nU5: Virtualització\nU5: Virtualització\n\n\n12a\nU6: Computació en el Núvol\nU6: Computació en el Núvol\n\n\n13a\nU6: Computació en el Núvol\nU6: Computació en el Núvol\n\n\n14a\n-\nU7: Orquestració i CI/CD\n\n\n15a\nWorkshop\nWorkshop\n\n\n16a\nPARCIALS\n\n\n\n17a\n\n\n\n\n18a\n\n\n\n\n19a\nRECUPERACIONS"
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#criteris-davaluació",
    "href": "slides/01-foundations-of-systems-administration.html#criteris-davaluació",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Criteris d’Avaluació",
    "text": "Criteris d’Avaluació\n\n\n\n\n\n\n\n\n\n\nActivitat\nPes\nRecuperable?\nNota Mínima?\nGrup?\n\n\n\n\nExamen 1\n35%\nSí\nNo\nNo\n\n\nExamen 2\n35%\nSí\nNo\nNo\n\n\nLaboratori\n20%\nNo\nSí\nSí\n\n\nActivitats Async\n5%\nNo\nNo\nNo\n\n\nSeguiment i participació\n5%\nNo\nNo\nNo"
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#exàmens",
    "href": "slides/01-foundations-of-systems-administration.html#exàmens",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Exàmens",
    "text": "Exàmens\nEls exàmens parcials (E1 i E2) són proves escrites que avaluen els coneixements teòrics i pràctics adquirits durant el curs.\n\nSón proves individuals i presencials.\nEs realitzaran en les dates establertes al calendari acadèmic.\nNo es permet l’ús de cap dispositiu electrònic (telèfons mòbils, ordinadors portàtils o tauletes).\nSi es permet l’ús d’un resum de continguts, que ha de ser un document escrit a mà i no pot excedir una fulla DIN A4 (per davant i per darrere)."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#recuperació",
    "href": "slides/01-foundations-of-systems-administration.html#recuperació",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Recuperació",
    "text": "Recuperació\n\nEls parcials són recuperables mitjançant proves escrites addicionals que es realitzaran durant la setmana de recuperació.\nSi un estudiant necessita recuperar un únic parcial (E1 o E2), podrà fer una prova específica per a aquest parcial. La qualificació obtinguda en aquesta recuperació substituirà la nota del parcial corresponent.\nSi un estudiant necessita recuperar ambdós parcials, haurà de realitzar dues proves separades, una per a cada parcial (E1 i E2). Les qualificacions obtingudes en cadascuna d’aquestes proves de recuperació substituiran les notes originals dels parcials respectius.\nÉs important notar que no hi haurà un model d’examen unificat per a la recuperació; cada prova de recuperació se centrarà exclusivament en els continguts del parcial al qual correspon."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#pràctiques",
    "href": "slides/01-foundations-of-systems-administration.html#pràctiques",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Pràctiques",
    "text": "Pràctiques\n\nLes pràctiques de l’assignatura impliquen treball fora de l’aula i s’han de lliurar de forma estricta en les dates establertes.\nLa seva avaluació es farà mitjançant rúbriques de correcció, que estaran disponibles per als estudiants amb antelació.\nEl professorat pot entrevistar els estudiants per verificar l’autoria. Si es detecta que una activitat no ha estat realitzada per l’estudiant la seva qualificació serà 0.\nQualsevol entrega fora del termini establert es considerarà no vàlida i es qualificarà amb un 0.\nCadascuna pot tenir una ponderació específica indicada a la descripció de l’activitat.\nAquestes pràctiques no són recuperables.\nTot i ser activitats en grup, cada estudiant pot obtenir una nota diferent en funció de la seva participació i aportacions individuals al grup."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#activitats-asíncrones-a-aws",
    "href": "slides/01-foundations-of-systems-administration.html#activitats-asíncrones-a-aws",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Activitats Asíncrones a AWS",
    "text": "Activitats Asíncrones a AWS\nAquestes activitats asíncrones es realitzaran a la plataforma AWS al llarg del curs. La seva finalitat és que completis totes les activitats i laboratoris proposats, ja que la qualificació es basarà íntegrament en la finalització d’aquests. Completar totes les tasques et donarà el 5% de la nota final. Si en fas només una part, la puntuació serà proporcional a les activitats que hagis realitzat.\n\nNo recuperable: Aquesta activitat no disposa de recuperació.\nData límit: La data màxima per a la presentació i finalització és el dia de l’E2.\nValor afegit: Obtenció d’un certificat oficial AWS."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#seguiment-i-participació",
    "href": "slides/01-foundations-of-systems-administration.html#seguiment-i-participació",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Seguiment i Participació",
    "text": "Seguiment i Participació\n\n\n\n\n\n\n\nRúbrica d’Avaluació\n\n\n\n\n\n\n\n\n\n\n\nPunts\nParticipació Presencial\nParticipació en Fòrums\nActivitats Sessió\n\n\n\n\n10\nContribucions excepcionals,enriqueix la discussió.\nLíder en discussions, promou debat.\nQualitat excepcional, supera expectatives.\n\n\n9\nComentaris rellevants, mostra comprensió, escolta activament.\nRespostes significatives.\nAlta qualitat, treball precís.\n\n\n8\nContribucions regulars, interactua amb companys.\nPublicacions rellevants, contribueix constructivament.\nCompleix tots requisits amb precisió.\n\n\n7\nParticipa amb una comprensió bàsica.\nCompleix mínims, contribucions breus.\nQualitat inconsistent però acceptable.\n\n\n5-6\nPoca freqüència, comentaris superficials.\nPublicacions rares, poc profundes.\nAlgunes activitats incompletes.\n\n\n1-4\nNomés participa si se li demana.\nPublicacions irrellevants.\nRarament completa activitats.\n\n\n0\nEvita participar, distret.\nPublicacions fora de tema.\nNo lliura activitats.\n\n\n\n\n\n\n\n\nL’assistència passiva no es puntua.\n\n\nAquest component d’avaluació està dissenyat per fomentar la participació activa i el compromís amb l’assignatura. La participació no es limita només a l’assistència a classe, sinó que també inclou la contribució en discussions, fòrums en línia i activitats relacionades amb les sessions. Tota participació ha de ser rellevant i constructiva per ser valorada positivament. En aquesta rúbrica, es detallen els criteris específics que s’utilitzaran per avaluar la participació dels estudiants en diferents àmbits."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#bonus-1",
    "href": "slides/01-foundations-of-systems-administration.html#bonus-1",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Bonus 1",
    "text": "Bonus 1\n\n\n\nObjectiu: Fomentar la reflexió i l’autoavaluació dels continguts treballats a classe.\nMetodologia: Cada setmana, els estudiants han de fer un commit al seu repositori d’apunts amb les notes de les sessions de teoria i pràctiques.\nAvaluació: Es valorarà la qualitat de les notes, la seva coherència i la seva relació amb els continguts treballats, així com les reflexions i opinions personals incloses.\nPer participar cal crear un repositori a Github (públic) i fer-me arribar l’enllaç.\n\n\n\n\nExemple de Notes\n## Setmana X\n\n# Resum teòric\n\n# Exemples pràctics\n\n# Dubtes i preguntes\n\n# Reflexions personals\n\n\n\n\n\n\n\nNo es permet cap altre forma\n\n\nLes notes han de ser escrites en format Markdown i mantingudes en un repositori Git i Github.\n\n\n\n\n\n\nAquest bonus està dissenyat per incentivar els estudiants a mantenir un registre organitzat i reflexiu dels continguts treballats a classe. En fer un commit setmanal amb les seves notes, els estudiants no només reforcen el seu aprenentatge, sinó que també desenvolupen habilitats de documentació i autoavaluació. La qualitat de les notes serà clau en l’avaluació, ja que es valorarà no només la precisió dels continguts, sinó també la capacitat de reflexionar sobre el que s’ha après i com s’ha aplicat aquest coneixement. Es tracta d’una oportinitat per als estudiants per crear el seu diari d’aprenentatge al llarg del curs. Per participar, els estudiants han de crear un repositori públic a Github i compartir l’enllaç amb el professorat."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#bonus-2",
    "href": "slides/01-foundations-of-systems-administration.html#bonus-2",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Bonus 2",
    "text": "Bonus 2\n\n\n\nEls materials són Open Source.\nQualsevol estudiant pot detectar errors, millorar els materials o afegir continguts nous.\nS’avaluarà la quantitat i qualitat.\n\n\n\n\n\nUn altre bonus que oferim és la possibilitat de contribuir als materials de l’assignatura seguint la metodologia de Open Source. Això significa que qualsevol estudiant pot detectar errors, suggerir millores o afegir continguts nous als materials proporcionats. Per participar, els estudiants poden fer un fork del repositori de l’assignatura, treballar en una branca separada i després obrir una pull request amb les seves propostes de canvi. La quantitat i qualitat de les contribucions seran avaluades, oferint així una oportunitat per als estudiants de participar activament en la millora dels recursos educatius."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#gestió-del-curs",
    "href": "slides/01-foundations-of-systems-administration.html#gestió-del-curs",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Gestió del curs",
    "text": "Gestió del curs\n\nEs demana que els estudiants arribin puntuals a les sessions. L’entrada tardana pot interrompre la dinàmica de la classe i el treball dels companys.\nEs demana que els estudiants respectin les normes de convivència i respecte mutu durant les sessions de classe. Això inclou evitar interrupcions innecessàries, escoltar activament als companys i al professor, i mantenir un ambient de treball positiu i constructiu."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#comunicació-amb-el-professorat",
    "href": "slides/01-foundations-of-systems-administration.html#comunicació-amb-el-professorat",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Comunicació amb el professorat",
    "text": "Comunicació amb el professorat\n\nIntenteu comunicar-vos a través del correu electrònic i no per l’eina del campus virtual per assegurar una resposta més ràpida.\nLes sessions de tutoria es realitzaran de manera presencial o virtual, segons les necessitats dels estudiants. És important que els estudiants sol·licitin cita prèvia per a les tutories utilitzant el correu electrònic jordi.mateo@udl.cat indicant el motiu de la consulta i la disponibilitat horària i afegint l’assumpte [AMSA]: Sol·licitud de Tutoria."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#treball-individual",
    "href": "slides/01-foundations-of-systems-administration.html#treball-individual",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Treball individual",
    "text": "Treball individual\n\nCada estudiant és responsable de la seva pròpia feina i de com gestiona el seu temps.\nL’assistència a classe no és obligatòria.\nCada alumne ha de presentar evidències pròpies del treball realitzat, encara que es col·labori en grup."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#ús-de-la-iag",
    "href": "slides/01-foundations-of-systems-administration.html#ús-de-la-iag",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Ús de la IAG",
    "text": "Ús de la IAG\n\nPots utilitzar eines d’IAG per generar idees, entendre conceptes complexos o esbossar l’estructura inicial del teu codi o projecte. No obstant això, la implementació i la versió final han de ser sempre de la teva autoria.\nEstà estrictament prohibit presentar codi o solucions generades directament per una IAG com a treball propi (és a dir, mitjançant un simple copiar i enganxar).\nSi incorpores material assistit per una IAG, has de declarar-ho explícitament. Això implica identificar clarament les seccions generades per IAG i proporcionar el prompt exacte utilitzat per crear-les.\n\n\nL’incompliment d’aquestes directrius es considerarà una violació de la integritat acadèmica.\n\n\nQualificació de zero en la tasca.\nConseqüències disciplinàries que estableix la Normativa de Convivència de la UdL per frau acadèmic."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#eines",
    "href": "slides/01-foundations-of-systems-administration.html#eines",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Eines",
    "text": "Eines\n\nOrdinador portàtil amb connexió a Internet.\n\nEs recomana portar el vostre propi ordinador per cursar l’assignatura.\nSi no disposeu d’ordinador, podreu utilitzar els ordinadors de la classe durant les sessions de laboratori.\n\nDistribucions Linux (Debian i AlmaLinux)\n\nÉs obligatori utilitzar les distribucions indicades als laboratoris. Altres distribucions no rebran suport.\n\nSoftware de virtualització (VMWare i QEMU)\n\nEs recomana utilitzar VMWare i QEMU, però podeu optar per altres opcions de virtualització. Heu de ser capaços d’adaptar el material al vostre programari de virtualització.\n\nCompte a AWS"
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#materials-i-recursos",
    "href": "slides/01-foundations-of-systems-administration.html#materials-i-recursos",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Materials i Recursos",
    "text": "Materials i Recursos\n\nApunts de l’assignatura i materials proporcionats pel professor.\nDocumentació oficial de les eines i tecnologies utilitzades.\nFòrums tècnics a la xarxa com Stack Overflow, Reddit, etc\nLlibres de referència en administració de sistemes:\n\n“UNIX and Linux System Administration Handbook” de Evi Nemeth, Garth Snyder, Trent R. Hein, Ben Whaley.\n“The Practice of System and Network Administration” de Thomas A. Limoncelli, Christina J. Hogan, Strata R. Chalup."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#el-rol-de-ladministrador-de-sistemes---similituds-amb-un-bomber",
    "href": "slides/01-foundations-of-systems-administration.html#el-rol-de-ladministrador-de-sistemes---similituds-amb-un-bomber",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "El rol de l’administrador de sistemes - Similituds amb un bomber",
    "text": "El rol de l’administrador de sistemes - Similituds amb un bomber\n\nEls administradors de sistemes han de tenir coneixements tècnics profunds i una actitud proactiva per anticipar problemes i, si cal, resoldre’ls sota pressió, tal com ho faria un bomber en una emergència.\n\n\n\n\n\nEl rol tradicional de l’aministrador de sistemes pot ser semblant al d’un bomber. Ha de treballar per prevenir incendis, però quan hi ha un incendi ha de córrer per apagar-lo i restaurar la situació el més ràpid. No importa l’hora, el lloc o el dia, l’administrador de sistemes ha de ser capaç de respondre a les emergències i solucionar els problemes de manera eficient i efectiva. Això requereix una gran habilitat tècnica, coneixements profunds dels sistemes i una actitud proactiva per anticipar-se als problemes i resoldre’ls ràpidament. Els administradors de sistemes han de ser tant proactius com reactius, prevenint problemes i responent ràpidament davant els imprevistos per garantir la continuïtat del servei. Poden utilitzar eines com Nagios, Zabbix, Prometheus per monitoritzar els sistemes i detectar problemes abans que es converteixin en emergències reals. Però, han d’intervenir i improvisar quan calgui per resoldre els problemes i restaurar la normalitat."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#el-rol-de-ladministrador-de-sistemes---similituds-amb-un-científic",
    "href": "slides/01-foundations-of-systems-administration.html#el-rol-de-ladministrador-de-sistemes---similituds-amb-un-científic",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "El rol de l’administrador de sistemes - Similituds amb un científic",
    "text": "El rol de l’administrador de sistemes - Similituds amb un científic\n\n\n\n\n\n\n\nEls administradors de sistemes han de ser capaços de resoldre problemes complexos i trobar solucions creatives.\nAixò pot ser semblant al treball d’un científic, que ha de plantejar hipòtesis, realitzar experiments i analitzar dades per arribar a conclusions.\nPer exemple, una empresa pot necessitar donar codis d’accés temporals als usuaris per connectar-se a la xarxa Wifi. En lloc de gestionar-ho manualment, un administrador de sistemes va crear un sistema que generava codis d’accés temporals quan els usuaris tocaven un platan connectada a un Raspberry Pi.\n\n\n\nUn altra característica de l’administrador de sistemes és la seva capacitat per resoldre problemes complexos i trobar solucions creatives. Això pot ser semblant al treball d’un científic, que ha de plantejar hipòtesis, realitzar experiments i analitzar dades per arribar a conclusions.\nPer exemple, una empresa pot necessitar donar codis d’accés temporals als usuaris per connectar-se a la xarxa Wifi. En lloc de gestionar-ho manualment, un administrador de sistemes va crear un sistema que generava codis d’accés temporals quan els usuaris tocaven un platan connectada a un Raspberry Pi. Aquesta solució creativa i inesperada va permetre automatitzar una tasca manual i millorar l’experiència de l’usuari. Això demostra la capacitat de l’administrador de sistemes per trobar solucions innovadores i eficients als problemes que es presenten."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#salari-administrador-de-sistemes",
    "href": "slides/01-foundations-of-systems-administration.html#salari-administrador-de-sistemes",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Salari Administrador de Sistemes",
    "text": "Salari Administrador de Sistemes\n\n\n\n\n\nEl salari base segons el portal payscale a Espanya és de mitjana 30k amb un potencial de creixement a futtur de 10k. Aquesta dada és orientativa i pot variar segons la ubicació, l’experiència, les habilitats i la formació del professional. Però, en comparativa amb altres sortides professionals, l’administrador de sistemes igual no és una opció interessant. Analitzem ara sortides professionals més especialitzades."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#especialitzacions-en-administració-de-sistemes",
    "href": "slides/01-foundations-of-systems-administration.html#especialitzacions-en-administració-de-sistemes",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Especialitzacions en Administració de Sistemes",
    "text": "Especialitzacions en Administració de Sistemes\n\n\n\nAdministradors de Xarxa, Enmagatzematge, Seguretat\nOperadors de Xarxa\nArquitectes de Sistemes\nTècnics de Suport\nTècnics de Centre de Dades\nEnginyers de Sistemes\nEnginyer DEVOPS\nEnginyer SRE (Site Reliability Engineer)\n\n\n\n\n\nHi ha una gran varietat d’especialitzacions dins l’àmbit de l’administració de sistemes, cada una amb responsabilitats úniques que poden influir en el salari i els rols. A continuació, detallem algunes d’aquestes especialitzacions:\n\nAdministradors de Xarxa: S’encarreguen de la configuració, gestió i manteniment de routers, switches, firewalls i altres dispositius de xarxa en entorns físics i virtuals. La seva tasca és garantir la connectivitat i seguretat de les xarxes de l’empresa.\nAdministradors de Emmagatzematge: Gestionen sistemes de fitxers, solucions de còpies de seguretat i tecnologies d’emmagatzematge de dades com NETAPP o EMC. Són responsables d’assegurar que les dades estiguin segures i accessibles.\nAdministradors de Seguretat: Protegeixen els sistemes informàtics contra amenaces i atacs cibernètics. Implementen polítiques de seguretat, gestionen certificats digitals i realitzen auditories de seguretat per protegir la informació sensible.\nOperadors de Xarxa: Supervisionen el funcionament diari de les xarxes, gestionant el trànsit de dades i resolent problemes de connexió o rendiment. S’asseguren que les xarxes funcionin sense interrupcions.\nArquitectes de Sistemes: Dissenyen i planifiquen la infraestructura tecnològica de l’empresa. Són responsables d’assegurar que els sistemes compleixin els requisits de rendiment, seguretat i escalabilitat.\nTècnics de Suport: Ofereixen assistència tècnica als usuaris, resolent problemes i incidents a través de sistemes de tickets. La seva tasca és garantir que els usuaris puguin utilitzar les tecnologies sense problemes.\n\n-Tècnics de Centre de Dades: Gestionen i mantenen els servidors, xarxes i altres equips físics en els centres de dades. S’asseguren que el centre de dades funcioni amb alta disponibilitat i rendiment.\n\nEnginyers de Sistemes: Són responsables de dissenyar, implementar i mantenir la infraestructura informàtica de l’empresa. La seva tasca és assegurar que els sistemes compleixin els requisits operatius i tècnics.\n\nAra veurem dues especialitzacions més avançades i amb més demanda en el mercat laboral actual: Enginyer DEVOPS i Enginyer SRE (Site Reliability Engineer) amb detall. També us deixo un enllaç a un llibre que parla de les diferents especialitzacions."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#què-és-un-site-reliability-engineer-sre",
    "href": "slides/01-foundations-of-systems-administration.html#què-és-un-site-reliability-engineer-sre",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Què és un Site Reliability Engineer (SRE)?",
    "text": "Què és un Site Reliability Engineer (SRE)?\nEls Site Reliability Engineers (SRE) són enginyers de sistemes especialitzats en la fiabilitat i l’escalabilitat dels sistemes informàtics. Estan centrats en les operacions, utilitzant el software com a eina per gestionar els sistemes, solucionar els afers i automatitzar tasques. Les seves missions són crear sistemes escalables i fiables.\n\nFiabilitat del Sistema: Nagios, Zabbix, Prometheus.\nEscalabilitat: Kubernetes, Docker, Terraform.\nMonitorització i Alertes: Grafana, ELK Stack, PagerDuty.\nGestió d’Incidents: Jira, ServiceNow, Slack.\nOptimització de Rendiment: New Relic, Datadog, AppDynamics.\nAutomatització de Processos: Ansible, Puppet, Chef.\n\n\nAmb l’evolució contínua de les tecnologies cloud i l’augment de la demanda de serveis digitals, les pràctiques de Site Reliability Engineering (SRE) s’han convertit en una peça clau per a moltes organitzacions. Un SRE es pot definir com un professional especialitzat en garantir que les empreses compleixin els seus Acords de Nivell de Servei (SLA) pel que fa a disponibilitat, rendiment, experiència de l’usuari i indicadors clau de negoci (KPIs). Això implica centrar-se en la millora de la fiabilitat i l’escalabilitat dels sistemes, així com en la implementació de pràctiques d’integració i lliurament continu (CI/CD), reforçar la seguretat i optimitzar els costos operatius.\nEls SREs aprofiten el programari com una eina per gestionar i automatitzar els sistemes, identificar i resoldre problemes, i automatitzar processos amb l’objectiu final de construir infraestructures escalables i fiables que responguin als objectius de negoci.\nLes funcions principals d’un SRE inclouen la monitorització constant dels sistemes, la gestió d’alertes i resposta a incidents, l’automatització de tasques rutinàries, i l’optimització de l’escala i adaptabilitat dels recursos tecnològics. A més, col·laboren estretament amb els equips de desenvolupament per assegurar la millora contínua de la fiabilitat i el rendiment dels sistemes."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#salari-dun-site-reliability-engineer",
    "href": "slides/01-foundations-of-systems-administration.html#salari-dun-site-reliability-engineer",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Salari d’un Site Reliability Engineer",
    "text": "Salari d’un Site Reliability Engineer\n\n\n\n\n\nEls Site Reliability Engineers (SREs) experimenten un increment salarial substancial en comparació amb els administradors de sistemes. Un SRE pot començar guanyant fins a 50.000 € durant el seu primer any, i amb l’experiència, arribar fins als 70.000 € o més en un termini de cinc anys. Aquest diferencial salarial reflecteix la creixent importància i demanda de professionals especialitzats en la fiabilitat i escalabilitat dels sistemes informàtics. A diferència dels administradors de sistemes, els SREs no només es dediquen a mantenir la infraestructura, sinó que també se centren en optimitzar la resiliència i eficiència dels serveis digitals, assegurant que compleixin els Acords de Nivell de Servei (SLA). Per tant, si t’interessa un rol amb responsabilitats més tècniques i un potencial de creixement major, el camí d’SRE pot ser una opció molt atractiva dins del mercat laboral actual. Les seves responsabilitats dins de l’empresa són molt importants i tenen un impacte directe amb els objectius de negoci."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#què-és-un-devops-engineer",
    "href": "slides/01-foundations-of-systems-administration.html#què-és-un-devops-engineer",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Què és un DevOps Engineer?",
    "text": "Què és un DevOps Engineer?\nEls DevOps Engineers són professionals clau en la integració i col·laboració entre els equips de desenvolupament (Dev) i operacions (Ops), amb l’objectiu principal de millorar l’eficiència i agilitat dels processos de desenvolupament de software. El seu treball se centra en accelerar el desplegament d’aplicacions, millorar la qualitat del software i optimitzar els fluxos de treball, fent ús intensiu de l’automatització, la integració contínua (CI) i el lliurament continu (CD).\n\nAutomatització: Jenkins, GitLab CI, Bamboo.\nGestió d’infraestructura com a codi (IaC): Terraform, Ansible, CloudFormation.\nContenidors i orquestració: Docker, Kubernetes.\nMonitorització i registre: Prometheus, Grafana, ELK Stack.\nCol·laboració i comunicació: Slack, Jira, Confluence.\n\n\nMentre que els Sysadmins tradicionalment s’ocupen de la gestió i manteniment de la infraestructura, com ara servidors, xarxes i sistemes operatius, els DevOps Engineers van més enllà d’aquestes tasques. El seu rol inclou l’automatització de processos, la implementació de pipelines de CI/CD, la gestió de contenidors (com Docker) i la infraestructura com a codi (IaC), com Terraform o Ansible. En lloc d’enfocar-se només en el manteniment i la disponibilitat dels sistemes, els DevOps Engineers treballen per integrar millor el desenvolupament i les operacions, assegurant que els nous llançaments de software siguin ràpids, segurs i consistents.\nTot i que hi ha solapaments entre DevOps i SRE, les diferències clau radican en l’enfocament i les prioritats. Mentre que els DevOps Engineers se centren en l’optimització dels processos de desenvolupament i operacions a través de la col·laboració i l’automatització, els SREs estan més orientats a la fiabilitat i escalabilitat dels sistemes en producció. El SRE té un enfocament més específic en mantenir els serveis en línia, gestionant incidents, optimitzant el rendiment i assegurant-se que es compleixen els SLA. Tot i que ambdós rols treballen amb eines similars, com CI/CD i contenidors, els SREs tenen més responsabilitats en la resolució d’incidents crítics i en la millora de la resiliència del sistema.\nCom podeu veure les eines tecnològiques que utilitzen els DevOps Engineers són molt similars a les dels SREs, però la seva aplicació i objectius són diferents. Per tant, apunteu-vos aquestes eines i tecnologies, ja que són essencials pel món laboral actual."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#salari-dun-devops-engineer",
    "href": "slides/01-foundations-of-systems-administration.html#salari-dun-devops-engineer",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Salari d’un DevOps Engineer",
    "text": "Salari d’un DevOps Engineer\n\n\n\n\n\nEls DevOps Engineers, igual que els SREs, gaudeixen d’un salari més alt i d’un major potencial de creixement professional en comparació amb els administradors de sistemes tradicionals. Si t’apassiona l’administració de sistemes enfocada a l’automatització del desplegament de software, el disseny i la gestió de pipelines de CI/CD, l’ús de contenidors i la implementació d’infraestructura com a codi, el rol de DevOps Engineer pot oferir-te una carrera més atractiva i plena d’oportunitats. En l’actualitat, moltes empreses busquen professionals amb habilitats en DevOps."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#transfomració-del-administrador-de-sistemes-a-sre",
    "href": "slides/01-foundations-of-systems-administration.html#transfomració-del-administrador-de-sistemes-a-sre",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Transfomració del Administrador de Sistemes a SRE",
    "text": "Transfomració del Administrador de Sistemes a SRE\n\n\n\n\nDamon Edwards, co-fundador de Rundeck, parla de la transformació d’un administrador de sistemes a un Site Reliability Engineer (SRE) i com aquesta evolució pot ajudar a millorar la fiabilitat dels sistemes i la productivitat dels equips de desenvolupament. Aquesta xerrada va ser presentada a la DevOpsCon 2019.\n\n\nEn aquest curs, veure una pinzellada de les tasques d’un SRE i d’un DevOps Engineer quan introduïm les eines de monitorització, automatització i CI/CD. Però, si voleu aprofundir en la temàtica, us recomano aquesta xerrada de la DevOpsCon, per Damon Edwarks, que parla del tema i explica com un administrador de sistemes es pot transformar en un SRE tenint en compte una responsabilitat compartida entre els SLOs i els errors de pressupost."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#arquitectura-client-servidor",
    "href": "slides/01-foundations-of-systems-administration.html#arquitectura-client-servidor",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Arquitectura Client-Servidor",
    "text": "Arquitectura Client-Servidor\nUna arquitectura client-servidor involucra uns sistemes que necessiten serveis i uns servidors que processen i responen a aquestes peticions.\n\n\nClient\nUn ordinador o dispositiu capaç de rebre informació o utilitzar un servei o proveïdor.\nServidor\nUn ordinador o dispositiu remot capaç de proveir accés a un servei o a informació.\n\n\n\n\nUn dels conceptes més importants en l’administració de sistemes és l’arquitectura client-servidor. Aquesta arquitectura implica la interacció entre dos tipus de sistemes: els clients, que sol·liciten serveis o informació, i els servidors, que processen i responen a aquestes peticions. Aquesta arquitectura és àmpliament utilitzada en entorns informàtics, com ara la web, les xarxes d’ordinadors i les aplicacions empresarials.\nPer exemple, quan un usuari accedeix a una pàgina web, el seu navegador actua com a client i sol·licita la pàgina al servidor web. El servidor de DNS consulta la URL i retorna l’adreça IP del servidor web. El navegador envia una petició HTTP o HTTPS al servidor web, que respon amb els fitxers necessaris per mostrar la pàgina al navegador. Aquest procés implica la comunicació entre el client i el servidor per proporcionar la informació sol·licitada a l’usuari."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#característiques-client-servidor",
    "href": "slides/01-foundations-of-systems-administration.html#característiques-client-servidor",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Característiques Client-Servidor",
    "text": "Característiques Client-Servidor\n\n\nAvantatges\n\nSistema centralitzat Totes les dades en un lloc.\nPolítiques de recuperació de dades.\nSeparació de la lògica.\n\n\n\n\nInconvenients\n\nAtacs de denegació de serveis.\nMan-in-the-middle.\nPhishing.\nSpoofing.\n\n\n\nAquesta arquitectura té avantatges i inconvenients. Entre els avantatges es troba la centralització de les dades, ja que tota la informació es troba en un únic lloc, el que facilita la gestió i la recuperació de les dades. A més, permet establir polítiques de recuperació de dades i separar la lògica de negoci de la interfície d’usuari, el que facilita la gestió i el manteniment del sistema. D’aquesta manera, els desenvolupadors poden centrar-se en la lògica de negoci sense preocupar-se de la interfície d’usuari. Per exemple, en una aplicació web, la lògica de negoci es pot gestionar al servidor, mentre que la interfície d’usuari es pot gestionar al client.\nEls principals inconvenients d’aquesta arquitectura són els possibles atacs de denegació de serveis, els atacs de l’home al mig, el phishing i l’usurpació d’identitat. Aquests atacs poden comprometre la seguretat del sistema i posar en perill la informació dels usuaris. Per tant, és important implementar mesures de seguretat per protegir el sistema i les dades dels usuaris. Un atac de denegació de servei enviarà moltes peticions al servidor per saturar-lo i fer-lo caure. Un atac de l’home al mig intercepta les comunicacions entre el client i el servidor per obtenir informació sensible. El phishing és un atac en què els atacants envien correus electrònics falsos per enganyar els usuaris i obtenir informació confidencial. L’usurpació d’identitat implica fer-se passar per una altra persona per obtenir accés a informació o recursos sensibles. Per tant, és molt imporant ser conscients d’aquests riscos i implementar mesures de seguretat per protegir el sistema i les dades dels usuaris.\nA la figura s’observa com múltiples clients es comuniquen amb un servidor central per obtenir informació o serveis. I com multiples servidors poden comunicar-se amb altres servidors per obtenir informació o serveis. També 1 client pot comunicar-se amb múltiples servidors. Per exemple, un client pot accedir a un servidor web per obtenir informació i a un servidor de correu per enviar correus electrònics. El servidor web pot comunicar-se amb el servidor de correu per enviar notificacions als usuaris."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#servidors-més-comuns",
    "href": "slides/01-foundations-of-systems-administration.html#servidors-més-comuns",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Servidors més comuns",
    "text": "Servidors més comuns\n\n\n\nServidor d’autenticació.\nServidor de fitxers.\nServidor de discos.\nServidor de correu.\nServidor de base de dades.\n\n\n\nServidor SSH.\nServidor Web.\nServidor d’aplicacions.\nServidor de backups.\nServidor de còmput.\n\n\n\nHi ha molts tipus de servidors en funció de l’objectiu que tenen. Alguns dels servidors més comuns són els servidors d’autenticació, que s’encarreguen de gestionar l’accés dels usuaris als sistemes; els servidors de fitxers, que emmagatzemen i gestionen els fitxers i documents de l’empresa; els servidors de discos, que proporcionen emmagatzematge addicional als servidors; els servidors de correu, que gestionen el correu electrònic de l’empresa; els servidors de base de dades, que emmagatzemen i gestionen les dades de l’empresa; els servidors SSH, que permeten l’accés remot als servidors; els servidors web, que allotgen les pàgines web de l’empresa; els servidors d’aplicacions, que executen les aplicacions de l’empresa; els servidors de backups, que realitzen còpies de seguretat de les dades de l’empresa; i els servidors de còmput, que realitzen càlculs i processos computacionals entre altres."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#exemple-darquitectura-escalable",
    "href": "slides/01-foundations-of-systems-administration.html#exemple-darquitectura-escalable",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Exemple d’arquitectura escalable",
    "text": "Exemple d’arquitectura escalable\n\n\n\n\nA la figura proporcionada es mostra una arquitectura típicament utilitzada per al desplegament d’una web escalable i fiable. En aquesta arquitectura, el punt d’entrada és un balancejador de càrrega, que distribueix les peticions entre els diversos servidors web. Els servidors web, que poden ser rèpliques, allotgen les pàgines web i gestionen les peticions dels usuaris. Aquestes pàgines web necessiten accedir a un servidor de base de dades per emmagatzemar i gestionar les dades associades. Cada base de dades està protegida per un servidor de backups, que realitza còpies de seguretat per garantir la recuperació en cas de fallades. A més, per millorar la velocitat de càrrega de les pàgines web, es fa servir un dispositiu CDN (Content Delivery Network) que redirigeix les peticions als servidors més propers a l’usuari.\nAquesta arquitectura és àmpliament utilitzada per allotjar llocs webs, ja que ofereix una combinació d’escalabilitat i fiabilitat, assegurant un rendiment òptim i una alta disponibilitat per als usuaris finals."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#problemes-més-comuns-servidors-i",
    "href": "slides/01-foundations-of-systems-administration.html#problemes-més-comuns-servidors-i",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Problemes més comuns servidors (I)",
    "text": "Problemes més comuns servidors (I)\n\nQui i com accedeix a la informació?\n\nDeterminar qui (usuari,procés,servei) pot accedir a quins fitxers i directoris i com ho pot fer (lectura, escriptura, execució).\nPermisos, ACLs, polítiques de seguretat.\n\nCom protegeixo la informació?\n\nDeterminar com protegir la informació sensible i confidencial.\nEncriptació, contrasenyes, autenticació, autorització, auditoria, backups.\n\nCom asseguro el sistema?\n\nProtegir el sistema contra atacs i amenaces.\nFirewall, IDS/IPS, antivirus, actualitzacions, patches, hardening.\n\n\n\nUn dels problemes més comuns en els servidors és determinar qui i com accedeix a la informació. Això implica definir qui (usuari, procés, servei) pot accedir a quins fitxers i directoris i com ho pot fer (lectura, escriptura, execució). Per fer-ho, es poden utilitzar permisos, llistes de control d’accés (ACLs) i polítiques de seguretat per garantir que només els usuaris autoritzats puguin accedir a la informació.\nUn altre problema comú és com protegir la informació sensible i confidencial. Això implica determinar com protegir la informació per evitar l’accés no autoritzat. Per fer-ho, es poden utilitzar tècniques com l’encriptació, les contrasenyes, l’autenticació, l’autorització, l’auditoria i els backups per garantir la seguretat i la privacitat de la informació.\nUn altre problema és com assegurar el sistema contra atacs i amenaces. Això implica protegir el sistema contra atacs externs i interns que puguin comprometre la seguretat i la integritat del sistema. Per fer-ho, es poden utilitzar eines com el firewall, els sistemes de detecció i prevenció d’intrusions (IDS/IPS), l’antivirus, les actualitzacions, els patches i el hardening per garantir la seguretat del sistema."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#problemes-més-comuns-servidors-ii",
    "href": "slides/01-foundations-of-systems-administration.html#problemes-més-comuns-servidors-ii",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Problemes més comuns servidors (II)",
    "text": "Problemes més comuns servidors (II)\n\nCom puc saber si el client és qui diu ser?\n\nAutenticar els usuaris i els dispositius.\nContrasenyes, certificats digitals, autenticació multifactorial.\n\nQuins avantatges/inconvenients té un disseny respecte a un altre?\n\nDeterminar quin disseny és més adequat per a les necessitats de l’empresa.\nEscalabilitat, rendiment, seguretat, disponibilitat, fiabilitat.\n\nCom asseguro el bon funcionament?\n\nGarantir que el sistema funcioni correctament i sense problemes.\nMonitorització, alertes, backups, redundància, tolerància a fallades.\n\n\n\nUn altre problema és com autenticar els usuaris i els dispositius per garantir que siguin qui diuen ser. Això implica autenticar els usuaris i els dispositius per garantir que només els usuaris autoritzats puguin accedir a la informació. Per fer-ho, es poden utilitzar tècniques com les contrasenyes, els certificats digitals i l’autenticació multifactorial per garantir la seguretat i la privacitat de la informació.\nUn altre problema comú és determinar quins avantatges i inconvenients té un disseny respecte a un altre. Això implica determinar quin disseny és més adequat per a les necessitats de l’empresa en termes d’escalabilitat, rendiment, seguretat, disponibilitat i fiabilitat. Per fer-ho, es poden avaluar els avantatges i inconvenients de cada disseny per garantir que s’adeqüi a les necessitats de l’empresa.\nUn altre problema és com assegurar el bon funcionament del sistema. Això implica garantir que el sistema funcioni correctament i sense problemes. Per fer-ho, es poden utilitzar tècniques com la monitorització, les alertes, els backups, la redundància i la tolerància a fallades per garantir que el sistema funcioni correctament i sense problemes."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#problemes-més-comuns-servidors-iii",
    "href": "slides/01-foundations-of-systems-administration.html#problemes-més-comuns-servidors-iii",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Problemes més comuns servidors (III)",
    "text": "Problemes més comuns servidors (III)\n\nCom dissenyo polítiques i plans d’emergència si tot falla?\n\nPreparar-se per a situacions d’emergència i desastres.\nPlans de contingència, plans de recuperació, plans de resposta a incidents.\n\nCom analitzo post-mortem les causes d’un atac?\n\nIdentificar les causes d’un atac i prendre mesures correctives.\nAnàlisi forense, auditoria, millora contínua.\n\n\n\nUn altre problema és com dissenyar polítiques i plans d’emergència si tot falla. Això implica preparar-se per a situacions d’emergència i desastres per garantir la continuïtat del negoci. Per fer-ho, es poden utilitzar plans de contingència, plans de recuperació i plans de resposta a incidents per garantir que l’empresa pugui respondre de manera eficaç a situacions d’emergència i desastres.\nFinalment, un altre problema és com analitzar post-mortem les causes d’un atac per identificar les causes i prendre mesures correctives. Això implica realitzar una anàlisi forense, una auditoria i una millora contínua per identificar les causes d’un atac i prendre mesures correctives per evitar que es repeteixin en el futur."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#què-és-un-centre-de-dades",
    "href": "slides/01-foundations-of-systems-administration.html#què-és-un-centre-de-dades",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Què és un centre de dades?",
    "text": "Què és un centre de dades?\nÉs una instal·lació que allotja un conjunt de servidors i equipament de xarxa (recursos heterogenis) per proporcionar recursos informàtics a diverses aplicacions i serveis (càrregues de treball diverses).\n\n\n\n\nEsquema d’un centre dades\n\n\n\n\nUn centre de dades o data center és un espai físic on s’allotgen els servidors, els dispositius de xarxa i altres equips informàtics necessaris per emmagatzemar, processar i distribuir la informació. Aquests centres de dades poden ser propis de l’empresa o externs, i poden ser gestionats per l’empresa o per un proveïdor de serveis. Els centres de dades són essencials per a les empreses que necessiten emmagatzemar i processar grans quantitats de dades, ja que proporcionen l’espai, la infraestructura i els recursos necessaris per garantir el funcionament dels sistemes informàtics.\nUn exemple notable de reutilització d’estructures per a centres de dades és l’ús d’edificis històrics com esglésies i mines abandonades. Aquests espais, amb les seves condicions úniques i sovint amb una infraestructura sòlida, són adaptats per allotjar servidors i equips. Per exemple, l’antiga església de Saint-Ouen a França ha estat convertida en un centre de dades, aprofitant la seva estructura i espai per complir amb els requisits tecnològics moderns. D’altra banda, la mina de carboni de Pionen a Suècia ha estat transformada en un centre de dades subterrani, oferint una protecció física addicional contra desastres naturals i atacs.\nGoogle disposa de servidors al fons del mar, aprofitant l’energia de les ones per refredar els servidors i reduir el consum energètic. Aquesta innovadora solució aprofita els recursos naturals per millorar l’eficiència energètica dels centres de dades i reduir l’impacte ambiental. Aquestes iniciatives mostren la diversitat de solucions i enfoques per a la gestió de centres de dades, adaptant-se a les necessitats i condicions específiques de cada empresa."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#què-és-un-rack",
    "href": "slides/01-foundations-of-systems-administration.html#què-és-un-rack",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Què és un rack?",
    "text": "Què és un rack?\nUn rack és una estructura metàl·lica que allotja servidors, switches, routers i altres equips informàtics en un centre de dades.\n\n\n\n\nRacks del CPD de la UdL\n\n\n\n\nUn rack és una estructura metàl·lica que allotja servidors, switches, routers i altres equips informàtics en un centre de dades. Aquests racks permeten organitzar i protegir els equips informàtics, així com facilitar la gestió dels cables i la refrigeració dels equips. Cada rack pot contenir diversos servidors, switches i altres equips, i es pot apilar verticalment per aprofitar l’espai disponible al centre de dades. A més, els racks disposen de panells laterals i portes per protegir els equips i garantir la seguretat dels servidors i altres equips informàtics.\nPer exemple, a la imatge us mostro els racks d’un passadís del centre de dades de la Universitat de Lleida, on es poden aquests armaris, penseu que cada rack pot contenir diversos servidors, switches i altres equips informàtics, i únciament es veu un dels múltiples passadissos del centre de dades. En aquest centre de dades és on tenim el Campus Virtual, les eines i dades dels estudiants i professors, així com els servidors de recerca dels grups de recerca de la UdL, entre d’altres."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#exemple-de-racks",
    "href": "slides/01-foundations-of-systems-administration.html#exemple-de-racks",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Exemple de racks",
    "text": "Exemple de racks\n\n\n\n\n\n\nRack 1 - GCD - Davant\n\n\n\n\n\n\n\n\n\n\nRack 1 - GCD - Darrera\n\n\n\n\n\nAra us mostro un rack, en concret els servidors són del grup de recerca en computació distribuïda. A la part de dalt es pot veure un switch, i la resta só servidors. A la part de davant es poden veure els servidors i a la part de darrera els cables de xarxa i alimentació. En aquest cas, hi ha diferents colors de cables per identificar la xarxa a la qual pertanyen i la seva funció."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#exemple-de-servidor",
    "href": "slides/01-foundations-of-systems-administration.html#exemple-de-servidor",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Exemple de servidor",
    "text": "Exemple de servidor\n\n\n\n\n\n\nExterior d’un servidor\n\n\n\n\n\n\n\n\n\n\nInterior d’un servidor\n\n\n\n\n\nEn aquestes imatges podem fer zoom i veure els components exteriors i interiors d’un servidor. A la imatge 8 es pot veure com cada disc té un indicador de color per identificar el disc en cas de fallada. A la imatge 9 es pot veure la placa base, els discos durs, la font d’alimentació, la memòria RAM i el processador."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#què-és-un-switch",
    "href": "slides/01-foundations-of-systems-administration.html#què-és-un-switch",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Què és un switch?",
    "text": "Què és un switch?\nUn switch és un dispositiu de xarxa que connecta diversos equips informàtics per permetre la comunicació entre ells.\n\n\n\n\nSwitch\n\n\n\n\nUn switch és un dispositiu de xarxa que connecta diversos equips per facilitar la comunicació entre ells. Cada switch utilitza una taula de comutació per dirigir les dades cap al destinatari correcte. Aquesta taula permet al switch conèixer quins equips estan connectats a quins ports i escollir la millor ruta per enviar les dades. Els ports del switch es poden configurar per assignar-los a VLANs (Xarxes Locals Virtuals), la qual cosa permet segmentar la xarxa en diverses sub-xarxes, millorant així la seguretat i el rendiment global de la xarxa.\nNo confondre un switch amb un router. Un switch connecta diversos equips dins de la mateixa xarxa local, mentre que un router connecta diverses xarxes locals o xarxes WAN (Xarxes d’Àrea Ampliada). Els routers utilitzen taula de rutes per determinar la millor ruta per enviar les dades entre xarxes, mentre que els switches utilitzen taula de comutació per enviar les dades entre equips dins de la mateixa xarxa local."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#característiques-dun-sistema",
    "href": "slides/01-foundations-of-systems-administration.html#característiques-dun-sistema",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Característiques d’un sistema",
    "text": "Característiques d’un sistema\n\nSimplicitat\nEscalabilitat\nSeguretat\nFiabilitat\nDisponibilitat\nRendiment\nFacilitat d’ús\n\n\nEn el disseny de sistemes informàtics, és important tenir en compte diverses característiques per garantir que el sistema sigui eficient, segur i fiable. Algunes de les característiques més importants d’un sistema són la simplicitat, l’escalabilitat, la seguretat, la fiabilitat, la disponibilitat, el rendiment i la facilitat d’ús. Ara bé, sovint intentem dotar sistemes amb característiques que no es poden afegir després de la seva construcció. Per exemple, intentar aplicar “seguretat” després que les interfícies del sistema hagin estat definides produeix restriccions i limitacions; intentar fer un sistema amb limitacions intrínseques funcionar en circumstàncies per les quals no va ser dissenyat produeix “hacks” i “workarounds” i el resultat final sovint essembla més una casa de cartes fràgil que una estructura sòlida i fiable.\nPer tant, quan discutim sobre el disseny de sistemes informàtics, és important tenir en compte aquestes característiques i assegurar-nos que el sistema compleixi els objectius de l’empresa i sigui capaç de respondre a les necessitats dels usuaris"
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#què-és-lescalabilitat",
    "href": "slides/01-foundations-of-systems-administration.html#què-és-lescalabilitat",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Què és l’escalabilitat?",
    "text": "Què és l’escalabilitat?\n\n\nL’escalabilitat és la capacitat d’un sistema per gestionar un augment de la càrrega de treball sense afectar el rendiment.\n\nVertical: augmentar la capacitat d’un servidor afegint més recursos (CPU, memòria, disc).\nHoritzontal: augmentar la capacitat d’un sistema afegint més servidors.\n\n\n\n\n\nEscalabilitat\n\n\n\n\n\n\n\n\n\n\n\n\nExemple\n\n\nEl serveis al núvol permeten pagar només pel que s’utilitza, permetent augmentar o disminuir la capacitat segons les necessitats. Et permet estirar els recursos tecnològics com un globus d’aire calent, augmentant la capacitat quan és necessari i reduint-la quan ja no és necessari.\n\n\n\n\n\nEscalabilitat es refereix a la capacitat d’un sistema per gestionar un augment en la càrrega de treball sense que el seu rendiment es vegi afectat. És un concepte clau en el disseny de sistemes informàtics, especialment en entorns amb variacions en la demanda. Aquesta capacitat s’aconsegueix mitjançant dues estratègies principals:\n\nEscalabilitat Vertical: Consisteix en millorar la capacitat d’un servidor afegint més recursos com CPU, memòria o disc. Això permet que un servidor maneje una càrrega de treball més gran sense necessitat d’addicional hardware.\nEscalabilitat Horitzontal: Consisteix en augmentar la capacitat del sistema afegint més servidors. Això distribueix la càrrega de treball entre diversos servidors, millorant la capacitat global del sistema.\n\nEn l’entorn de cloud computing, aquest concepte es relaciona sovint amb elasticitat, que és la capacitat d’un sistema per adaptar-se de manera dinàmica a les fluctuacions de la càrrega de treball. Per exemple, una botiga en línia podria experimentar un augment significatiu de trànsit durant el Black Friday. Un sistema escalable i elàstic podria gestionar aquest augment de demanda sense perdre rendiment, i després reduir la capacitat quan la demanda torna a nivells normals.\nL’objectiu és garantir que el sistema pugui mantenir un rendiment òptim i evitar problemes com temps d’espera llargs, errors o caigudes, que podrien afectar negativament l’experiència de l’usuari i els resultats comercials."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#què-és-la-fiabilitat",
    "href": "slides/01-foundations-of-systems-administration.html#què-és-la-fiabilitat",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Què és la fiabilitat?",
    "text": "Què és la fiabilitat?\nLa fiabilitat d’un sistema es refereix a la seva capacitat per operar sense interrupcions durant un període determinat. La fiabilitat es mesura habitualment mitjançant el MTBF (Mean Time Between Failures), que indica el temps mitjà que un sistema pot funcionar abans de fallar. Per exemple, si un sistema té un MTBF de 1000 hores, això vol dir que, de mitjana, es pot esperar que el sistema falli cada 1000 hores d’ús.\n\n\\[ MTBF = \\frac{Temps\\ total\\ de\\ funcionament}{Nombre\\ de\\ fallades} \\]\n\n\nPer millorar la fiabilitat i minimitzar les interrupcions, es poden implementar tècniques com la redundància. Un exemple comú és l’ús de servidors en configuració de calent i fred:\n\nServidor en calent: És el servidor principal que està en funcionament i gestionant les operacions actuals.\nServidor en fred: És un servidor de reserva que es manté en espera i es posa en marxa només quan el servidor en calent falla.\n\n\n\nLa fiabilitat és la capacitat d’un sistema per mantenir-se operatiu durant un període de temps determinat sense fallar. Es mesura en MTBF (Mean Time Between Failures). Per exemple, un sistema amb un MTBF de 1000 hores es pot esperar que falli cada 1000 hores d’ús.\nUna forma d’evitar fallades és la redundància, imagineu que tenim un servidor en calent (actual) i un servidor en fred (reserva) que es posa en marxa en cas de fallada del servidor actual. En aquest cas, el sistema és més fiable perquè si falla el servidor actual, el servidor de reserva pot prendre el relleu sense afectar el servei. La contrapartida és que aquesta redundància implica un cost addicional."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#què-és-la-disponibilitat",
    "href": "slides/01-foundations-of-systems-administration.html#què-és-la-disponibilitat",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Què és la disponibilitat?",
    "text": "Què és la disponibilitat?\nLa disponibilitat d’un sistema es refereix a la seva capacitat per estar operatiu i accessible per als usuaris durant un període de temps determinat.\n\nLa disponibilitat es mesura habitualment mitjançant el MTTR (Mean Time To Repair), que indica el temps mitjà que es triga a reparar un sistema després d’una fallada. Per exemple, si un sistema té un MTTR de 2 hores, això vol dir que, de mitjana, es triga 2 hores a reparar el sistema després d’una fallada.\n\n\n\\[ Disponibilitat = \\frac{Temps\\ de\\ funcionament}{Temps\\ de\\ funcionament + Temps\\ de\\ reparar} \\]\n\n\n\n\n\n\n\n\nExemple\n\n\nAmazon Web Services (AWS) ofereix un SLA (Service Level Agreement) del 99,99%, el que significa que el servei estarà disponible el 99,99% del temps. Si el servei no compleix aquest SLA, AWS ha de compensar els clients amb crèdits de servei.\n\n\n\n\n\nLa disponibilitat d’un sistema es refereix a la seva capacitat per estar operatiu i accessible per als usuaris durant un període de temps determinat. Es mesura en MTTR (Mean Time To Repair), que indica el temps mitjà que es triga a reparar un sistema després d’una fallada. Per exemple, si un sistema té un MTTR de 2 hores, això vol dir que, de mitjana, es triga 2 hores a reparar el sistema després d’una fallada. No confondre amb fiabilitat, que es refereix a la capacitat d’un sistema per operar sense interrupcions durant un període determinat.\nPer exemple, un sistema pot tenir una alta fiabilitat, però una baixa disponibilitat si el temps de reparació després d’una fallada és llarg. D’altra banda, un sistema pot tenir una baixa fiabilitat, però una alta disponibilitat si es pot reparar ràpidament després d’una fallada. La disponibilitat es mesura en percentatge i es pot garantir mitjançant acords de nivell de servei (SLA) que estipulen el temps de disponibilitat del sistema i les compensacions en cas de fallada.\nUn exemple comú d’alta disponibilitat és Amazon Web Services (AWS), que ofereix un SLA del 99,99%, el que significa que el servei estarà disponible el 99,99% del temps."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#kiss-keep-it-simple-stupid",
    "href": "slides/01-foundations-of-systems-administration.html#kiss-keep-it-simple-stupid",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "KISS: Keep It Simple, Stupid",
    "text": "KISS: Keep It Simple, Stupid\nUn sistema simple és més fàcil de mantenir, gestionar i entendre. Per dissenyar un sistema simple, es poden seguir les següents pautes:\n\nDivideix i venceràs: Divideix el sistema en components més petits i senzills\nMinimitza la complexitat: Evita la complexitat innecessària i mantén el sistema senzill\nUtilitza estàndards: Utilitza estàndards i pràctiques comunes per simplificar el disseny\nDocumenta el sistema: Documenta el sistema per facilitar la comprensió i el manteniment\nAutomatitza les tasques repetitives: Utilitza la automatització per simplificar les tasques repetitives i reduir els errors humans\n\n\n\n\n\n\n\n\nExemple\n\n\nUn sistema LEGO és un exemple de simplicitat, ja que es pot construir gairebé qualsevol cosa convinant peces senzilles. Aquesta simplicitat permet als usuaris crear i modificar les seves pròpies creacions sense necessitat de coneixements tècnics avançats.\n\n\n\n\n\nKISS és una directriu de disseny que destaca la importància de la simplicitat. Aplicant aquest principi, els sistemes resulten ser més robustos i fàcils de gestionar, cosa que millora la seva eficàcia i la satisfacció de l’usuari.\nAlgunes pautes per aplicar el principi KISS en el disseny de sistemes són:\n\nDivideix i venceràs: Divideix el sistema en components més petits i senzills, per exemple, en lloc de tenir un gran monòlit, divideix el sistema en microserveis.\nMinimitza la complexitat: Evita la complexitat innecessària i mantén el sistema senzill, per exemple, evita l’ús de tecnologies i funcionalitats que no són necessàries.\nUtilitza estàndards: Utilitza estàndards i pràctiques comunes per simplificar el disseny, per exemple, segueix les pràctiques de codificació i disseny recomanades per la comunitat.\nDocumenta el sistema: Documenta el sistema per facilitar la comprensió i el manteniment, per exemple, crea documentació clara i concisa per als desenvolupadors i els usuaris.\nAutomatitza les tasques repetitives: Utilitza la automatització per simplificar les tasques repetitives i reduir els errors humans, per exemple, automatitza les tasques de desplegament i proves per millorar l’eficiència i la fiabilitat del sistema.\n\nUn exemple de simplicitat és un sistema LEGO, que permet als usuaris construir gairebé qualsevol cosa combinant peces senzilles. Aquesta simplicitat permet als usuaris crear i modificar les seves pròpies creacions sense necessitat de coneixements tècnics avançats."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#eines-i-tecnologies-més-comuns",
    "href": "slides/01-foundations-of-systems-administration.html#eines-i-tecnologies-més-comuns",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Eines i tecnologies més comuns?",
    "text": "Eines i tecnologies més comuns?\n\nVirtualització: Màquines Virtuals, Contenidors\nCloud Computing: Infraestructura com a Servei (IaaS), Plataforma com a Servei (PaaS), Software com a Servei (SaaS)\nAutomatització: Ansible, Puppet, Chef\nInfraestructura com a Codi: Terraform, CloudFormation\nMonitorització: Nagios, Zabbix, Prometheus\nCI/CD: Jenkins, GitLab CI\nSeguretat: PfSense, Suricata, Snort\nBases de Dades: MySQL, PostgreSQL, MongoDB\nServeis Web: Apache, Nginx, Tomcat\nOrquestació de Contenidors: Kubernetes, Docker Swarm\n\n\nEn el món de l’administració de sistemes, hi ha una gran varietat d’eines i tecnologies que es poden utilitzar per gestionar i mantenir els sistemes informàtics. Algunes de les eines i tecnologies més comuns són:\n\nVirtualització: La virtualització permet crear màquines virtuals i contenidors per aïllar i gestionar els recursos del sistema. Això permet millorar l’eficiència i la flexibilitat dels sistemes, ja que es poden crear múltiples entorns virtuals en un sol servidor físic.\nCloud Computing: El cloud computing ofereix serveis informàtics a través d’Internet, permetent als usuaris accedir a recursos informàtics a la demanda. Això inclou Infraestructura com a Servei (IaaS), Plataforma com a Servei (PaaS) i Software com a Servei (SaaS).\nAutomatització: L’automatització permet automatitzar tasques repetitives i reduir els errors humans. Algunes eines d’automatització com Ansible, Puppet i Chef permeten gestionar la configuració dels servidors de manera eficient.\nInfraestructura com a Codi: L’infraestructura com a codi permet gestionar la infraestructura de manera programàtica, utilitzant codi per definir i gestionar els recursos del sistema. Eines com Terraform i CloudFormation permeten gestionar la infraestructura com a codi.\nMonitorització: La monitorització permet supervisar l’estat dels sistemes i identificar problemes abans que afectin el rendiment. Algunes eines de monitorització com Nagios, Zabbix i Prometheus permeten supervisar els sistemes en temps real.\nCI/CD: La integració contínua (CI) i el desplegament contínu (CD) permeten automatitzar el procés de desenvolupament i desplegament de codi. Eines com Jenkins i GitLab CI permeten implementar pràctiques de CI/CD.\nSeguretat: La seguretat dels sistemes és una preocupació important en l’administració de sistemes. Algunes eines de seguretat com PfSense, Suricata i Snort permeten protegir els sistemes contra atacs i amenaces.\nBases de Dades: Les bases de dades són essencials per emmagatzemar i gestionar la informació dels sistemes. Algunes bases de dades com MySQL, PostgreSQL i MongoDB són àmpliament utilitzades en l’administració de sistemes.\nServeis Web: Els serveis web són essencials per proporcionar serveis i aplicacions a través d’Internet. Algunes eines com Apache, Nginx i Tomcat permeten gestionar i desplegar serveis web.\nOrquestació de Contenidors: L’orquestació de contenidors permet gestionar i coordinar els contenidors en un entorn de contenidors. Eines com Kubernetes i Docker Swarm permeten gestionar i escalar els contenidors de manera eficient."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#virtualització-màquines-virtuals",
    "href": "slides/01-foundations-of-systems-administration.html#virtualització-màquines-virtuals",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Virtualització (Màquines Virtuals)",
    "text": "Virtualització (Màquines Virtuals)\n\n\n\n\nEsquema de tipus de virtualització de màquines virtuals\n\n\n\n\nLa virtualització és una tecnologia clau que permet aprofitar millor els recursos d’un servidor físic, creant múltiples màquines virtuals (VMs) que funcionen com a entitats independents, cadascuna amb el seu propi sistema operatiu i aplicacions. Aquest enfocament permet millorar l’eficiència, ja que múltiples màquines virtuals poden compartir un únic servidor físic, maximitzant l’ús dels recursos disponibles i oferint més flexibilitat a l’hora de gestionar sistemes. Per exemple, si voleu executar tant Windows com Linux al vostre ordinador per fer proves, podeu crear màquines virtuals per a cada sistema operatiu utilitzant programes com VirtualBox o VMware. Això us permet treballar amb diferents entorns sense necessitat de tenir diversos ordinadors físics. A nivell de servidors, aquesta mateixa idea es porta a gran escala: un sol servidor físic pot tenir múltiples màquines virtuals aïllades, cada una amb la seva funció específica. Això permet consolidar serveis i maximitzar l’ús de recursos. Per exemple, en una empresa, un sol servidor físic podria allotjar VMs per a bases de dades, aplicacions web, i sistemes de correu, cadascun funcionant de manera independent.\n\nVirtualització Nativa: També coneguda com a “bare-metal”, en aquest tipus, l’hipervisor s’executa directament sobre el maquinari físic sense cap sistema operatiu intermedi. Exemples d’aquesta tecnologia inclouen VMware ESXi o Microsoft Hyper-V. Això ofereix un rendiment molt elevat, ja que no hi ha cap capa addicional entre el maquinari i l’hipervisor, ideal per a entorns de producció.\nVirtualització Allotjada: Aquí, l’hipervisor s’executa sobre un sistema operatiu ja existent. Per exemple, en KVM (Kernel-based Virtual Machine), s’utilitza Linux com a sistema operatiu base, i sobre aquest es creen les màquines virtuals. Aquest enfocament és més fàcil d’implementar però pot sacrificar una mica de rendiment en comparació amb la virtualització nativa.\nParavirtualització: En aquest model, el sistema operatiu convidat sap que està sent virtualitzat i coopera amb l’hipervisor per millorar el rendiment. Un exemple destacat és Xen, que és molt utilitzat en entorns cloud per la seva eficiència. Aquest tipus de virtualització pot oferir un rendiment proper al de la virtualització nativa, però amb més flexibilitat.\nVirtualització Assistida per Hardware: Aquest model aprofita les capacitats del processador per accelerar el procés de virtualització. Processadors moderns com els d’Intel (VT-x) o AMD (AMD-V) ofereixen suport per a aquest tipus de virtualització, que és utilitzat per tecnologies com VMware o Hyper-V."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#ansible",
    "href": "slides/01-foundations-of-systems-administration.html#ansible",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Ansible",
    "text": "Ansible\nAnsible és una eina d’automatització de la configuració i gestió de sistemes. Utilitza un llenguatge senzill basat en YAML per definir les tasques i la configuració dels sistemes, i utilitza SSH per connectar-se als servidors i executar les tasques.\n\n\n- hosts: webservers\n  tasks:\n    - name: Install Apache\n      apt:\n        name: apache2\n        state: present\n    - name: Start Apache\n      service:\n        name: apache2\n        state: started\n\nhosts:\n  webservers:\n    - web1.example.com\n    - web2.example.com\n    - web3.example.com\n\n\nAnsible és una eina d’automatització que ens permet gestionar la configuració dels servidors de manera eficient i fiable. Per exemple, si necessitem instal·lar un servidor web a 10.000 servidors, en lloc de fer-ho manualment en cada servidor, podem utilitzar Ansible per automatitzar aquesta tasca. Amb aquest script indiquem les tasques ha realitzar instal·lar apache i aixecar el servei. I en el fitxer de hosts indiquem els servidors on volem realitzar aquestes tasques."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#què-és-el-cloud-computing",
    "href": "slides/01-foundations-of-systems-administration.html#què-és-el-cloud-computing",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Què és el Cloud Computing?",
    "text": "Què és el Cloud Computing?\nLliurament de recursos sota demanda, incloent servidors, emmagatzematge, bases de dades, programari, analítica, i més, a través d’internet amb un model de pagament per ús.\n\n\n\n\nPizza as a service\n\n\n\n\nEl cloud computing es refereix al lliurament sota demanda de serveis informàtics, incloent servidors, emmagatzematge, bases de dades, programari, analítica, i molt més, a través d’internet amb un model de pagament per ús.\nAquests recursos s’executen en servidors ubicats en grans centres de dades arreu del món. Els usuaris poden accedir-hi de manera remota des de qualsevol lloc amb connexió a internet. En lloc de posseir i mantenir la seva pròpia infraestructura, els usuaris i empreses poden llogar serveis des d’aplicacions fins a emmagatzematge d’un proveïdor de serveis al núvol. Els recursos es poden combinar com peces de LEGO per crear solucions a mida de les necessitats.\nAquest model ha permès l’evolució de l’administració de sistemes a un nivell superior, permetent als usuaris centrar-se en el desenvolupament d’aplicacions i serveis sense haver de preocupar-se de la infraestructura subjacents."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#amazon-web-services",
    "href": "slides/01-foundations-of-systems-administration.html#amazon-web-services",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Amazon Web Services",
    "text": "Amazon Web Services\n\n\n\n\nAmazon Web Services (AWS) és un proveïdor de serveis de computació en núvol que ofereix una àmplia gamma de serveis, incloent servidors virtuals, emmagatzematge, bases de dades, analítica, seguretat, i molt més. AWS permet als usuaris i empreses llogar recursos informàtics a través d’internet, oferint una plataforma flexible i escalable per a la implementació d’aplicacions en núvol. Altres proveïdors de serveis en núvol inclouen Microsoft Azure, Google Cloud Platform, IBM Cloud, i Oracle Cloud, però en aquest curs utilitzarem AWS per raons de popularitat i disponibilitat de recursos."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#cloudformation",
    "href": "slides/01-foundations-of-systems-administration.html#cloudformation",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "CloudFormation",
    "text": "CloudFormation\nCloudFormation és un servei d’AWS que permet als desenvolupadors definir i desplegar la infraestructura de manera programàtica mitjançant codi.\nResources:\n  MyInstance:\n    Type: AWS::EC2::Instance\n    Properties:\n      ImageId: ami-0c55b159cbfafe1f0\n      InstanceType: t2.micro\n      KeyName: my-key-pair\n      SecurityGroups:\n        - my-security-group\n\nAWS CloudFormation és un servei que permet als desenvolupadors definir i desplegar la infraestructura de manera programàtica mitjançant codi. Aquest codi es defineix en plantilles de CloudFormation, que descriuen els recursos necessaris per a la infraestructura, com ara instàncies EC2, grups de seguretat, taules de rutes, …, En aquest exemple, es defineix una instància EC2 amb una imatge AMI, un tipus d’instància, una clau SSH, i un grup de seguretat. Un cop es defineix la plantilla, es pot desplegar la infraestructura amb un sol clic o una sola comanda, automatitzant així el procés de desplegament i garantint la consistència de la infraestructura."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#virtualització-contenidors",
    "href": "slides/01-foundations-of-systems-administration.html#virtualització-contenidors",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Virtualització (Contenidors)",
    "text": "Virtualització (Contenidors)\n\n\n\n\nEsquema de tipus de virtualització de contenidors (Docker)\n\n\n\n\nLa virtualització de contenidors és una tecnologia que permet als desenvolupadors empaquetar aplicacions i les seves dependències en un contenidor lleuger i portàtil que pot ser executat en qualsevol sistema que tingui un motor de contenidors. Aquest enfocament permet als desenvolupadors crear, distribuir i executar aplicacions de manera eficient i fiable, ja que els contenidors són autosuficients i aïllats de l’entorn d’execució. A més, els contenidors són lleugers i portàtils, el que facilita la seva distribució i execució en entorns diversos.\nPer exemple, Docker o containerd són motors de contenidors que permeten als desenvolupadors crear i executar contenidors lleugers i portàtils. Aquests contenidors poden contenir aplicacions, serveis o microserveis, i es poden executar en qualsevol sistema que tingui un motor de contenidors instal·lat. Això permet als desenvolupadors crear, distribuir i executar aplicacions de manera eficient i fiable, ja que els contenidors són autosuficients i aïllats de l’entorn d’execució.\nLa principal diferència entre la virtualització de màquines virtuals i la virtualització de contenidors és el nivell d’abstracció. Mentre que les màquines virtuals virtualitzen tota una màquina física, incloent el sistema operatiu, els contenidors virtualitzen només l’aplicació i les seves dependències, compartint el mateix nucli del sistema operatiu hoste. Això fa que els contenidors siguin més lleugers i portàtils que les màquines virtuals, i permet als desenvolupadors crear i executar aplicacions de manera més eficient i fiable."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#kubernetes",
    "href": "slides/01-foundations-of-systems-administration.html#kubernetes",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Kubernetes",
    "text": "Kubernetes\n\n\n\n\nKubernetes\n\n\n\n\nKubernetes és una plataforma de codi obert per a la gestió d’aplicacions en contenidors. Permet als desenvolupadors automatitzar el desplegament, l’escalat i la gestió d’aplicacions en contenidors, oferint una plataforma flexible i escalable per a la implementació d’aplicacions en entorns de producció. Es basa en una arquitectura de màster i nodes, on el màster és responsable de la gestió i control del clúster, mentre que els nodes són els servidors on s’executen les aplicacions en contenidors. Requereix de diferents xarxes (com xarxa de control, xarxa de pod, xarxa de servei) per a la comunicació entre els components del clúster, a més necessita serveis de descobriment de serveis (com etcd) per a la gestió de la configuració i l’estat del clúster, controladors de xarxa (com Flannel) per a la comunicació entre els nodes, i controladors de volums (com Rook) per a la gestió de l’emmagatzematge persistent, un planificador (com kube-scheduler) per a la programació de les tasques, i un controlador de replicació (com kube-controller-manager) per a la gestió de la replicació de les aplicacions i sobretot el kubelet, que és l’agent que s’executa en cada node i és responsable de la gestió dels contenidors en el node. Com veieu, Kubernetes és una plataforma complexa que requereix una configuració i gestió adequades per a garantir el seu funcionament correcte."
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#thats-all",
    "href": "slides/01-foundations-of-systems-administration.html#thats-all",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "That’s all",
    "text": "That’s all\n\n\n\n\n\n\n\n\n\nTake Home Message\n\n\nUn administrador de sistemes combina habilitats de bomber i investigador: ha de solucionar problemes de manera ràpida i efectiva, però també anticipar-se i prevenir-ne de futurs abans que esdevinguin crítics. Aquesta tasca és complexa i diversa, abastant des de la gestió de cables i servidors físics fins a l’administració de pods i sistemes automàtics sense servidor (serverless)."
  }
]