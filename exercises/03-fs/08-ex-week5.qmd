---
title: "Migraci√≥ de directoris a particions diferents"
lang: ca
---

## Objectius

- Crear particions i sistemes de fitxers (**ext4, xfs**).
- Migrar directoris reals a particions separades amb coher√®ncia i sense p√®rdua de dades.
- Configurar el muntatge autom√†tic amb UUID i opcions de seguretat (*nodev, nosuid, noexec*).
- Diagnosticar i recuperar problemes reals: saturaci√≥ d'espai i corrupci√≥ de sistema de fitxers.
- **Eines**: `fdisk`, `mkfs.*`, `tune2fs`, `mount`, `rsync`, `xfs_repair`, `hexedit`.

## Requeriments previs

- Tenir una m√†quina virtual (MV) amb Debian instal¬∑lat.
- Crear un disc dur virtual addicional de 10GB del tipus SATA o NVMe.
- Instal¬∑lar els paquets `xfsprogs`, `rsync`, `hexedit` i `build-essential`:
  
  ```bash
  apt update -y && apt install xfsprogs rsync hexedit build-essential -y
  ```
- Totes les comandes s'han d'executar amb permisos de superusuari (`root`). Per tant, `su -`.
- Compte amb el nom del disc dur addicional, en aquest cas `/dev/nvme0n2`, per√≤ pot variar en funci√≥ de la configuraci√≥ de la m√†quina virtual, utilitza la comanda `lsblk` per a identificar el disc dur addicional. Utilitza el nom correcte actualitzant-lo en les comandes que apareixen en aquest exercici.


## Particions i Sistemes de Fitxers

### Crear Particions i Sistemes de Fitxers

Assegurarem que el disc dur addicional est√† detectat pel sistema. En aquest cas, el disc dur √©s `/dev/nvme0n2`, per√≤ pot variar en funci√≥ de la configuraci√≥ de la m√†quina virtual, utilitza la comanda `lsblk` per a identificar el disc dur addicional.

Utilitzarem la comanda `fdisk` per a crear tres noves particions en el disc dur.

- La primera partici√≥ ser√† per a `/var` amb el sistema de fitxers `ext4`, etiqueta `var` mida 4GB.
- La segona partici√≥ ser√† per a `/tmp` amb el sistema de fitxers `xfs`,  sense etiqueta i mida 2GB.
- La tercera partici√≥ ser√† per a `/opt` amb el sistema de fitxers `ext4`, etiqueta `opt` mida 3GB.
- La quarta partici√≥ ser√† `/home` amb el sistema de fitxers `ext4`, etiqueta `home` i la resta d'espai disponible (1GB).

Crearem les noves particions en el disc dur. Podeu utilzar una pipeline per a automatitzar la creaci√≥ de les particions.

```bash
echo -e "n\np\n\n\n+4G\nn\np\n\n\n+2G\nn\np\n\n\n+3G\nn\np\n\n\n+1G\nw" | fdisk /dev/nvme0n2
```

El seg√ºent pas √©s crear els sistemes de fitxers en les particions que acabem de crear i assignar les etiquetes corresponents.

```bash
mkfs.ext4 /dev/nvme0n2p1
tune2fs -L "var" /dev/nvme0n2p1
mkfs.xfs /dev/nvme0n2p2
mkfs.ext4 /dev/nvme0n2p3
tune2fs -L "opt" /dev/nvme0n2p3
mkfs.xfs /dev/nvme0n2p4
tune2fs -L "home" /dev/nvme0n2p4
 ```

Monteu les particions en directoris temporals per a migrar les dades, per a aix√≤, creeu els directoris `/mnt/var`, `/mnt/tmp` , `/mnt/opt` i `/mnt/home`.

```bash
mkdir /mnt/var /mnt/tmp /mnt/opt /mnt/home
mount /dev/nvme0n2p1 /mnt/var
mount /dev/nvme0n2p3 /mnt/opt
mount /dev/nvme0n2p4 /mnt/home
```

::: {.callout-note title="/tmp"}
La partici√≥ `/tmp` √©s temporal i no cont√© dades importants, per tant, no la muntarem en aquest pas, ja que no necessitem migrar cap dada. Les seves dades es perdran en el reinici del sistema.
:::

### Migrar Directoris a les Noves Particions

Abans de migrar les dades, √©s important assegurar-se que no hi ha processos que estiguin utilitzant els directoris que volem migrar. Per a aix√≤, podem utilitzar la comanda `lsof` per a llistar els fitxers oberts en aquests directoris.

```bash
lsof +D /var
lsof +D /opt
lsof +D /home
```

::: {.callout-note title="Fitxers oberts"}
Si hi ha processos que estan utilitzant els directoris que volem migrar, √©s recomanable aturar aquests processos abans de continuar amb la migraci√≥. Aix√≤ √©s especialment important per al directori `/var`, ja que cont√© fitxers de registre i altres dades que poden ser utilitzades per diversos serveis del sistema.
:::

Hi ha moltes comandes per a migrar dades entre directoris, per√≤ en aquest cas utilitzarem la comanda `rsync` ja que ens permet mostrar el progr√©s de la c√≤pia i tamb√© ens permet reprendre la c√≤pia en cas que es talli la connexi√≥ o hi hagi un error. A m√©s, tamb√© ens permet excloure directoris o fitxers que no volem migrar i ens permet fer c√≤pies incrementals.

```bash
rsync -av /var/ /mnt/var
rsync -av /opt/ /mnt/opt
rsync -av /home/ /mnt/home
```

:::{.callout-note title="rsync"}
`rsync` √©s una eina molt potent per a la sincronitzaci√≥ de fitxers i directoris. En aquest cas, utilitzem les opcions `-a` (mode arxiu) i `-v` (verbose) per a conservar els permisos, propietaris, marques de temps i per a mostrar el progr√©s de la c√≤pia. La barra inclinada (`/`) al final dels directoris d'origen √©s important perqu√® indica a `rsync` que nom√©s volem copiar el contingut del directori i no el directori en si mateix. Si no posem la barra inclinada, `rsync` crear√† un subdirectori amb el mateix nom que el directori d'origen dins del directori de destinaci√≥. Per a m√©s informaci√≥ sobre `rsync`, podeu consultar la documentaci√≥ (`man rsync`).
:::

Un cop copiem les dades, √©s important verificar que les dades s'han copiat correctament. Per a aix√≤, podem utilitzar la comanda `diff` per a comparar els directoris d'origen i destinaci√≥.

```bash
diff -r /var /mnt/var
diff -r /opt /mnt/opt
diff -r /home /mnt/home
```

Si la comanda `diff` no mostra cap sortida, significa que els directoris s√≥n id√®ntics i que les dades s'han copiat correctament. Si hi ha difer√®ncies, la comanda `diff` mostrar√† les l√≠nies que s√≥n diferents entre els dos directoris.

Muntarem les noves particions en els directoris corresponents.

```bash
mount /dev/nvme0n2p1 /var
mount /dev/nvme0n2p3 /opt
mount /dev/nvme0n2p4 /home
```

Utiltiza la comanda `df` per a comprovar que les particions s'han muntat correctament o `lsblk` per a veure totes les particions i els seus punts de muntatge.

### Configurar el Muntatge Autom√†tic

Si ara reinicieu el sistema `reboot`, les particions no estaran muntades autom√†ticament. Per a que les particions es muntin autom√†ticament en l'arrencada del sistema, hem d'editar el fitxer `/etc/fstab` i afegir les noves particions amb els seus punts de muntatge corresponents.

```bash
echo "/dev/nvme0n2p1 /var ext4 defaults 0 0" >> /etc/fstab
echo "/dev/nvme0n2p2 /tmp xfs defaults 0 0" >> /etc/fstab
echo "/dev/nvme0n2p3 /opt ext4 defaults 0 0" >> /etc/fstab
echo "/dev/nvme0n2p4 /home xfs defaults 0 0" >> /etc/fstab
```

:::{.callout-note title="`/etc/fstab`"}
El fitxer `/etc/fstab` cont√© la informaci√≥ de les particions que es muntaran autom√†ticament en l'arrencada del sistema. Cada l√≠nia del fitxer cont√© la informaci√≥ d'una partici√≥. Els camps de cada l√≠nia s√≥n: dispositiu, punt de muntatge, sistema de fitxers, opcions, freq√º√®ncia de comprovaci√≥ i ordre de comprovaci√≥. Podeu consultar la documentaci√≥ del fitxer per a m√©s informaci√≥ (`man fstab`).
:::

Pots provar la configuraci√≥ del fitxer `/etc/fstab` sense reiniciar el sistema amb la comanda `mount -a`. Aquesta comanda muntar√† totes les particions que estan definides en el fitxer `/etc/fstab`. Tamb√© podem fer un `reboot` per a comprovar que les particions es muntin autom√†ticament en l'arrencada del sistema, sempre hi quan la comanda `mount -a` no hagi donat cap error.

En aquest punt podriam optimitzar la configuraci√≥ particions per a millorar el rendiment del sistema. 

1. Utiltizarem els UUIDs en lloc dels dispositius per a muntar les particions. Aix√≤ ens permetr√† identificar les particions de forma un√≠voca i evitar problemes en cas que els dispositius canvi√Øn d'identificador. Per fer-ho podem utilitzar la comanda `sed` per actualitzar el fitxer `/etc/fstab`.

    ```bash
    sed -i "s|/dev/nvme0n2p1|UUID=$(blkid -s UUID -o value /dev/nvme0n2p1)|" /etc/fstab
    sed -i "s|/dev/nvme0n2p2|UUID=$(blkid -s UUID -o value /dev/nvme0n2p2)|" /etc/fstab
    sed -i "s|/dev/nvme0n2p3|UUID=$(blkid -s UUID -o value /dev/nvme0n2p3)|" /etc/fstab
    sed -i "s|/dev/nvme0n2p4|UUID=$(blkid -s UUID -o value /dev/nvme0n2p4)|" /etc/fstab
    ```

    > üîç  **Pregunta**: *En quins casos poden canviar els dispositius o tenir duplicats?*
    >
    > Els dispositius poden canviar d'identificador en cas que es connectin m√©s dispositius al sistema o es canvii l'ordre de connexi√≥ dels dispositius. Aix√≤ pot provocar que les particions es muntin en llocs diferents dels esperats. Per a evitar aquest problema, √©s recomanable utilitzar els UUIDs en lloc dels dispositius per a muntar les particions.

2. Utilitzarem opcions m√©s espec√≠fiques per protegir la partici√≥ `/tmp` per a evitar que s‚Äôexecutin programes des de la partici√≥. Utilitzant les opcions **nodev**, **nosuid**, i **noexec**:
  
    - Edita el fitxer `/etc/fstab` i afegeix les opcions `nodev`, `nosuid`, i `noexec` a la partici√≥ `/tmp`.

:::{.callout-note title="Opcions de Muntatge"}
La opci√≥ `defaults` √©s una col¬∑lecci√≥ d'opcions que s'utilitzen per defecte en la majoria de sistemes de fitxers. Aquestes opcions inclouen `rw` (lectura i escriptura), `suid` (permet l'√∫s de l'atribut suid), √©s a dir, evita que es puguin exectuar programaes amb permisos de superusuari, `dev` (permet l'√∫s de dispositius), `exec` (permet l'execuci√≥ de fitxers binaris), `auto` (muntatge autom√†tic en l'arrencada del sistema), `nouser` (nom√©s l'usuari root pot muntar la partici√≥) i `async` (permet l'escriptura as√≠ncrona).
:::

    - Comprova les opcions despr√©s d'editar el fitxer `/etc/fstab`.

        ```bash
        mount | grep /tmp
        ```
    - Per aplicar les opcions de muntatge a la partici√≥ `/tmp`, farem un `reboot` del sistema.
  
    - Testem les opcions de muntatge de la partici√≥ `/tmp`:
  
        1. Prova d'executar un programa des de la partici√≥ `/tmp` com a usuari no privilegiat.

            ```bash
            echo "echo 'Hello, World'" > /tmp/hello.sh
            chmod +x /tmp/hello.sh
            /tmp/hello.sh
            bash /tmp/hello.sh
             ```

        2. Prova de fer el mateix com a usuari privilegiat.

            ```bash
            su -
            /tmp/hello.sh
            bash /tmp/hello.sh
            ```

            > üëÅÔ∏è **Observaci√≥**:
            >
            > Observeu que la opci√≥ `noexec` impedeix la execuci√≥ dels binaris per√≤ no ens protegeix contra l'execuci√≥ de scripts de bash.

        3. Prova d'accedir a un dispositiu creat a `/tmp`:

            - Inicialitza un dispositiu a `/tmp` utilitzant la comanda `mknod`.

                ```bash
                mknod /tmp/dispositiu c 1 3
                ```

                > ‚ö†Ô∏è **Compte**:
                >
                > La comanda `mknod` √∫nica i exclusivament la poden fer els usuaris amb permisos de superusuari. Per tant, feu servir la comanda `su` per a canviar a l'usuari `root` abans de fer servir la comanda `mknod`.

            - Per accedir al dispositiu, utilitza la comanda `cat`.

                ```bash
                cat /tmp/dispositiu
                ```

            > üëÅÔ∏è **Observaci√≥**:
            >
            > Fixeu-vos que quan intento accedir a un dispositiu al directori actual, no hi ha cap problema. Per√≤ quan intento accedir al dispositiu creat a `/tmp`, rebre un missatge d'error indicant que no es pot accedir al dispositiu. Aix√≤ √©s degut a la opci√≥ `nodev` que impedeix l'acc√©s a dispositius en la partici√≥.

        4. Per veure, les implicacions de la opci√≥ `nosuid`, podem realitzar el seg√ºent experiment:

            Per fer-ho, crearem un executable amb c que ens indicar√† l'identificador de l'usuari real i l'identificador de l'usuari efectiu. On l'usuari real √©s l'usuari que ha iniciat la sessi√≥ i l'usuari efectiu √©s l'usuari que executa el programa. Si un programa t√© el bit `suid` activat, l'usuari efectiu ser√† l'usuari propietari del programa i no l'usuari que l'ha executat.

            ```c
            #include <stdio.h>
            #include <sys/types.h>
            #include <unistd.h>

            int main() {
                printf("Effective user ID: %d\n", geteuid());
                printf("Real user ID: %d\n", getuid());
                return 0;
            }
            ```

            Compilem el programa amb la comanda `gcc`.

            ```bash
            gcc -o /tmp/suid /tmp/suid.c
            ```

            - Desactiva la opci√≥ `nosuid` i tamb√© la opci√≥ `noexec` per a la partici√≥ `/tmp`. Per fer-ho, utilitza l'usuari `root` per a editar el fitxer `/etc/fstab`.

            - Remunta la partici√≥ `/tmp`.

            - Prova d'executar el programa com a usuari no privilegiat.

                ```bash
                /tmp/suid
                ```

            - Activa la opci√≥ `nosuid` i torna a provar d'executar el programa.

                ```bash
                /tmp/suid
                ```


            > üëÅÔ∏è **Observaci√≥**:
            >
            > Fixeu-vos que quan la opci√≥ `nosuid` est√† activada, no es pot executar el programa amb permisos de superusuari. Aix√≤ √©s important per a evitar que els usuaris no privilegiats puguin executar programes amb permisos de superusuari. Aquesta opci√≥ pot permetre escalar privilegis i comprometre la seguretat del sistema.

> üîç  **Pregunta**: *Per qu√® √©s important tenir els directoris `/var`, `/tmp` i `/opt` en particions diferents?*
>
> La ra√≥ principal per a tenir els directoris `/var`, `/tmp` i `/opt` en particions diferents √©s per a millorar el rendiment i la seguretat del sistema. El directori `/var` cont√© dades variables com ara logs, bases de dades, correu electr√≤nic, etc. Si aquest directori es queda sense espai, el sistema podria fallar. El mateix raonament s'aplica al directori `/tmp` i `/opt`. Per aix√≤, √©s important tenir-los en particions separades per a evitar que el sistema falli. A m√©s, tenir els directoris `/var`, `/tmp` i `/opt` en particions separades tamb√© millora la seguretat del sistema ja que si una partici√≥ falla, les altres particions seguiran funcionant.

Anem a fer una simulaci√≥ de com respon el sistema en cas de no tenir els directoris `/var`, `/tmp` i `/opt` en particions separades. Per a aix√≤, simularem que el directori `/opt` es va omplint fins a ocupar tot l'espai disponible en la partici√≥ principal del sistema.

1. Desmuntem la partici√≥ `/opt` per a poder continuar amb l'exercici.

    ```bash
    umount /opt
    ```

2. Creeu un fitxer de 20GB al directori `/opt`:

    ```bash
    dd if=/dev/urandom of=/opt/fitxer bs=1M count=20480
    ```

3. Comprova l'estat del sistema.

    ```bash
    df -h
    ```

    ![Comprova l'estat del sistema](../../figs/exercises/fs-01/df-omplert.png)

4. Intenta instal¬∑lar un paquet amb `apt` i comprova que el sistema falla.

    ```bash
    apt install htop
    ```

    ![Intenta instal¬∑lar un paquet amb `apt` i comprova que el sistema falla](../../figs/exercises/fs-01/apt-fallit.png)

    Com podeu veure, el sistema fallar√† ja que no t√© espai suficient per a instal¬∑lar el paquet. Aix√≤ √©s un problema greu ja que el sistema no podr√† funcionar correctament fins que no alliberem espai en la partici√≥ principal.

5. Elimina el fitxer que has creat per a poder continuar amb la resta de l'exercici.

    ```bash
    rm /opt/fitxer
    ```

6. Munteu la partici√≥ `/opt` i torneu a crear el fitxer per a omplir el directori.

    ```bash
    mount /dev/nvme0n2p3 /opt
    dd if=/dev/urandom of=/opt/fitxer bs=1M count=20480
    ```

7. Ara √∫nicament teniu la partici√≥ `/opt` plena; per√≤ el sistema pot continuar fent tasques:

    ```bash
    apt install htop
    ```

## Simulant una corrupci√≥ a `/home`

En aquest escenari simularem que hem patit una corrupci√≥ a la partici√≥ `/home` i quines eines podem utiltzar per intentar recuperar les dades. B√†sicament editarem alguns bits de la partici√≥ `/home` amb un editor hexadecimal per a simular la corrupci√≥ i despr√©s utilitzarem l'eina `xfs_repair` per a intentar recuperar les dades.

El primer pas que farem ser√† migrar el directori `/home` a una partici√≥ diferent per a poder simular la corrupci√≥. A continuaci√≥, simularem la corrupci√≥ i finalment recuperarem les dades.

Ara podem crear fitxers i directoris al directori `/home` del vostre usuari normal, en el meu cas `jordi`.

```bash
mkdir codi
mkdir dades
touch dades/pokemon.csv
touch codi/main.c
touch codi/Makefile
touch codi/README.md
touch .vim
```

Per a simular una corrupci√≥ editarem alguns valors de la partici√≥ `/home` amb un editor hexadecimal.

1. Desmuntem la partici√≥ `/home`.

    ```bash
    umount /home
    ```

    > **Compte!**: Si esteu connectats per SSH, no podreu desmuntar la partici√≥ `/home` ja que el vostre usuari est√† utilitzant aquesta partici√≥. En la primera sessi√≥. Per tant, haure de fer-ho a la consola de la m√†quina virtual.

2. Obrirem la partici√≥ `/home` amb un editor hexadecimal:
   
```bash
hexedit /dev/nvme0n2p4 
```

3. Modifiqueu bits a l'atzar i deseu els canvis. Per fer-ho escriviu damunt dels valors hexadecimals altres valors. Un cop fet guardeu amb **Ctrl + X i Y**.


4. Ara intentarem muntar la partici√≥ `/home` per a comprovar que ha estat corrompuda.

```bash
mount /home
```

    Si la partici√≥ `/home` s'ha corromput, haur√≠eu de veure un missatge d'error com aquest:

    ![home_corrupte](../../figs/exercises/fs-01/home_corrupte.png)

5. Els diferents sistemes de fitxers tenen eines per a comprovar la integritat dels fitxers. Per exemple, el sistema de fitxers `xfs` t√© l'eina `xfs_ncheck` que permet comprovar la integritat dels fitxers.

    ```bash
    xfs_ncheck /dev/nvme0n2p4
    ```

6. Per a reparar la partici√≥ `/home` utilitzarem l'eina `xfs_repair`.

    ```bash
    xfs_repair /dev/nvme0n2p4
    ```

7. Un cop reparada la partici√≥ `/home`, la muntarem de nou.

    ```bash
    mount /home
    ```

8. Comprovarem que la partici√≥ `/home` s'ha muntat correctament i cont√© els fitxers que hav√≠em creat.

    ```bash
    ls /home
    ```
